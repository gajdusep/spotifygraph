{"version":3,"sources":["store/reducers.tsx","components/welcome-page.tsx","methods/graph-parsing-methods.tsx","methods/spotify-methods.tsx","store/types.tsx","store/actions.tsx","components/login-page.tsx","methods/graph-layout.tsx","methods/edge-calculation.tsx","components/artist-edge.tsx","methods/colors.tsx","components/artist-node.tsx","components/chosen-cluster-graph-precomputed.tsx","components/chosen-artist-bar.tsx","components/chosen-cluster.tsx","components/cluster-node.tsx","components/cluster-edge.tsx","components/draggable-canvas.tsx","components/player.tsx","components/page-content.tsx","components/side-bar.tsx","components/my-graph-page.tsx","App.tsx","index.tsx"],"names":["middleWare","loggerMiddleware","createLogger","predicate","getState","action","process","collapsed","push","thunk","getInitialState","isGraphLoadingError","graphLoaded","graphLoading","chosenArtistLoading","userLoggedIn","graph","clusters","clusterEdges","artistEdges","clusterSquares","artistDict","spotifyWebApiObject","SpotifyWebApi","graphLoadingRelatedArtistsProgress","graphLoadingMessage","paused","isGraphFromFileLoaded","nonFavouriteArtistDict","rootReducer","state","reducer","WelcomePage","props","className","onClick","history","React","Component","withRouter","connect","loggedIn","parseClusters","artistsDict","clusterJsons","i","length","key","id","clusterArtists","clusterArtistsPositions","Object","entries","artistsPositions","artistsSpotifyId","artistPosition","x","y","sort","a","b","score","currCluster","genres","artistsIds","map","aFull","country","processClusterPositions","positions","square","clusterSquare","values","asyncTimeout","ms","Promise","resolve","setTimeout","getCookie","name","document","cookie","xsrfCookies","split","c","trim","filter","startsWith","decodeURIComponent","songFromJSONData","element","preview_url","console","debug","previewLink","artists","externalUrl","external_urls","spotify","getFollowedArtistsIds","sp","limit","result","maxRetries","after","success","retries","options","getFollowedArtists","response","getResponseHeader","parseInt","headers","isUndefined","items","artObj","cursors","getAllRelatedArtists","artistsToExploreIds","alreadyLoadedRelatedArtists","progressBarCallback","artistsToExploreLen","aID","getArtistRelatedArtists","obtainedRelArtists","objectFull","getLikedSongs","offset","next","getMySavedTracks","trackObj","track","getArtistsIdsFromLikedSongs","likedSongs","likedSongsArtistsIdsNonDistinct","objectTrackFull","reduce","acc","currVal","concat","artistObjectSimplified","Set","getAllArtistsFull","allArtistsIds","getArtists","slice","createArtistDictWithFullInformation","artistsFull","relatedArtistsFinal","followedArtistsIdsSet","dictToReturn","artist","artistImage","images","url","isFollowed","has","popularity","followedScore","image","relatedArtistsIds","song","j","songArtist","simplArtist","art","dictArtistFullToReduced","artistsDictFull","artistsDictReduced","artFull","fetchAllDataFromSpotify","accessToken","setStateCallback","setGraphLoadingMessageFunction","setGraphLoadingProgress","setAccessToken","likedSongsArtistsIds","followedArtistsIds","relatedArtistsStorageName","storageRelatedArtistsValue","localStorage","getItem","JSON","parse","setItem","stringify","csfrtoken","calculateGraphLink","jsonReponse","fetch","method","body","fetchReponse","ok","json","status","statusText","alert","blbostToDelete","join","artistEdgesJSONs","edge","id1","id2","weight","clusterEdgesJsons","g","PositionType","t","setChosenArtist","type","payload","produce","chosenArtist","setChosenCluster","cluster","chosenCluster","setGraph","setGraphLoadingMessage","message","progress","graphLoadingSuccess","setChosenArtistError","error","chosenArtistError","setChosenArtistLoading","loading","setChosenArtistData","artistData","chosenArtistData","setPaused","graphFromFileIsLoaded","isLoaded","validateGraphObject","jsonToValidate","validationResult","decode","isRight","LoginPage","p","params","client_id","response_type","redirect_uri","scope","kv","encodeURIComponent","window","location","assign","this","spotifyLoginLink","to","loginWithSpotify","setUserLoggedIn","somestupidfunction","clusterInComponent","clusterComponents","freeRectMatrix","possibleRectanglePositions","notUsedClusterComponents","finalPositions","freeRectMatrixRows","freeRectMatrixCols","wholeLoop","foundSomeCoords","clusterComponent","rowLoop","row","col","coordCombinations","coordIndex","coordArray","isLegit","every","rIndex","cIndex","clusterIds","keys","k","rect","left","top","notUsedIndex","computeClusterPositions","width","height","clusterWidth","clusterHeigth","toRet","oneClusterComponents","twoClusterComponents","threeClusterComponents","bigComponent","clustersInSquares","screenParams","bigClusterSquares","clusterId","clusterPosition","newX","newY","getBigComponentsPositions","currentHeight","rectangles","pos","getPossibleFreePositions","notUsedThreeClusterComponents","notUsedTwoClusterComponents","notUsedOneClusterComponents","newRects","currentY","currentX","middleX","middleY","circleRadius","angle","Math","random","coords","cos","PI","sin","squareChange","clusterRect","hasCollisions","getRestComponentsPositions","computeHeigthFromPositions","maxY","_colliding","start1","end1","start2","end2","rects","res","r","rect2","rect1","clusterHeight","numberToWidth","floor","numberToheight","noRectangles","computeEdgeCoordinates","x1","y1","x2","y2","thickness","wid","hei","y1fin","y2fin","x1fin","x2fin","ArtistEdge","weigth","st","artistWidth","edgeColor","maximumEdgeWeigth","style","d","strokeWidth","fill","stroke","COLORS","lightAzureBlue","darkAzureBlue","pink","green","grey","ArtistNode","currentPositionX","positionX","currentPositionY","positionY","dragging","onDrag","bind","onStop","e","ui","stopPropagation","preventDefault","setState","newCurrX","deltaX","newCurrY","deltaY","positionChangedCallback","handleClick","setChosenArtistDataAllFunc","color","artistImageDivStyle","backgroundImage","backgroundSize","borderRadius","alignSelf","minimumScore","bounds","defaultPosition","backgroundColor","dispatch","s","notLikedSongs","artistToUpdate","areSongsEqual","s1","s2","getArtistTopTracks","then","topTracks","currentArtistId","currArtistToUpdate","tracks","songToCheck","indexOfLiked","findIndex","likedSong","artistsToUpdate","currentNotFavouriteDict","favouriteDict","catch","finally","setChosenArtistDataAll","ChosenClusterGraphPrecomputed","boxRef","wrapperRef","getIdArtistDictAndSliderLimits","idArtistDict","artistsSliderLimits","edgesSliderLimits","nodes","artistSliderValue","minimum","edgesSliderValue","descriptionHover","minimumEdgeWeight","createRef","positionChangedHandler","changeArtistSliderValue","changeEdgeSliderValue","prevprops","prevstate","graphElements","prepareAfterGraphDataUpdate","prepareAfterSliderUpdate","maximum","node","edges","ceil","current","clientWidth","clientHeight","omg","createNodes","elem","artist_id","newArtistsPositions","compX","position","compY","node1id","node2id","edgeWeigth","clusterEdgeKey","node1","node2","err","currentTarget","valueAsNumber","min","max","step","value","onChange","showDescriptionStyle","display","handle","createEdgeSlider","createArtistSlider","onMouseEnter","changeHover","onMouseLeave","size","ref","getDraggableSlider","createEdges","ChosenArtistBar","prepareSongs","liked","notLiked","chosenSongId","songId","prevProps","prevState","includes","maxHeight","playerIcon","setSongToPlay","chosenSongColorIndicator","songToPlay","setPause","likedSongColorIndicator","setChosenSong","marginRight","flexDirection","justifyContent","alignContent","open","spotifyApiObject","addToMySavedTracks","likedSongsOld","notLikedSongsOld","songs","toReturn","getSongDiv","margin","getSongsDivs","ChosenCluster","closeChosenClusterGraph","closeChosenArtist","elements","getChosenClusterGraphElements","currArtistId","clusterEdgesWithChosenCluster","clusterEdge","similarClusters","artistDivStyle","secondId","similarCluster","indexOf","similarClusterArtistsElements","artistId","currArtist","artistDivStyleNew","title","getSimilarClusters","undefined","countries","require","registerLocale","ClusterNode","fontSizeDefault","oldX","oldY","positionChanged","imgSize","rows","number_of_artists","currKey","l","createArtistWrapper","createEmptyWrapper","headerString","numberOfGenres","fontSizeConst","wrapperStyle","opacity","zIndex","alignItems","countryCode","alpha3ToAlpha2","svg","fontSize","clusterDiv","onStart","ClusterEdge","ProgressBar","DraggableCanvas","currentScale","originalRefHeight","originalRefWidth","newHeight","newHeigth","dimensions","w","h","clusterPositions","source","target","log2","notOverlappedPositions","getClusterPositions","origWidth","origHei","newWidth","currentPositions","ratio","addEventListener","onResizeRecomputePositions","loadGraph","graphLoadedCallback","spotifyError","clusterIsChosen","defaultScale","defaultPositionX","defaultPositionY","maxScale","limitToWrapper","onWheelStop","scale","zoomIn","zoomOut","setTransform","Fragment","callback","Player","playerRef","pause","play","mp3Link","artistsDescriptionNames","favouriteArtistDict","artistsDescription","onPlay","onPause","autoPlay","controls","src","PageContent","SideBar","dowloadGraph","uploadGraph","chosenClusterArtists","properties","createElement","setAttribute","appendChild","click","removeChild","selectorFiles","corruptedFileAlert","log","file","reader","FileReader","onload","event","resultString","toString","loadGraphFromFile","loadGraphFromFileFunc","readAsText","alt","accept","files","chosenClusterProperties","jsonToParse","MyGraphPage","loggingLoading","loggingFailed","afterSpotifyLogin","query","search","substr","forEach","part","item","currentPathName","pathname","linkToBackend","tryAccessToken","get","storeInstance","createStore","compose","applyMiddleware","App","store","basename","path","component","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.170f6603.chunk.js","sourcesContent":["import { createStore, applyMiddleware, compose } from 'redux';\nimport { State, ActionWrapper } from './types';\nimport thunk from 'redux-thunk';\nimport { createLogger } from 'redux-logger';\nimport SpotifyWebApi from 'spotify-web-api-js'\n\nconst middleWare: any = [];\nconst loggerMiddleware = createLogger({\n    predicate: (getState: Function, action: ActionWrapper) => process.env.NODE_ENV === 'development' && action.type !== 'SET_GRAPH_LOADING_MESSAGE',\n    collapsed: (getState, action) => true\n});\nmiddleWare.push(thunk)\nmiddleWare.push(loggerMiddleware)\n\n\nconst getInitialState = (): State => {    \n    return ({    \n        isGraphLoadingError: false,\n        graphLoaded: false,\n        graphLoading: false,\n        chosenArtistLoading: false,\n        userLoggedIn: false,\n        graph: ({clusters:[], clusterEdges:[], artistEdges:[], clusterSquares:[], artistDict: {}}),\n        spotifyWebApiObject: new SpotifyWebApi(),\n        graphLoadingRelatedArtistsProgress: 0,\n        graphLoadingMessage: \"\",\n        paused: false,\n        isGraphFromFileLoaded: false,\n        nonFavouriteArtistDict: {}\n    })\n} \n\nconst rootReducer = (\n    state: State = getInitialState(),\n    action: ActionWrapper<any>\n) => {\n    if (!action.reducer) return state\n    else return action.reducer(state)\n}\n\nconst createStoreInstance = () => createStore(\n    rootReducer, \n    getInitialState(), \n    compose(\n        applyMiddleware(...middleWare)\n    ))\n\nexport { createStoreInstance }\n","/* eslint-disable @typescript-eslint/no-useless-constructor */\n\nimport React from 'react'\nimport { connect } from 'react-redux'\nimport { withRouter } from 'react-router-dom'\nimport { RouteComponentProps } from 'react-router'\nimport { State } from '../store/types'\n\nimport './welcome-page.css'\nimport '../App.css'\n\ninterface WelcomePageProps extends RouteComponentProps<any> {        \n    loggedIn: boolean\n}\n\nclass WelcomePage extends React.Component<WelcomePageProps, {}> {\n    constructor(props: WelcomePageProps) {\n        super(props);\n        const redirect_uri = process.env.NODE_ENV === \"production\" ? \n            process.env.REACT_APP_PROD_SPOTIFY_REDIRECT_URL : process.env.REACT_APP_DEV_SPOTIFY_REDIRECT_URL\n    }\n    \n    render() {    \n        return (\n            <div className=\"App\">\n                <div className=\"page-wrapper\">\n                    <div className=\"page-description-div\">\n                        <h1>Spotify graph</h1>\n                        <p>a project that will show you your musical taste in form of a graph</p>\n                    </div>\n                    <button className=\"very-big-button\" onClick={() => {this.props.history.push('/login')}}>Continue to get your graph</button>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default withRouter<WelcomePageProps,any>(\n    connect(\n        (state:State) => ({\n            loggedIn: state.userLoggedIn\n        }),\n        {}\n    )(WelcomePage))\n","import { ArtistFull, Cluster, ArtistEdge, ClusterEdge, ClusterSquare, StringDict, Position, NumberDict } from '../store/types'\n\ninterface clusterJson {\n    id: string\n    genres: string[]\n    country: string\n    artistsPositions: NumberDict<Position>\n}\n\nexport const parseClusters = (artistsDict: StringDict<ArtistFull>, clusterJsons: clusterJson[]): Cluster[] => {\n    let clusters: Cluster[] = []\n    for (let i = 0; i < clusterJsons.length; i++) {\n        const key = clusterJsons[i].id\n\n        // prepare the cluster artists:\n        const clusterArtists: ArtistFull[] = []\n        const clusterArtistsPositions: StringDict<Position> = {}\n\n        for (const [artistsSpotifyId, artistPosition] of Object.entries(clusterJsons[i].artistsPositions)) {\n            clusterArtists.push(artistsDict[artistsSpotifyId])\n            clusterArtistsPositions[artistsSpotifyId] = {x:artistPosition.x, y:artistPosition.y}\n        }\n\n        clusterArtists.sort((a,b) => {return b.score - a.score})\n\n        const currCluster: Cluster = ({\n            id: key,\n            genres: clusterJsons[i].genres,\n            artistsIds: clusterArtists.map(aFull => aFull.id),\n            artistsPositions: clusterArtistsPositions,\n            country: clusterJsons[i].country\n        })\n        clusters.push(currCluster)\n    }\n    return clusters\n}\n\ninterface ClusterSquareJSON {\n    [id: string]: {x:number, y:number}\n}\n\nexport const processClusterPositions = (positions: ClusterSquareJSON[]): ClusterSquare[] => {\n    let clusterSquares: ClusterSquare[] = []\n    for (let i = 0; i < positions.length; i++) {\n        \n        const square = positions[i]\n        const clusterSquare: ClusterSquare = {};\n        if (Object.values(square).length > 0) {\n            for (let id in square) {\n                let x = square[id].x\n                let y = square[id].y\n                clusterSquare[id] = {x: x, y: y}\n            }\n            clusterSquares.push(clusterSquare)\n        }\n    }\n\n    return clusterSquares\n}\n\ninterface ClusterEdgeJSON {\n    id1: string,\n    id2: string,\n    weight: number\n}\n\nexport const parseClusterEdges = (clusterEdgesJsons: ClusterEdgeJSON[]): ClusterEdge[] => {\n    return clusterEdgesJsons.map(element => ({ id1: element.id1, id2: element.id2, weight: element.weight })\n    )\n}\n\ninterface ArtistEdgeJSON {\n    id1: string,\n    id2: string,\n    weight: number\n}\n\nexport const parseArtistEdges = (artistEdgesJSONs: ArtistEdgeJSON[]): ArtistEdge[] => {\n    let artistEdges: ArtistEdge[] = artistEdgesJSONs.map((edge) => ({id1: edge.id1, id2: edge.id2, weight: edge.weight}))\n    return artistEdges\n}\n","import SpotifyWebApi from 'spotify-web-api-js'\nimport { ArtistFull, ArtistReduced, StringDict, Graph, SongFull } from '../store/types';\nimport { processClusterPositions, parseClusters, parseClusterEdges, parseArtistEdges } from './graph-parsing-methods'\nimport { isUndefined } from 'util';\n\n// requests retry interval\nconst RETRY_INTERVAL = 4000\n\n// parameters for score computing\nconst isFollowedConst = 5\nconst likedSongConst = 1\nconst spotifyPopularityConst = 0.1\n\nconst asyncTimeout = (ms:number) => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nconst getCookie = (name: string): string => {\n    if (!document.cookie) {\n        return ''\n    }\n\n    const xsrfCookies = document.cookie.split(';')\n        .map(c => c.trim())\n        .filter(c => c.startsWith(name + '='));\n\n    if (xsrfCookies.length === 0) {\n        return ''\n    }\n    return decodeURIComponent(xsrfCookies[0].split('=')[1]);\n}\n\nexport const songFromJSONData = (element: SpotifyApi.TrackObjectFull): SongFull => {\n    if (element.preview_url === null) {\n        console.debug(element.id, ':', element.name, element)\n    }\n    \n    return {\n        name: element.name, \n        id: element.id,\n        previewLink: element.preview_url,\n        artistsIds: element.artists.map(a => a.id),\n        externalUrl: element.external_urls.spotify\n    }\n}\n\nconst getFollowedArtistsIds = async (sp: SpotifyWebApi.SpotifyWebApiJs\n): Promise<string[]> => {\n    let limit = 50\n    let result: string[] = []\n\n    let response\n    const maxRetries = 3\n    let after = null\n    do {\n        let success = true\n        let retries = 0\n        do {\n            try {\n                const options: {} = after ? {limit:limit, after: after} : {limit:limit}\n                response = await sp.getFollowedArtists(options)\n            } catch(err) {\n                await asyncTimeout(err.getResponseHeader['retry-after'] ? parseInt(err.headers['retry-after']+1) * 1000 : RETRY_INTERVAL);\n                success = false\n                retries += 1\n            }\n        } while(success === false && retries < maxRetries)\n                \n        // the request was not successfull even after retries\n        if (isUndefined(response)) {\n            after = null\n        }\n        else {\n            result.push(...response.artists.items.map((artObj: SpotifyApi.ArtistObjectFull) => artObj.id))\n            after = response.artists.cursors.after\n        }\n    } while(after)\n    \n    return result\n}\n\nconst getAllRelatedArtists = async (\n    sp: SpotifyWebApi.SpotifyWebApiJs,\n    artistsToExploreIds: string[],\n    alreadyLoadedRelatedArtists: StringDict<string[]>,\n    progressBarCallback: Function\n): Promise<string[][]> => {\n    const result: string[][] = []\n    const maxRetries = 3\n    const artistsToExploreLen = artistsToExploreIds.length\n\n    for (let i = 0; i < artistsToExploreLen; i++) {\n        const aID = artistsToExploreIds[i]\n        progressBarCallback(i / artistsToExploreLen)\n\n        if (aID in alreadyLoadedRelatedArtists) {\n            result.push(alreadyLoadedRelatedArtists[aID])\n        } else {\n            let response\n            let success = true\n            let retries = 0\n            do {\n                try {\n                    response = await sp.getArtistRelatedArtists(aID)\n                } catch(err) {\n                    await asyncTimeout(err.getResponseHeader['retry-after'] ? parseInt(err.headers['retry-after']+1) * 1000 : RETRY_INTERVAL);\n                    success = false\n                    retries += 1\n                }\n            } while(success === false && retries < maxRetries)\n            \n            if (isUndefined(response)) {\n                result.push([])\n            }\n            else {\n                const obtainedRelArtists = response.artists.map((objectFull) => objectFull.id)\n                alreadyLoadedRelatedArtists[aID] = obtainedRelArtists\n                result.push(obtainedRelArtists)\n            }\n        }        \n    }\n    return result\n}\n\nconst getLikedSongs = async (sp: SpotifyWebApi.SpotifyWebApiJs\n): Promise<SpotifyApi.TrackObjectFull[]> => {\n    let offset = 0\n    let limit = 50\n    let result: SpotifyApi.TrackObjectFull[] = []\n\n    let response\n    const maxRetries = 3\n    let next = null\n    do {\n        let success = true\n        let retries = 0\n        do {\n            try {\n                response = await sp.getMySavedTracks({limit: 50, offset: offset})\n            } catch(err) {\n                await asyncTimeout(err.getResponseHeader['retry-after'] ? parseInt(err.headers['retry-after']+1) * 1000 : RETRY_INTERVAL);\n                success = false\n                retries += 1\n            }\n        } while(success === false && retries < maxRetries)\n                \n        // the request was not successfull even after retries\n        if (isUndefined(response)) {\n            next = null\n        }\n        else {\n            offset += limit\n            result.push(...response.items.map((trackObj: SpotifyApi.SavedTrackObject) => trackObj.track))\n            next = response.next\n        }\n    } while(next)\n\n    return result\n}\n\nconst getArtistsIdsFromLikedSongs = (likedSongs: SpotifyApi.TrackObjectFull[]) => {\n    const likedSongsArtistsIdsNonDistinct =\n        likedSongs.map((objectTrackFull) => objectTrackFull.artists)\n        .reduce((acc, currVal) => acc.concat(currVal), [])\n        .map((artistObjectSimplified) => artistObjectSimplified.id)\n    return [...new Set(likedSongsArtistsIdsNonDistinct)]\n}\n\nconst getAllArtistsFull = async (sp: SpotifyWebApi.SpotifyWebApiJs, allArtistsIds: string[])\n: Promise<SpotifyApi.ArtistObjectFull[]> => {\n    const result: SpotifyApi.ArtistObjectFull[] = []\n    const maxRetries = 3\n    let offset = 0\n    let limit = 50\n\n    do {\n        let response\n        let success = true\n        let retries = 0\n        do {\n            try {\n                response = await sp.getArtists(allArtistsIds.slice(offset, offset+limit))\n            } catch(err) {\n                await asyncTimeout(err.getResponseHeader['retry-after'] ? parseInt(err.headers['retry-after']+1) * 1000 : RETRY_INTERVAL);\n                success = false\n                retries += 1\n            }\n        } while(success === false && retries < maxRetries)\n    \n        if (isUndefined(response)) {\n            // TODO what here?\n        } else {\n            result.push(...response.artists)\n            offset += limit\n        }\n\n    } while(offset < allArtistsIds.length)\n\n    return result\n}\n\nconst createArtistDictWithFullInformation =  (\n    artistsFull: SpotifyApi.ArtistObjectFull[],\n    relatedArtistsFinal: string[][],\n    followedArtistsIdsSet: Set<string>,\n    likedSongs: SpotifyApi.TrackObjectFull[]\n): StringDict<ArtistFull> => {\n    if (artistsFull.length !== relatedArtistsFinal.length) {\n        console.debug('ERROR: NOT EVERY ARTIST HAS RELATED ARTISTS')\n        return {}\n    }\n\n    const dictToReturn: StringDict<ArtistFull> = {}\n    for (let i = 0; i < artistsFull.length; i++) {\n        const artist = artistsFull[i];\n        const artistImage = artist.images && artist.images.length > 0 ? artist.images[artist.images.length - 1].url : ''\n        const isFollowed = followedArtistsIdsSet.has(artist.id)\n\n        const popularity = artist.popularity\n        const followedScore = isFollowed ? isFollowedConst : 0\n        \n        dictToReturn[artist.id] = {\n            genres: artist.genres,\n            id: artist.id,\n            image: artistImage,\n            isFollowed: isFollowed,\n            likedSongs: [],\n            name: artist.name,\n            relatedArtistsIds: relatedArtistsFinal[i],\n            score: popularity * spotifyPopularityConst + followedScore\n        }\n    }\n\n    for (let i = 0; i < likedSongs.length; i++) {\n        const song = likedSongs[i];\n        for (let j = 0; j < song.artists.length; j++) {\n            const songArtist = song.artists[j]\n            if (songArtist.id in dictToReturn) {\n                dictToReturn[songArtist.id].likedSongs.push({\n                    artistsIds: song.artists.map(simplArtist => simplArtist.id),\n                    externalUrl: song.external_urls.spotify,\n                    name: song.name, \n                    id: song.id,\n                    previewLink: song.preview_url\n                })\n            }\n        }\n    }\n\n    for (let key in dictToReturn) {\n        const art = dictToReturn[key]\n        dictToReturn[key].score += art.likedSongs.length * likedSongConst\n    }\n\n    return dictToReturn\n}\n\nconst dictArtistFullToReduced =\n(artistsDictFull: StringDict<ArtistFull>) : StringDict<ArtistReduced> => {\n    const artistsDictReduced: StringDict<ArtistReduced> = {}\n    for (let key in artistsDictFull) {\n        const artFull = artistsDictFull[key]\n        artistsDictReduced[key] = {\n            id: artFull.id,\n            relatedArtistsIds: artFull.relatedArtistsIds,\n            genres: artFull.genres\n        }\n    }\n    return artistsDictReduced\n}\n\nconst emptyGraph = (): Graph => {\n    return {clusters: [], clusterEdges: [], artistEdges: [], clusterSquares: [], artistDict: {}}\n}\n\nexport const fetchAllDataFromSpotify = async (\n    accessToken: string,\n    sp: SpotifyWebApi.SpotifyWebApiJs,\n    setStateCallback: Function,\n    setGraphLoadingMessageFunction: Function,\n    setGraphLoadingProgress: Function,\n): Promise<Graph>  =>\n{\n    /*\n    1) REQ - liked songs\n    2) artists from liked songs\n    3) REQ - followed artists\n    4) concat from_liked and followed_artists\n    5) REQ - get all artists full objects\n    6) REQ - get related artists of concatenated\n    7) make a dict, {artistsId: artist} - where artist is full artist object (or our Artist type)\n    8) add additional info to the artists:\n        a)OK for every liked song - add to dict the songs\n        b)OK is artist followed?\n        c) calculate artist score\n        d)OK related artists ids (for future work)\n    */\n\n    if (!!!accessToken) return emptyGraph()\n\n    sp.setAccessToken(accessToken)\n\n    // 1) get liked songs\n    const likedSongs = await getLikedSongs(sp)    \n    \n    setGraphLoadingMessageFunction(\"Getting your liked songs from Spotify...\")\n    console.debug('liked songs: ', likedSongs)    \n\n    // 2) artists from liked songs\n    const likedSongsArtistsIds = getArtistsIdsFromLikedSongs(likedSongs)\n    console.debug('liked songs artists ids: ', likedSongsArtistsIds)\n\n    // 3) followed artists\n    setGraphLoadingMessageFunction(\"Getting the artists you follow from Spotify...\")\n    const followedArtistsIds = await getFollowedArtistsIds(sp)\n    console.debug('followed artists ids: ', followedArtistsIds)\n\n    // 4) concat from_liked and followed_artists\n    const allArtistsIds = [...new Set(likedSongsArtistsIds.concat(followedArtistsIds))]\n    // const allArtistsIds = [...new Set(followedArtistsIds)] // debug option for less ids...\n    console.debug('all artists ids: ', allArtistsIds)\n\n    // TODO: else: inform user that he doesn't have anything we want\n    if (allArtistsIds.length < 1) {\n        return emptyGraph()\n    }\n\n    // 5) get all artists full objects\n    setGraphLoadingMessageFunction(\"Getting information about all the artists you are interested it...\")\n    const artistsFull = await Promise.resolve(getAllArtistsFull(sp, allArtistsIds))\n    console.debug('artists full: ', artistsFull);\n    \n    // 6) get related artists of concatenated\n    const relatedArtistsStorageName = \"relatedArtists\"\n    // localStorage.setItem(relatedArtistsStorageName, JSON.stringify({})) // TODO: DELETE THIS AFTER DEBUGGING\n    const storageRelatedArtistsValue = localStorage.getItem(relatedArtistsStorageName)\n    \n    let alreadyLoadedRelatedArtists = {}\n    if (storageRelatedArtistsValue === null) {\n\n    }\n    else {\n        try {\n            alreadyLoadedRelatedArtists = JSON.parse(storageRelatedArtistsValue)\n        } catch {\n            alreadyLoadedRelatedArtists = {}\n        }\n        \n        if (alreadyLoadedRelatedArtists === null) {\n            alreadyLoadedRelatedArtists = {}\n        }\n    }\n    \n    \n    setGraphLoadingMessageFunction(\"Getting information about the related artists of all of your favourite artists... \\n This might take a while :(\")\n    // const relatedArtistsFinal = await Promise.resolve(getRelatedArtists(sp, allArtistsIds, 0, alreadyLoadedRelatedArtists, setGraphLoadingProgress))\n    const relatedArtistsFinal = await getAllRelatedArtists(sp, allArtistsIds, alreadyLoadedRelatedArtists, setGraphLoadingProgress)\n    localStorage.setItem(relatedArtistsStorageName, JSON.stringify(alreadyLoadedRelatedArtists))\n    console.debug('related artists final', relatedArtistsFinal)\n\n    // 7,8) make a dict, add aditional info\n    const artistDict = createArtistDictWithFullInformation(\n        artistsFull,\n        relatedArtistsFinal,\n        new Set(followedArtistsIds),\n        likedSongs\n    )\n    console.debug('artist dict', artistDict)\n\n    const csfrtoken = getCookie('csrftoken')\n    \n    setGraphLoadingMessageFunction(\"We have all the data we need, now computing the graph!\")\n    \n    let calculateGraphLink = process.env.NODE_ENV === \"production\" ? process.env.REACT_APP_PROD_BACKEND_URL_CALCULATE_GRAPH : process.env.REACT_APP_DEV_BACKEND_URL_CALCULATE_GRAPH\n    if (isUndefined(calculateGraphLink)) return emptyGraph()\n    \n    let jsonReponse:any = {}\n    // TODO: set some global state of error, co dela 404, 500 atd..? \n    try {\n        const fetchReponse = await fetch(calculateGraphLink, {\n            method: 'POST',\n            body: JSON.stringify(dictArtistFullToReduced(artistDict)),\n            headers: {\n                // access token..\n                'Content-Type': 'application/json',\n                'X-CSRFToken': csfrtoken,\n                // 'X-Api-Key': accessToken\n            }\n        })\n        if (fetchReponse.ok) {  // TODO tohle asi nestaci..\n            jsonReponse = await fetchReponse.json()\n        } else {\n            throw {\n                json: await fetchReponse.json(),\n                status: fetchReponse.status,\n                statusText: fetchReponse.statusText\n            }\n        }\n    } catch (requestError) {\n        if (requestError.json) {\n            alert(requestError.json['message'])\n            return emptyGraph()\n        }\n    }    \n    \n    setStateCallback({blbostToDelete: allArtistsIds.join('\\n')})\n\n    console.debug(jsonReponse)\n\n    const artistEdges = parseArtistEdges(jsonReponse.artistEdges)\n\n    const clusters = parseClusters(artistDict, jsonReponse.clusters)\n\n    const clusterEdges = parseClusterEdges(jsonReponse.clusterEdges)\n\n    const clusterSquares = processClusterPositions(jsonReponse.clusterSquares)\n\n    const g = new Promise<Graph>(resolve => resolve({\n        artistEdges: artistEdges,\n        clusters: clusters,\n        clusterEdges: clusterEdges,\n        clusterSquares: clusterSquares,\n        artistDict: artistDict,\n    }\n    ))\n    \n    console.debug('graph from spotify fetch:', await g)\n    return g\n}\n","import { ThunkAction } from 'redux-thunk'\nimport SpotifyWebApi from 'spotify-web-api-js'\nimport * as t from 'io-ts'\nimport { IoMdStar } from 'react-icons/io'\n\nexport interface StringDict<T> {\n    [id: string]: T\n}\n\nexport interface NumberDict<T> {\n    [id: number]: T\n}\n\nexport const PositionType = t.type({\n    x: t.number,\n    y: t.number\n})\n\nexport type Position = t.TypeOf<typeof PositionType>\n\nexport interface SongFull {\n    artistsIds: string[]\n    externalUrl: string\n    id: string\n    name: string\n    previewLink: string\n}\n\nexport interface SongReduced {\n    id: string\n    name: string    \n}\n\nexport interface ArtistFull {\n    genres: string[]\n    id: string\n    image: string\n    isFollowed: boolean\n    likedSongs: SongFull[]\n    name: string\n    relatedArtistsIds: string[]\n    score: number\n}\n\nexport interface ArtistReduced {\n    genres: string[],\n    id: string,\n    relatedArtistsIds:string[]\n}\n\nexport interface ArtistSimplified {    \n    id: string,\n    name: string\n}\n\nexport interface ArtistEdge {\n    id1: string\n    id2: string\n    weight: number\n}\n\nexport interface Cluster {\n    id: string\n    genres: string[]\n    artistsIds: string[]\n    artistsPositions: StringDict<Position>\n    country?: string\n}\n\nexport interface ClusterEdge {\n    id1: string\n    id2: string\n    weight: number\n}\n\nexport interface ClusterSquare {\n    [clusterId: string]: Position\n}\n\nexport interface Graph {\n    clusters: Cluster[]\n    clusterEdges: ClusterEdge[]\n    artistDict: StringDict<ArtistFull>\n    artistEdges: ArtistEdge[]\n    clusterSquares: ClusterSquare[]\n}\n\nexport interface ChosenArtistData {\n    notLikedSongs: SongFull[]\n    likedSongs: SongFull[]\n}\n\nexport interface State {\n    chosenCluster?: Cluster\n\n    chosenArtist?: ArtistFull\n    chosenArtistData?: ChosenArtistData\n    chosenArtistError?: string\n    chosenArtistLoading: boolean\n\n    graph: Graph\n\n    // access variables\n    userLoggedIn: boolean\n    accessToken?: string\n\n    // the song being played\n    songToPlay?: SongFull\n    nonFavouriteArtistDict: StringDict<ArtistSimplified>\n\n    // the state indicating the graph loading process\n    graphLoaded: boolean\n    graphLoading: boolean\n    isGraphLoadingError: boolean\n    graphLoadingErrorMessage?: string\n\n    graphLoadingMessage: string\n    graphLoadingRelatedArtistsProgress: number\n\n    isGraphFromFileLoaded: boolean\n\n    // prepared spotify web api for requests:\n    spotifyWebApiObject: SpotifyWebApi.SpotifyWebApiJs\n\n    // player state\n    paused: boolean\n}\n\nexport interface ActionWrapper<Payload = undefined> {\n  type: string\n  payload?: Payload\n  reducer: (state: State) => State\n}\n\nexport type ThunkActionWrapper<T> = ThunkAction<Promise<T>, State, {}, ActionWrapper<any>>\n","import { produce } from 'immer'\nimport { ActionWrapper, ThunkActionWrapper, State, ArtistFull, Cluster, Graph, SongFull, ChosenArtistData, ArtistSimplified } from './types'\nimport SpotifyWebApi from 'spotify-web-api-js'\nimport { isUndefined } from 'util'\nimport { fetchAllDataFromSpotify, songFromJSONData } from '../methods/spotify-methods'\nimport { PositionType } from './types'\nimport { isRight } from 'fp-ts/lib/Either'\n\nexport const setAccessToken = (accessToken: string): ActionWrapper<string> => ({\n    type: 'SET_ACCESS_TOKEN',\n    payload: accessToken,\n    reducer: produce((state: State) => {\n        state.accessToken = accessToken\n        state.userLoggedIn = true\n    })\n})\n\nexport const setUserLoggedIn = (): ActionWrapper<void> => ({\n    type:'LOG_IN',\n    reducer: produce((state: State) => {\n        state.userLoggedIn = true\n    })\n})\n\nexport const logOut = (): ActionWrapper<void> => ({\n    type: 'LOG_OUT',\n    reducer: produce((state: State) => {\n        state.accessToken = undefined\n        state.userLoggedIn = false\n    })\n})\n\nexport const setChosenArtist = (artist: ArtistFull): ActionWrapper<ArtistFull> => ({\n    type: 'SET_CHOSEN_ARTIST',\n    payload: artist,\n    reducer: produce((state: State) => {\n        state.chosenArtist = artist\n    })\n})\n\nexport const setChosenCluster = (cluster: Cluster): ActionWrapper<Cluster> => ({\n    type: 'SET_CHOSEN_CLUSTER',\n    payload: cluster,\n    reducer: produce((state: State) => {\n        state.chosenCluster = cluster\n    })\n})\n\nexport const clearChosenClusterAndArtist = (): ActionWrapper<void> => ({\n    type: 'CLEAR_CHOSEN_CLUSTER_ARTIST',\n    reducer: produce((state: State) => {\n        state.chosenCluster = undefined\n        state.chosenArtist = undefined\n    })\n})\n\nexport const closeChosenClusterGraph = (): ActionWrapper<void> => ({\n    type: 'CLOSE_CHOSEN_CLUSTER_GRAPH',\n    reducer: produce((state: State) => {\n        state.chosenCluster = undefined\n    })\n})\n\nexport const closeChosenArtist = (): ActionWrapper<void> => ({\n    type: 'CLOSE_CHOSEN_ARTIST',\n    reducer: produce((state: State) => {\n        state.chosenArtist = undefined\n    })\n})\n\nexport const setGraph = (graph: Graph): ActionWrapper<Graph> => ({\n    type: 'SET_GRAPH',\n    payload: graph,\n    reducer: produce((state: State) => {\n        state.graph = graph\n    })\n})\n\nexport const setGraphArtists = (artists: ArtistFull[]): ActionWrapper<ArtistFull[]> => ({\n    type: 'SET_GRAPH_ARTISTS',\n    payload: artists,\n    reducer: produce((state: State) => {\n        state.graphLoading = false\n        state.graphLoaded = true\n    })\n})\n\nexport const graphLoading = (): ActionWrapper<void> => ({\n    type: 'GRAPH_LOADING',\n    reducer: produce((state: State) => {\n        state.graphLoading = true\n    })\n})\n\nexport const setGraphLoadingMessage = (message: string): ActionWrapper<string> => ({\n    type: 'SET_GRAPH_LOADING_MESSAGE',\n    reducer: produce((state: State) => {\n        state.graphLoadingMessage = message\n    })\n})\n\nexport const setGraphLoadingProgress = (progress: number): ActionWrapper<number> => ({\n    type: 'SET_GRAPH_LOADING_MESSAGE',\n    reducer: produce((state: State) => {\n        state.graphLoadingRelatedArtistsProgress = progress\n    })\n})\n\nexport const graphLoadingError = (): ActionWrapper<void> => ({\n    type: 'GRAPH_LOADING_ERROR',\n    reducer: produce((state: State) => {\n        state.graphLoading = false\n        state.isGraphLoadingError = true\n    })\n})\n\nexport const graphLoadingSuccess = (): ActionWrapper<void> => ({\n    type: 'GRAPH_LOADING_SUCCESS',\n    reducer: produce((state: State) => {\n        state.graphLoading = false\n        state.graphLoaded = true\n    })\n})\n\nexport const setChosenArtistError = (error: string): ActionWrapper<string> => ({\n    type: 'SET_CHOSEN_ARTIST_ERROR',\n    payload: error,\n    reducer: produce((state: State) => {\n        state.chosenArtistError = error\n    })\n})\n\nexport const setChosenArtistLoading = (loading: boolean): ActionWrapper<boolean> => ({\n    type: 'SET_CHOSEN_ARTIST_LOADING',\n    payload: loading,\n    reducer: produce((state: State) => {\n        state.chosenArtistLoading = loading\n    })\n})\n\nexport const setChosenArtistData = (artistData: ChosenArtistData, chosenArtist: ArtistFull): ActionWrapper<ChosenArtistData> => ({\n    type: 'SET_CHOSEN_ARTIST_DATA',\n    payload: artistData,\n    reducer: produce((state: State) => {\n        state.chosenArtistData = artistData\n        state.chosenArtist = chosenArtist\n    })\n})\n\nexport const setSongToPlay = (song: SongFull): ActionWrapper<SongFull> => ({\n    type: 'SET_SONG_TO_PLAY',\n    payload: song,\n    reducer: produce((state: State) => {\n        if (!!!state.songToPlay || state.songToPlay.id !== song.id) {\n            state.songToPlay = song\n            state.paused = false\n        }\n    })\n})\n\nexport const setPaused = (paused: boolean): ActionWrapper<boolean> => ({\n    type: 'SET_PAUSED',\n    payload: paused,\n    reducer: produce((state: State) => {\n        state.paused = paused\n    })\n})\n\nexport const setSpotifyApi = (accessToken: string): ActionWrapper<string> => ({\n    type: 'SET_SPOTIFY_API',\n    payload: accessToken,\n    reducer: produce((state:State) => {\n        try {\n            const sApi = state.spotifyWebApiObject\n            sApi.setAccessToken(accessToken)\n            state.spotifyWebApiObject = sApi\n        } catch (error) {\n            console.debug(error)\n        }        \n        console.debug('SET SPOTIFY API')         \n    })\n})\n\nconst updateNotFavouriteArtists = (artistsToUpdate: ArtistSimplified[]): ActionWrapper<any> => ({\n    type: 'UPDATE_NOT_FAVOURITE_ARTISTS',\n    payload: artistsToUpdate,\n    reducer: produce((state: State) => {\n        const currentNotFavouriteDict = state.nonFavouriteArtistDict\n        const favouriteDict = state.graph.artistDict\n\n        for (let i = 0; i < artistsToUpdate.length; i++) {\n            const element = artistsToUpdate[i];\n            if (element.id in favouriteDict) {\n                // don't add\n            }\n            else {\n                currentNotFavouriteDict[element.id] = element\n            }\n        }\n        state.nonFavouriteArtistDict = currentNotFavouriteDict\n    })\n})\n\nconst artistsFromSongJSON = (element: SpotifyApi.TrackObjectFull, currentArtistId: string): ArtistSimplified[] => {\n    const toRet: ArtistSimplified[] = element.artists.reduce((result: ArtistSimplified[], a: SpotifyApi.ArtistObjectSimplified) => {\n        if (a.id !== currentArtistId) result.push({id: a.id, name: a.name })\n        return result\n    }, [])\n    return toRet\n}\n\n// TODO WHAT IS THIS?\nexport const setChosenArtistDataAll = (\n    chosenArtist: ArtistFull, \n    accessToken: string\n): ThunkActionWrapper<void> => async (dispatch): Promise<void> => {\n    if (isUndefined(accessToken) || accessToken === null || accessToken === \"\") {\n        dispatch(setChosenArtistError('The token was not loaded, cannot obtain the artist data.'))\n        return\n    }\n\n    dispatch(setChosenArtist(chosenArtist))\n    dispatch(setChosenArtistLoading(true))\n    let s = new SpotifyWebApi();\n    s.setAccessToken(accessToken)\n    \n    const likedSongs: SongFull[] = []\n    const notLikedSongs: SongFull[] = []\n    let artistToUpdate: ArtistSimplified[] = []\n    \n    const areSongsEqual = (s1: SongFull, s2: SongFull) => {\n        return (s1.id === s2.id || s1.name === s2.name)\n    }\n\n    s.getArtistTopTracks(chosenArtist.id, 'CZ')  // TODO: what's the country code? -_-\n    .then(topTracks => {\n        for (let i = 0; i < topTracks.tracks.length; i++) {\n            const currArtistToUpdate = artistsFromSongJSON(topTracks.tracks[i], chosenArtist.id)\n            artistToUpdate = artistToUpdate.concat(currArtistToUpdate)\n            const songToCheck = songFromJSONData(topTracks.tracks[i])\n            const indexOfLiked = chosenArtist.likedSongs.findIndex(likedSong => areSongsEqual(songToCheck, likedSong))\n            \n            if (indexOfLiked === -1) {\n                notLikedSongs.push(songToCheck)\n            }\n            else {\n                if (songToCheck.previewLink === \"\") {\n                    songToCheck.previewLink = chosenArtist.likedSongs[indexOfLiked].previewLink\n                }\n                likedSongs.push(songToCheck)\n            }\n        }\n\n        for (let i = 0; i < chosenArtist.likedSongs.length; i++) {\n            const element = chosenArtist.likedSongs[i];\n            const indexOfLiked = likedSongs.findIndex(likedSong => areSongsEqual(element, likedSong))\n            if (indexOfLiked === -1) {\n                likedSongs.push(element)\n            }\n            \n        }\n\n        dispatch(updateNotFavouriteArtists(artistToUpdate))\n        dispatch(setChosenArtistData({likedSongs: likedSongs, notLikedSongs: notLikedSongs}, chosenArtist))\n    })\n    .catch((error:string) => {\n        console.debug(error)\n        dispatch(setChosenArtistError('During the artist data fetching, the following error occured:' + error))                \n    })\n    .finally(() => {\n        dispatch(setChosenArtistLoading(false))\n    })\n}\n\nexport const loadGraph = (accessToken: string, sp:SpotifyWebApi.SpotifyWebApiJs, callback: Function): ThunkActionWrapper<void> => \nasync (dispatch): Promise<void> => {\n    dispatch(graphLoading())\n\n    fetchAllDataFromSpotify(\n        accessToken, sp, \n        () => {}, \n        (message: string) => {dispatch(setGraphLoadingMessage(message))},\n        (progress: number) => {dispatch(setGraphLoadingProgress(progress))}\n    )\n    .then(g => dispatch(setGraph(g)))\n    .then(() => callback())\n    .then(() => dispatch(graphLoadingSuccess()))\n    .catch((error) => {\n        console.debug(error)\n        dispatch(graphLoadingError())\n    })\n}\n\nexport const graphFromFileIsLoaded = (isLoaded: boolean): ActionWrapper<boolean> => ({\n    type: 'GRAPH_FROM_FILE_IS_LOADED',\n    payload: isLoaded,\n    reducer: produce((state: State) => {\n        state.isGraphFromFileLoaded = isLoaded\n    })\n})\n\n\nconst validateGraphObject = (jsonToValidate: any) => {\n    const validationResult = PositionType.decode(jsonToValidate)\n    console.debug('typecheck:', isRight(validationResult))\n\n}\n\n// TODO: not working completely, but at least loads the main graph!\nexport const loadGraphFromFile = (jsonToParse: Graph): ThunkActionWrapper<void> => \nasync (dispatch): Promise<void> => {\n    validateGraphObject({x:24,y:53}) // TODO: remove this..\n\n    for (let i = 0; i < jsonToParse.clusters.length; i++) {\n        const cluster = jsonToParse.clusters[i];\n        if (isUndefined(cluster.artistsIds) || cluster.artistsIds.length === 0) {\n            cluster.artistsIds = Object.keys(cluster.artistsPositions)\n        }\n    }\n\n    await Promise.resolve(\n        dispatch(clearChosenClusterAndArtist())\n    )\n    .then(() => dispatch(graphLoading()))\n    .then(() => dispatch(setGraph(jsonToParse)))\n    .then(() => dispatch(graphFromFileIsLoaded(true)))\n    .then(() => dispatch(graphLoadingSuccess()))            \n}\n","/* eslint-disable @typescript-eslint/no-useless-constructor */\n\nimport React from 'react'\nimport { connect } from 'react-redux'\nimport { State } from '../store/types'\nimport { Redirect } from \"react-router-dom\";\nimport { setUserLoggedIn } from '../store/actions'\nimport './welcome-page.css'\nimport '../App.css'\n\ninterface LoginPageProps {    \n    loggedIn: boolean\n    setUserLoggedIn: typeof setUserLoggedIn\n}\n\ninterface LoginPageState {}\n\nclass LoginPage extends React.Component<LoginPageProps, LoginPageState> {\n    constructor(props: LoginPageProps) {\n        super(props);\n    }\n\n    spotifyLoginLink() {\n        const client_id = 'dfb05fa5c36b41d48407ad5e3773d39b'\n        const scope = [                                                                                    \n            'streaming',            \n            'user-read-email',\n            'user-read-private',\n            'user-read-playback-state',\n            'user-modify-playback-state',\n            'user-library-read',\n            'user-library-modify',\n            'user-follow-read',\n            'playlist-modify-private',\n            'playlist-read-private',\n        ]\n        const state = 'rndstringsomehash'\n        const redirect_uri = process.env.NODE_ENV === \"production\" ? \n            process.env.REACT_APP_PROD_SPOTIFY_REDIRECT_URL : process.env.REACT_APP_DEV_SPOTIFY_REDIRECT_URL\n        const params = {\n            client_id:client_id,\n            response_type:'code',\n            redirect_uri:redirect_uri,\n            scope:scope.join(' '),\n            state:state,\n        }\n\n        const encodeGetParams = (p:Object): string => \n            Object.entries(p).map(kv => kv.map(encodeURIComponent).join(\"=\")).join(\"&\");                \n\n        const link = 'https://accounts.spotify.com/authorize?' + encodeGetParams(params)\n        return link                                    \n    }\n\n    loginWithSpotify() {\n        window.location.assign(this.spotifyLoginLink())\n    }\n\n    render() {\n        if (this.props.loggedIn) {\n            return <Redirect to=\"/mygraph\"/>\n        }\n\n        return (\n            <div className=\"App\">\n                <div className=\"page-wrapper\">\n                    <div className=\"generic-description\">\n                        <div>Please login with your spotify account</div>\n                    </div>                    \n                    <button className=\"very-big-button\" onClick={() => this.loginWithSpotify()}>Log in with your Spotify account</button>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        loggedIn: state.userLoggedIn\n    }),\n    {\n        setUserLoggedIn\n    }\n)(LoginPage)\n","/* eslint-disable no-extra-label */\n\nimport {ClusterSquare, StringDict, Position } from '../store/types'\n\ninterface Rectangle {\n    left: number\n    top: number\n    width: number\n    height: number\n}\n\ninterface ScreenParams {\n    width: number\n    height: number\n    clusterWidth: number\n    clusterHeigth: number\n}\n\nconst getBigComponentsPositions = (\n    bigClusterSquares: ClusterSquare[],\n    finalPositions: StringDict<Position>,\n    screenParams: ScreenParams\n) => {\n    for (let i = 0; i < bigClusterSquares.length; i++) {\n        const square = bigClusterSquares[i];\n        for (let clusterId in square) {\n            const clusterPosition = square[clusterId]\n\n            const newX = clusterPosition.x * (screenParams.width - screenParams.clusterWidth - 40)\n            const newY = clusterPosition.y * screenParams.height\n            finalPositions[clusterId] = {x:newX, y:newY}\n        }\n    }\n}\n\n\n\nconst somestupidfunction = (\n    clusterInComponent: number,\n    clusterComponents: ClusterSquare[],\n    freeRectMatrix: number[][],\n    possibleRectanglePositions: Rectangle[],\n    notUsedClusterComponents: ClusterSquare[],\n    finalPositions: StringDict<Position>,\n) => {\n    if (clusterInComponent !== 1 && clusterInComponent !== 2 && clusterInComponent !== 3 && freeRectMatrix.length <= 0) {\n    }\n\n    const freeRectMatrixRows = freeRectMatrix.length\n    const freeRectMatrixCols = freeRectMatrix[0].length\n\n    wholeLoop:\n    for (let i = 0; i < clusterComponents.length; i++) {\n        let foundSomeCoords = false\n        const clusterComponent = clusterComponents[i];\n\n        rowLoop:\n        for (let row = 0; row < freeRectMatrix.length; row++) {\n\n            // columnLoop:\n            for (let col = 0; col < freeRectMatrix[row].length; col++) {\n\n                let coordCombinations: number[][][] = []\n                if (clusterInComponent === 1) {\n                    coordCombinations = [\n                        [[row, col]]\n                    ]\n                }\n                else if (clusterInComponent === 2) {\n                    coordCombinations = [\n                        [[row, col], [row, col+1]],\n                        [[row, col], [row+1, col]],\n                    ]\n                }\n                else if (clusterInComponent === 3) {\n                    coordCombinations = [\n                        [[row, col],     [row, col+1], [row+1, col+1]],\n                        [[row, col],     [row+1, col], [row+1, col+1]],\n                        [[row, col],     [row, col+1], [row+1, col]],\n                        [[row+1, col+1], [row, col+1], [row+1, col]],\n                    ]\n                }\n\n                for (let coordIndex = 0; coordIndex < coordCombinations.length; coordIndex++) {\n                    const coordArray = coordCombinations[coordIndex]\n                    const isLegit = coordArray.every(([rIndex,cIndex]) => {\n                        return rIndex < freeRectMatrixRows && cIndex < freeRectMatrixCols && freeRectMatrix[rIndex][cIndex] !== 0\n                    })\n                    const clusterIds = Object.keys(clusterComponent);\n                    if (isLegit) {\n\n                        for (let k = 0; k < clusterInComponent; k++) {\n                            const rect = possibleRectanglePositions[freeRectMatrix[coordArray[k][0]][coordArray[k][1]] - 1]\n                            finalPositions[clusterIds[k]] = {x:rect.left, y:rect.top}\n                            freeRectMatrix[coordArray[k][0]][coordArray[k][1]] = 0\n                        }\n\n                        foundSomeCoords = true\n                        break rowLoop\n                    }\n                    else {}\n                }\n            }\n        }\n\n        if (!foundSomeCoords) {\n            for (let notUsedIndex = i; notUsedIndex < clusterComponents.length; notUsedIndex++) {\n                notUsedClusterComponents.push(clusterComponents[notUsedIndex])\n            }\n            break wholeLoop\n        }\n    }\n}\n\n\nconst getRestComponentsPositions = (\n    finalPositions: StringDict<Position>,\n    oneClusterComponents: ClusterSquare[],\n    twoClusterComponents: ClusterSquare[],\n    threeClusterComponents: ClusterSquare[],\n    screenParams: ScreenParams,\n    currentHeight: number\n) => {\n    // get the empty rectangle to fill with small pieces..\n\n    let rectangles: Rectangle[] = []\n    for (let key in finalPositions) {\n        let pos = finalPositions[key]\n        rectangles.push({left:pos.x, top:pos.y, width:screenParams.clusterWidth, height:screenParams.clusterHeigth})\n    }\n    const { possibleRectanglePositions, freeRectMatrix } = getPossibleFreePositions(\n        screenParams.width, currentHeight, screenParams.clusterWidth + 30, screenParams.clusterHeigth + 30, rectangles);\n\n    const notUsedThreeClusterComponents: ClusterSquare[] = []\n    const notUsedTwoClusterComponents: ClusterSquare[] = []\n    const notUsedOneClusterComponents: ClusterSquare[] = []\n\n    somestupidfunction(3, threeClusterComponents, freeRectMatrix, possibleRectanglePositions, notUsedThreeClusterComponents, finalPositions)\n    somestupidfunction(2, twoClusterComponents, freeRectMatrix, possibleRectanglePositions, notUsedTwoClusterComponents, finalPositions)\n    somestupidfunction(1, oneClusterComponents, freeRectMatrix, possibleRectanglePositions, notUsedOneClusterComponents, finalPositions)\n\n    const newRects: Rectangle[] = []\n\n    let currentY = currentHeight\n    let currentX = 0\n    // const triangleSquareSize = screenParams.clusterWidth * 3\n    const middleX = screenParams.clusterWidth * 0.7\n    const middleY = screenParams.clusterHeigth * 0.7\n    const circleRadius = screenParams.clusterWidth * 0.7\n    for (let i = 0; i < notUsedThreeClusterComponents.length; i++) {\n        const clusterComponent = notUsedThreeClusterComponents[i];\n        const clusterIds = Object.keys(clusterComponent);\n        // const angle = 1/3\n        const angle = Math.random()\n\n        const coords: number[][] = [\n            [\n                (circleRadius)*(Math.cos(angle*Math.PI)) + middleX + currentX,\n                (circleRadius)*(Math.sin(angle*Math.PI)) + middleY + currentY\n            ],\n            [\n                circleRadius*(Math.cos((angle+2/3)*Math.PI)) + middleX + currentX,\n                circleRadius*(Math.sin((angle+2/3)*Math.PI)) + middleY + currentY\n            ],\n            [\n                circleRadius*(Math.cos((angle+4/3)*Math.PI)) + middleX + currentX,\n                circleRadius*(Math.sin((angle+4/3)*Math.PI)) + middleY + currentY\n            ]\n        ]\n\n        for (let j = 0; j < 3; j++) {\n            finalPositions[clusterIds[j]] = {x:coords[j][0], y:coords[j][1]}\n            newRects.push({left: coords[j][0], top: coords[j][1], width:screenParams.clusterWidth, height:screenParams.clusterHeigth})\n        }\n\n        const squareChange = circleRadius * 1.7 + screenParams.clusterWidth\n        currentX += squareChange\n        if (currentX + squareChange > screenParams.width) {\n            currentX = 0\n            currentY += squareChange\n        }\n    }\n\n    for (let i = 0; i < notUsedTwoClusterComponents.length; i++) {\n        const clusterComponent = notUsedTwoClusterComponents[i];\n        const clusterIds = Object.keys(clusterComponent);\n        const coords: number[][] = [\n            [ currentX, currentY ],\n            [ currentX + circleRadius * 2, currentY ],\n        ]\n\n        for (let j = 0; j < 2; j++) {\n            finalPositions[clusterIds[j]] = {x:coords[j][0], y:coords[j][1]}\n            newRects.push({left: coords[j][0], top: coords[j][1], width:screenParams.clusterWidth, height:screenParams.clusterHeigth})\n        }\n\n        const squareChange = circleRadius * 2 + screenParams.clusterWidth\n        currentX += squareChange\n        if (currentX > screenParams.width - screenParams.clusterWidth) {\n            currentX = 0\n            currentY += screenParams.clusterHeigth + 20\n        }\n    }\n\n    // rest one cluster components:\n    currentY = currentHeight\n    for (let i = 0; i < notUsedOneClusterComponents.length; i++) {\n        const clusterComponent = notUsedOneClusterComponents[i];\n        const clusterId = Object.keys(clusterComponent)[0];\n        const clusterRect: Rectangle = {top:currentY, left: currentX, width:screenParams.clusterWidth, height:screenParams.clusterHeigth}\n\n        while (hasCollisions(clusterRect, newRects)) {\n            clusterRect.left += screenParams.clusterWidth\n\n            if (clusterRect.left + screenParams.clusterWidth > screenParams.width) {\n                clusterRect.left = 0\n                clusterRect.top += screenParams.clusterHeigth + 20\n            }\n        }\n        finalPositions[clusterId] = { x: clusterRect.left, y: clusterRect.top }\n        currentX = clusterRect.left + screenParams.clusterWidth + 20\n        currentY = clusterRect.top\n        if (currentX + screenParams.clusterWidth > screenParams.width) {\n            currentX = 0\n            currentY += screenParams.clusterHeigth\n        }\n    }\n}\n\nexport const computeClusterPositions =\n    (width: number, height: number, clusterWidth: number, clusterHeigth: number, clusterSquares: ClusterSquare[]):\n    StringDict<Position> =>\n{\n    const toRet: StringDict<Position> = {} // prepare dict for final positions\n    width -= 15 // some distance from the edge\n\n    const oneClusterComponents = []\n    const twoClusterComponents = []\n    const threeClusterComponents = []\n    const bigComponent = []\n\n    for (let i = 0; i < clusterSquares.length; i++) {\n        const square = clusterSquares[i];\n\n        // TODO: fix cases, where there are 1/2/3 nodes\n        const clustersInSquares = Object.keys(square).length\n        if (clustersInSquares === 1) {\n            oneClusterComponents.push(square)\n        }\n        else if (clustersInSquares === 2) {\n            twoClusterComponents.push(square)\n        }\n        else if (clustersInSquares === 3) {\n            threeClusterComponents.push(square)\n        }\n        else {\n            bigComponent.push(square)\n        }\n    }\n\n    const clusterPadding = 25\n    const screenParams:ScreenParams = {width: width, height: height, clusterWidth: clusterWidth+clusterPadding, clusterHeigth: clusterHeigth+10}\n    getBigComponentsPositions(bigComponent, toRet, screenParams)\n    const currentHeight = computeHeigthFromPositions(toRet, clusterHeigth)\n    getRestComponentsPositions(toRet, oneClusterComponents, twoClusterComponents, threeClusterComponents, screenParams, currentHeight)\n    return toRet\n}\n\n\nexport const computeHeigthFromPositions = (\n    positions: StringDict<Position>, clusterHeigth: number\n): number => {\n    let maxY = 0\n    for (let key in positions){\n        let pos = positions[key]\n        maxY = pos.y > maxY ? pos.y : maxY\n    }\n    return maxY + clusterHeigth\n}\n\nconst _colliding = (start1:number, end1:number, start2:number, end2:number) => {\n\treturn start1 < end2 && start2 < end1;\n}\n\nconst areColliding = (rect1: Rectangle, rect2: Rectangle) => {\n\treturn _colliding(rect1.left, rect1.left + rect1.width, rect2.left, rect2.left + rect2.width)\n\t\t&& _colliding(rect1.top, rect1.top + rect1.height, rect2.top, rect2.top + rect2.height);\n}\n\nconst hasCollisions = (rect: Rectangle, rects: Rectangle[]) => {\n\treturn rects.reduce((res, r) => res || areColliding(r, rect), false);\n}\n\nconst getPossibleFreePositions = (\n    width: number, height:number, clusterWidth: number, clusterHeight:number, rects:Rectangle[]\n): {possibleRectanglePositions: Rectangle[], freeRectMatrix: number[][]} => {\n    const freeRectMatrix: number[][] = []\n    let numberToWidth = Math.floor(width / clusterWidth)\n    let numberToheight = Math.floor(height / clusterHeight)\n\n    numberToWidth = numberToWidth === 0 ? 1 : numberToWidth\n    numberToheight = numberToheight === 0 ? 1 : numberToheight\n\n    const possibleRectanglePositions = []\n    let noRectangles = 0\n    for (let i = 0; i < numberToheight; i++) {\n        freeRectMatrix[i] = []\n        for (let j = 0; j < numberToWidth; j++) {\n            const rect: Rectangle = {top: i*clusterHeight, left: j*clusterWidth, width: clusterWidth, height:clusterHeight}\n            if (hasCollisions(rect, rects)) {\n                freeRectMatrix[i][j] = 0\n            }\n            else {\n                noRectangles += 1\n                freeRectMatrix[i][j] = noRectangles\n                possibleRectanglePositions.push(rect)\n            }\n        }\n    }\n\n\treturn {possibleRectanglePositions:possibleRectanglePositions, freeRectMatrix: freeRectMatrix}\n}\n","\n\nexport const computeEdgeCoordinates = (x1:number, y1:number, x2:number, y2:number, thickness: number) => {\n    let top:number, left:number, wid:number, hei:number\n    \n    if (x1 > x2) {\n        left = x2\n        wid = x1 - x2\n    }\n    else {\n        left = x1\n        wid = x2 - x1\n    }\n\n    if (y1 > y2) {\n        top = y2\n        hei = y1 - y2\n    }\n    else {\n        top = y1\n        hei = y2 - y1\n    }\n\n    let x1fin = 0 + thickness\n    let y1fin = hei\n    let x2fin = wid\n    let y2fin = 0 + thickness\n    if ((y1 > y2 && x1 > x2) ||\n        (y1 < y2 && x1 < x2)) {\n        y1fin = 0 + thickness\n        y2fin = hei\n    }\n\n    return {x1fin, y1fin, x2fin, y2fin, top, left, hei, wid}\n}\n","import React from 'react'\nimport {computeEdgeCoordinates} from '../methods/edge-calculation'\n\ninterface ArtistEdgeProps {\n    x1: number\n    y1: number\n    x2: number\n    y2: number\n    weigth: number\n    artistWidth: number\n    maximumEdgeWeigth: number\n}\n\nexport default class ArtistEdge extends React.Component<ArtistEdgeProps, {}> {\n\n    render() {\n        const thickness = this.props.weigth*2\n        const {x1fin, y1fin, x2fin, y2fin, top, left, hei, wid} = computeEdgeCoordinates(\n            this.props.x1, this.props.y1, this.props.x2, this.props.y2, thickness)\n\n        const st: React.CSSProperties ={\n            top: top + 30,\n            left: left + this.props.artistWidth / 2\n        }\n        \n        const curvature = 20\n        const edgeColor = `rgb(${2}, ${250}, ${240}, ${this.props.weigth / this.props.maximumEdgeWeigth})`\n\n        return(\n            <svg style={st} className=\"position-absolute\" width={wid+thickness+curvature} height={hei+thickness+curvature}>\n                <path \n                    d={`M ${x1fin},${y1fin} \n                        C ${x1fin+curvature},${y1fin+curvature} ${x2fin+curvature},${y2fin+curvature} ${x2fin},${y2fin}`} \n                    strokeWidth={thickness} \n                    fill=\"none\" \n                    stroke={edgeColor}\n                />\n            </svg>\n        )\n    }\n}\n","const COLORS = {\n    lightAzureBlue: `rgb(132, 237, 243)`,\n    darkAzureBlue: `rgb(2, 109, 104)`,\n    pink: `rgb(255, 51, 153)`,\n    green: `rgb(0, 204, 0)`,\n    grey: `rgb(191, 191, 191)`\n}\n  \n  export default COLORS;\n","import React from 'react'\nimport Draggable, { DraggableEvent } from 'react-draggable'\nimport CSS from 'csstype';\nimport { connect } from 'react-redux'\nimport { State } from '../store/types'\nimport { setChosenArtistDataAll} from '../store/actions'\nimport { ArtistFull } from '../store/types'\nimport COLORS from '../methods/colors'\n\nimport './cluster-node.css'\nimport './artist-node.css'\n\ninterface ArtistNodeProps {\n    artist: ArtistFull\n    positionX: number\n    positionY: number\n\n    minimumScore: number\n\n    chosenArtist?: ArtistFull\n    accessToken?: string\n    positionChangedCallback: Function // callback needed for edge update\n    // setChosenArtistFunc: typeof setChosenArtist\n    setChosenArtistDataAllFunc: typeof setChosenArtistDataAll\n}\n\ninterface ArtistNodeState {\n    currentPositionX: number\n    currentPositionY: number\n    dragging: boolean\n}\n\nclass ArtistNode extends React.Component<ArtistNodeProps, ArtistNodeState> {\n    constructor(props: ArtistNodeProps) {\n        super(props);\n        this.state = {\n            currentPositionX: props.positionX,\n            currentPositionY: props.positionY,\n            dragging: false,\n        }\n        this.onDrag = this.onDrag.bind(this)\n        this.onStop = this.onStop.bind(this)\n    }\n\n    componentDidUpdate() {\n    }\n\n    onDrag(e: DraggableEvent, ui: any) {\n        e.stopPropagation(); e.preventDefault();\n        this.setState({dragging:true})\n        const newCurrX = this.state.currentPositionX + ui.deltaX\n        const newCurrY = this.state.currentPositionY + ui.deltaY\n        this.setState({currentPositionX: newCurrX, currentPositionY: newCurrY})\n        this.props.positionChangedCallback(newCurrX, newCurrY, this.props.artist.id)\n    }\n\n    onStop(e: DraggableEvent) {\n        e.stopPropagation(); e.preventDefault();\n        const dragging = this.state.dragging;\n        this.setState({dragging:false})\n        if (!dragging) {\n            this.handleClick();\n        }\n    }\n\n    handleClick() {\n        // const id = this.props.artist.spotifyId\n        // this.props.setChosenArtistFunc(id)\n        if (this.props.accessToken) {\n            if (this.props.chosenArtist && this.props.chosenArtist.id === this.props.artist.id) {\n                return\n            }\n            else {\n                this.props.setChosenArtistDataAllFunc(this.props.artist, this.props.accessToken);\n            }\n        }\n    }\n\n    render() {\n        let color = COLORS.lightAzureBlue\n        if (this.props.chosenArtist && this.props.chosenArtist.id === this.props.artist.id) {\n            color = COLORS.pink\n        }\n        const nodeWidth = 60\n        const nodeHeight = 60\n\n        const artistImageDivStyle: CSS.Properties = {\n            backgroundImage:`url(${this.props.artist.image})`,\n            backgroundSize: `${nodeHeight}px ${nodeWidth}px`,\n            width:`${nodeWidth}px`,\n            height:`${nodeHeight}px`,\n            borderRadius: \"10px\",\n            alignSelf:\"center\"\n        }\n\n        if(this.props.artist.score < this.props.minimumScore) {\n            return <div></div>\n        }\n\n        return (\n            <Draggable\n                key={this.props.artist.id}\n                bounds=\"parent\"\n                defaultPosition={{ x: this.props.positionX, y: this.props.positionY}}\n                onDrag={this.onDrag}\n                onStop={this.onStop}\n                // onStart={(e:DraggableEvent) => {e.stopPropagation(); e.preventDefault();}}\n            >\n                <div className=\"artist-node-outer-wrapper\">\n                    <div style={{...artistImageDivStyle, backgroundColor:COLORS.lightAzureBlue}}>\n                        <div style={artistImageDivStyle}/>\n                    </div>\n                    <div className=\"artist-node-artist-name-div\" style={{backgroundColor: color}}>\n                        {this.props.artist.name}\n                    </div>\n                </div>\n            </Draggable>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        accessToken: state.accessToken,\n        chosenArtist: state.chosenArtist\n    }),\n    (dispatch: any) => ({\n        setChosenArtistDataAllFunc: (chosenArtist: ArtistFull, accessToken: string) => dispatch(setChosenArtistDataAll(chosenArtist, accessToken))        \n    })\n)(ArtistNode)\n","import React, { ChangeEvent } from 'react'\nimport { connect } from 'react-redux'\nimport { State, ArtistFull, StringDict } from '../store/types'\nimport {InsideClusterGraph} from './chosen-cluster'\nimport ArtistEdge from './artist-edge'\nimport ArtistNode from './artist-node'\nimport Draggable from 'react-draggable'\nimport {TiArrowMove} from 'react-icons/ti'\nimport { BsQuestion} from 'react-icons/bs'\nimport './chosen-cluster-graph-precomputed.css'\n\n\ninterface ChosenClusterGraphPrecomputedProps {\n    accessToken?: string\n    graphElements: InsideClusterGraph\n    chosenArtist?: ArtistFull\n}\n\ninterface SliderLimits {\n    minimum: number\n    maximum: number\n}\n\ninterface ChosenClusterGraphPrecomputedState {\n    width: number\n    height: number\n    nodes: JSX.Element[]\n    artistsPositions: {[id:string]: {x:number, y:number}}\n    dragging: boolean\n\n    idArtistDict: StringDict<ArtistFull>\n\n    artistsSliderLimits: SliderLimits\n    edgesSliderLimits: SliderLimits\n\n    artistSliderValue: number\n    edgesSliderValue: number\n\n    descriptionHover: boolean\n\n    minimumEdgeWeight: number\n}\n\nclass ChosenClusterGraphPrecomputed extends React.Component<ChosenClusterGraphPrecomputedProps, ChosenClusterGraphPrecomputedState> {\n    constructor(props: ChosenClusterGraphPrecomputedProps) {\n        super(props);\n        const {idArtistDict, artistsSliderLimits, edgesSliderLimits} = this.getIdArtistDictAndSliderLimits()\n        this.state = {\n            width: 0, height: 0,\n            nodes: [], artistsPositions: {},\n            dragging: false,\n            artistSliderValue: artistsSliderLimits.minimum, edgesSliderValue: edgesSliderLimits.minimum,\n            idArtistDict: idArtistDict,\n            artistsSliderLimits: artistsSliderLimits,\n            edgesSliderLimits: edgesSliderLimits,\n            descriptionHover: false,\n            minimumEdgeWeight: 0.5 // TODO: wrong! Make this value dynamic.\n        }\n        this.wrapperRef = React.createRef();\n        this.boxRef = React.createRef();\n\n        this.positionChangedHandler = this.positionChangedHandler.bind(this)\n        this.changeArtistSliderValue = this.changeArtistSliderValue.bind(this)\n        this.changeEdgeSliderValue = this.changeEdgeSliderValue.bind(this)\n    }\n\n    boxRef: any\n    wrapperRef: any\n    \n    componentDidUpdate(prevprops: ChosenClusterGraphPrecomputedProps, prevstate: ChosenClusterGraphPrecomputedState) {\n        if (prevprops.graphElements !== this.props.graphElements) {\n            this.prepareAfterGraphDataUpdate()\n        }\n        else if (prevstate.artistSliderValue !== this.state.artistSliderValue) {\n            this.prepareAfterSliderUpdate()\n        }\n    }\n\n    componentDidMount() {\n        this.prepareAfterGraphDataUpdate()\n    }\n\n    getIdArtistDictAndSliderLimits(): {\n        idArtistDict: StringDict<ArtistFull>,\n        artistsSliderLimits: SliderLimits,\n        edgesSliderLimits: SliderLimits\n    } {\n        const idArtistDict: StringDict<ArtistFull> = {}\n        let artistsSliderLimits: SliderLimits = {minimum: 1000, maximum: -1000}\n        let edgesSliderLimits: SliderLimits = {minimum: 1000, maximum: -1000}\n\n        // get the id-artist dict and artist slider values\n        for (let i = 0; i < this.props.graphElements.nodes.length; i++) {\n            const node = this.props.graphElements.nodes[i];\n            idArtistDict[node.artist.id] = node.artist\n\n            artistsSliderLimits.maximum = node.artist.score > artistsSliderLimits.maximum ? node.artist.score : artistsSliderLimits.maximum;\n            artistsSliderLimits.minimum = node.artist.score < artistsSliderLimits.minimum ? node.artist.score : artistsSliderLimits.minimum;\n        }\n\n        // get the edge slider values\n        for (let i = 0; i < this.props.graphElements.edges.length; i++) {\n            const edge = this.props.graphElements.edges[i];\n            edgesSliderLimits.maximum = edge.weigth > edgesSliderLimits.maximum ? edge.weigth : edgesSliderLimits.maximum;\n            edgesSliderLimits.minimum = edge.weigth < edgesSliderLimits.minimum ? edge.weigth : edgesSliderLimits.minimum;\n        }\n\n        artistsSliderLimits.maximum = Math.ceil(artistsSliderLimits.maximum)\n        artistsSliderLimits.minimum = Math.ceil(artistsSliderLimits.minimum) - 1\n        edgesSliderLimits.maximum = Math.ceil(edgesSliderLimits.maximum)\n        edgesSliderLimits.minimum = Math.ceil(edgesSliderLimits.minimum) - 1\n\n        return {idArtistDict: idArtistDict, artistsSliderLimits: artistsSliderLimits, edgesSliderLimits: edgesSliderLimits}\n    }\n\n    prepareAfterGraphDataUpdate() {\n        const {idArtistDict, artistsSliderLimits, edgesSliderLimits} = this.getIdArtistDictAndSliderLimits()\n        this.setState({\n            artistsSliderLimits: artistsSliderLimits,\n            edgesSliderLimits: edgesSliderLimits,\n            artistSliderValue: artistsSliderLimits.minimum,\n            edgesSliderValue: edgesSliderLimits.minimum,\n            idArtistDict: idArtistDict\n        })\n        let width = this.boxRef.current.clientWidth;\n        let height = this.boxRef.current.clientHeight;\n        this.setState({width: width, height: height})\n        const omg: {nodes: JSX.Element[], positions:{}} = this.createNodes(width,height);\n        this.setState({nodes:omg.nodes, artistsPositions: omg.positions})\n    }\n\n    prepareAfterSliderUpdate() {\n        const nodes = []\n        for (let i = 0; i < this.props.graphElements.nodes.length; i++) {\n            const elem = this.props.graphElements.nodes[i]\n            nodes.push(\n                <ArtistNode\n                    key={elem.artist.id}\n                    positionChangedCallback={this.positionChangedHandler}\n                    positionX={this.state.artistsPositions[elem.artist.id].x}\n                    positionY={this.state.artistsPositions[elem.artist.id].y}\n                    artist={elem.artist}\n                    minimumScore={this.state.artistSliderValue}\n                />\n            )\n        }\n        this.setState({nodes:nodes})\n    }\n\n    positionChangedHandler(x: number, y: number, artist_id: string) {\n        if (this.state.artistsPositions == null) {\n            return []\n        }\n        const pos = this.state.artistsPositions\n        pos[artist_id] = { x: x, y: y }\n        this.setState({artistsPositions: pos});\n    }\n\n    createNodes(wid: number, hei: number): {nodes: JSX.Element[], positions:{}} {\n        const nodeWidth = 100\n        const nodeHeight = 100\n        const canvasPadding = 15\n\n        const nodes:JSX.Element[] = []\n        let newArtistsPositions: {[id:string]: {x:number, y:number}} = {}\n        for (let i = 0; i < this.props.graphElements.nodes.length; i++) {\n            const elem = this.props.graphElements.nodes[i]\n            const compX = elem.position.x*(wid-nodeWidth-2*canvasPadding) + canvasPadding\n            const compY = elem.position.y*(hei-nodeHeight-2*canvasPadding) + canvasPadding\n            newArtistsPositions[elem.artist.id] = {x:compX, y:compY}\n\n            nodes.push(\n                <ArtistNode\n                    key={elem.artist.id}\n                    positionChangedCallback={this.positionChangedHandler}\n                    positionX={compX}\n                    positionY={compY}\n                    artist={elem.artist}\n                    minimumScore={this.state.artistSliderValue}\n                />\n            )\n        }\n        return {nodes, positions:newArtistsPositions}\n    }\n\n    createEdges(): JSX.Element[] {\n        const edges = []\n        if (this.state.artistsPositions == null) {\n            return []\n        }\n\n        try {\n            for (let i = 0; i < this.props.graphElements.edges.length; i++) {\n                const edge = this.props.graphElements.edges[i]\n                const node1id = edge.id1\n                const node2id = edge.id2\n                const edgeWeigth = edge.weigth\n                const clusterEdgeKey = node1id + node2id\n\n                const node1 = this.state.idArtistDict[node1id]\n                const node2 = this.state.idArtistDict[node2id]\n\n                if (node1 !== node2 && edgeWeigth > this.state.edgesSliderValue &&\n                    edgeWeigth > this.state.minimumEdgeWeight &&\n                    node1.score >= this.state.artistSliderValue &&\n                    node2.score >= this.state.artistSliderValue\n                ) {\n                    edges.push(\n                        <ArtistEdge\n                            key={clusterEdgeKey}\n                            x1={this.state.artistsPositions[node1id].x}\n                            y1={this.state.artistsPositions[node1id].y}\n                            x2={this.state.artistsPositions[node2id].x}\n                            y2={this.state.artistsPositions[node2id].y}\n                            weigth={edge.weigth}\n                            artistWidth={70}\n                            maximumEdgeWeigth={this.state.edgesSliderLimits.maximum}\n                        />\n                    )\n                }\n            }\n        }\n        catch(err) {\n            edges.push(<div></div>)\n        }\n\n        return edges\n    }\n\n    changeArtistSliderValue(e: ChangeEvent<HTMLInputElement>) {\n        this.setState({artistSliderValue: e.currentTarget.valueAsNumber})\n    }\n\n    createArtistSlider(): JSX.Element {\n        const minimum = this.state.artistsSliderLimits.minimum\n        const maximum = this.state.artistsSliderLimits.maximum\n        return <div className=\"inner-slider-wrapper\">\n            <input\n                type=\"range\"\n                min={minimum}\n                max={maximum}\n                // step={(maximum - minimum) / this.props.graphElements.nodes.length}\n                step={(maximum - minimum)/10}\n                value={this.state.artistSliderValue}\n                onChange={this.changeArtistSliderValue}\n                className=\"slider-input\"\n            />\n        </div>\n    }\n\n    changeEdgeSliderValue(e: ChangeEvent<HTMLInputElement>) {\n        this.setState({edgesSliderValue: e.currentTarget.valueAsNumber})\n    }\n\n    createEdgeSlider(): JSX.Element {\n        const minimum = Math.max(this.state.edgesSliderLimits.minimum, this.state.minimumEdgeWeight)\n        const maximum = this.state.edgesSliderLimits.maximum\n        return <div className=\"inner-slider-wrapper\">\n            <input\n                type=\"range\"\n                min={minimum}\n                max={maximum}\n                step={(maximum - minimum)/10}\n                value={this.state.edgesSliderValue}\n                onChange={this.changeEdgeSliderValue}\n                className=\"slider-input\"\n            />\n        </div>\n    }\n\n    changeHover() {\n        this.setState({descriptionHover: !this.state.descriptionHover})\n    }    \n\n    getDraggableSlider() {\n        const showDescriptionStyle = this.state.descriptionHover ? {} : {display: 'none'}\n        return (\n            <Draggable handle=\"strong\" bounds=\"parent\">\n                <div className=\"draggable-slider-div\">\n                    <div>\n                        <div className=\"outer-slider-wrapper\">\n                            { this.createEdgeSlider() }\n                            edges\n                        </div>\n                        <div className=\"outer-slider-wrapper\">\n                            { this.createArtistSlider() }\n                            artists\n                        </div>\n                    </div>\n                    <BsQuestion onMouseEnter={() => this.changeHover()} onMouseLeave={() => this.changeHover()} size={30}/>\n                    <strong><TiArrowMove size={30}/></strong>\n                    <div className=\"slider-description\" style={showDescriptionStyle}>\n                        <p>Drag the sliders to control how many edges and artists will be shown.</p>\n                        <p>The artists will be hidden in the order based on their importance to you - less important first, more important remainig.</p>\n                        <p>The importance takes into account these factors: how many their songs you like, if you follow them and popularity on Spotify.</p>\n                        <p>The score of an edge between two artists is calculated from the number of common genres and Spotify \"related artists\" information.</p>\n                    </div>\n                </div>\n            </Draggable>\n        )\n    }\n\n    render() {\n        return (\n            <div className=\"noselect chosen-cluster-wrapper\" ref={this.wrapperRef}>\n                <div className=\"insideClusterBox\" ref={this.boxRef} style={{ width:this.state.width }}>\n                    { this.getDraggableSlider() }\n                    { this.state.width !== 0 && this.state.nodes.length !== 0 &&  this.createEdges() }\n                    { this.state.width !== 0 && this.state.nodes }\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        accessToken: state.accessToken,\n        chosenArtist: state.chosenArtist\n    }),\n    {}\n)(ChosenClusterGraphPrecomputed)\n","\nimport React from 'react'\nimport './chosen-artist-bar.css'\nimport './styles.css'\nimport { connect } from 'react-redux'\nimport { ArtistFull, State, ChosenArtistData, SongFull } from '../store/types'\nimport { setSongToPlay, setPaused } from '../store/actions'\nimport { isUndefined } from 'util'\nimport { MdPlayCircleOutline, MdPauseCircleOutline } from 'react-icons/md'\nimport { IoMdMusicalNotes, IoMdHeart } from 'react-icons/io'\nimport { RiQuestionLine} from 'react-icons/ri'\nimport SpotifyWebApi from 'spotify-web-api-js'\nimport COLORS from '../methods/colors'\n\ninterface ChosenArtistBarProps {\n    chosenArtist?: ArtistFull,\n    chosenArtistLoading: boolean,\n    chosenArtistError: string,\n    chosenArtistData: ChosenArtistData,\n    setSongToPlay: Function,\n    spotifyApiObject: SpotifyWebApi.SpotifyWebApiJs,\n    songToPlay: SongFull\n    paused: boolean\n    setPause: Function\n}\n\ninterface ChosenArtistBarState {\n    chosenSongId: string\n\n    likedSongs:SongFull[]\n    notLikedSongs:SongFull[]\n}\n\nclass ChosenArtistBar extends React.Component<ChosenArtistBarProps, ChosenArtistBarState> {\n\n    constructor(props: any) {\n        super(props)\n        const {liked, notLiked} = this.prepareSongs()\n        // this.state = {chosenSongId: '', likedSongs:liked, notLikedSongs: notLiked}\n        this.state = {chosenSongId: '', likedSongs:liked, notLikedSongs: notLiked}\n    }\n\n    setChosenSong(songId: string) {\n        if (songId === this.state.chosenSongId) {\n            this.setState({chosenSongId: \"\"})\n        }\n        else {\n            this.setState({chosenSongId: songId})\n        }\n    }\n\n    componentDidUpdate(prevProps: ChosenArtistBarProps, prevState: ChosenArtistBarState) {\n        if(prevProps.chosenArtistData !== this.props.chosenArtistData) {\n            this.setState({\n                chosenSongId: '', \n                likedSongs:this.props.chosenArtistData.likedSongs, \n                notLikedSongs: this.props.chosenArtistData.notLikedSongs\n            })\n        }\n    }\n\n    prepareSongs(): {liked: SongFull[], notLiked: SongFull[]} {\n        if(!!!this.props.chosenArtistData || isUndefined(this.props.chosenArtist)) {\n            return {liked:[],notLiked:[]}\n        }\n\n        const likedSongs:SongFull[] = []\n        const notLikedSongs:SongFull[] = []\n\n        for (let i = 0; i < this.props.chosenArtistData.likedSongs.length; i++) {\n            const element = this.props.chosenArtistData.likedSongs[i];\n            if (this.props.chosenArtist.likedSongs &&\n                // this.props.chosenArtist.likedSongs.includes(element.id) &&\n                !!!likedSongs.includes(element)) {\n                likedSongs.push(element);\n            }\n            else if (!notLikedSongs.includes(element)){\n                notLikedSongs.push(element);\n            }\n        }\n        console.debug('liked:', likedSongs)\n        console.debug('liked by artist', this.props.chosenArtist.likedSongs)\n        console.debug('not liked:', notLikedSongs)\n        return {liked: likedSongs, notLiked: notLikedSongs}\n    }\n\n    getSongDiv(song: SongFull, liked: boolean): JSX.Element {\n        const style = this.state.chosenSongId === song.id ? {maxHeight: 80} : {maxHeight: 0}\n        \n        let playerIcon = <MdPlayCircleOutline size={40} onClick={(e) => {e.stopPropagation(); this.props.setSongToPlay(song);}} />\n\n        let chosenSongColorIndicator = COLORS.lightAzureBlue;        \n        if (this.props.songToPlay && this.props.songToPlay.id === song.id) {\n            chosenSongColorIndicator = COLORS.pink;\n            if (this.props.paused) {\n                playerIcon = <MdPlayCircleOutline size={40} onClick={(e) => {e.stopPropagation(); this.props.setPause(false)}} />\n            }\n            else {\n                playerIcon = <MdPauseCircleOutline size={40} onClick={(e) => {e.stopPropagation(); this.props.setPause(true)}} />\n            }\n        }\n\n        let likedSongColorIndicator = COLORS.lightAzureBlue\n        if (liked) {\n            likedSongColorIndicator = COLORS.green\n        }\n\n        if (song.previewLink === '' || song.previewLink === null || isUndefined(song.previewLink)) {\n            playerIcon = <RiQuestionLine size={40} onClick={(e) => {e.stopPropagation(); alert('No preview found on Spotify')}} />\n            chosenSongColorIndicator = COLORS.grey\n        }        \n\n        return (\n            <div key={song.id} className=\"flex-column song-div\" style={{backgroundColor: chosenSongColorIndicator}}>\n                <div className=\"song-preview\" style={{backgroundColor: likedSongColorIndicator}} onClick={() => this.setChosenSong(song.id)}>\n                    <div className=\"pointer\"\n                        style={{marginRight:\"5px\", display:\"inline-flex\", flexDirection:\"column\", justifyContent:\"center\", alignContent:\"center\"}}\n                    >\n                        {playerIcon}\n                    </div>\n                    <div className=\"song-wrapper\">\n                        {song.name}\n                    </div>\n                </div>\n                <div className=\"song-description\" style={style}>\n                    <div className=\"full-song-link-div\" onClick={() => {window.open(song.externalUrl)}}>\n                        <IoMdMusicalNotes/>\n                        Full song\n                    </div>\n                    { !!!liked && <div className=\"full-song-link-div\" onClick={() => {                        \n                        this.props.spotifyApiObject.addToMySavedTracks([song.id])\n                        .then(() => {\n                            console.debug('TRACK SAVED')\n                            let likedSongsOld = this.state.likedSongs\n                            likedSongsOld = likedSongsOld.concat(song)\n                            let notLikedSongsOld = this.state.notLikedSongs.filter(s => s.id !== song.id)\n\n                            this.setState({likedSongs: likedSongsOld, notLikedSongs: notLikedSongsOld})\n                        })\n                        .catch((error: any) => {\n                            console.debug('THIS ERROR DURING TRACK SAVING OCCURED:', error)\n                        })\n                    }}>\n                        <IoMdHeart/>\n                        Save to liked songs\n                    </div>\n                    }\n                </div>\n            </div>\n        )\n    }\n\n    getSongsDivs(songs: SongFull[], liked: boolean): JSX.Element[] {\n        if (!!!songs) return []\n\n        const toReturn: JSX.Element[] = []\n        for (let i = 0; i < songs.length; i++) {            \n            toReturn.push(                    \n                this.getSongDiv(songs[i], liked)\n            )\n        }\n        return toReturn\n\n    }\n\n    render() {\n        if (this.props.chosenArtistError) {\n            return (\n                <div className=\"chosen-artist-bar\">\n                    <h2><i>{this.props.chosenArtistError}</i></h2>\n                </div>\n            )\n        }\n        else if (isUndefined(this.props.chosenArtist) || isUndefined(this.props.chosenArtistData)) {\n            return (\n                <div className=\"chosen-artist-bar\">\n                    <h2>CLICK SOME ARTIST</h2>\n                </div>\n            )\n        }\n        else if (this.props.chosenArtistLoading) {\n            return (\n                <div className=\"chosen-artist-bar\">\n                    <h2>LOADING...</h2>\n                </div>\n            )\n        }\n        else {\n            return (\n                <div className=\"chosen-artist-bar\">\n                    <div className=\"chosen-artist-bar-top\">\n                        <h1 style={{margin:0}}>\n                            {this.props.chosenArtist.name}\n                        </h1>\n                        <div style={{\n                            backgroundImage:`url(${this.props.chosenArtist.image})`,\n                            width: 70, height: 70, borderRadius: `${20}%`,\n                            backgroundSize: `70px 70px`,\n                            display: \"inline-grid\"\n                        }}></div>\n                        {\n                            this.props.chosenArtist.isFollowed &&\n                            <h2 style={{ margin:`5px 0px 0px 0px` }}>You are following this artist.</h2>\n                        }\n                    </div>\n                    <div className=\"chosen-artist-bar-scroll\">\n                        {this.getSongsDivs(this.state.likedSongs, true)}\n                        {this.getSongsDivs(this.state.notLikedSongs, false)}\n                    </div>\n                </div>\n            )\n        }\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        songToPlay: state.songToPlay,\n        chosenArtist: state.chosenArtist,\n        chosenArtistLoading: state.chosenArtistLoading,\n        chosenArtistError: state.chosenArtistError,\n        chosenArtistData: state.chosenArtistData,\n        spotifyApiObject: state.spotifyWebApiObject,\n        paused: state.paused\n    }),\n    (dispatch: Function) => ({\n        setPause: (paused:boolean) => dispatch(setPaused(paused)),\n        setSongToPlay: (song: SongFull) => dispatch(setSongToPlay(song))\n    })\n)(ChosenArtistBar)\n","import * as React from 'react'\nimport CSS from 'csstype'\nimport './styles.css'\nimport { connect } from 'react-redux'\nimport { State, Cluster, ClusterEdge, ArtistEdge,ArtistFull, StringDict } from '../store/types'\nimport { closeChosenClusterGraph, setChosenCluster, closeChosenArtist } from '../store/actions'\nimport ChosenClusterGraphPrecomputed from './chosen-cluster-graph-precomputed'\nimport {TiArrowBack} from 'react-icons/ti'\nimport ChosenArtistBar from './chosen-artist-bar'\n\n\ninterface ChosenClusterProps {\n    closeChosenClusterGraph: Function,\n    closeChosenArtist: Function,\n    setChosenCluster: Function,\n    chosenCluster: Cluster,    \n    clusters: Cluster[],\n    clusterEdges: ClusterEdge[],\n    artistEdges: ArtistEdge[],\n    artistDict: StringDict<ArtistFull>\n}\n\ninterface ChosenClusterState {\n    elements: InsideClusterGraph\n}\n\nexport interface InsideClusterArtistNode {\n    artist: ArtistFull\n    position: {x:number, y:number}\n}\n\nexport interface InsideClusterArtistEdge {\n    id: string\n    id1: string\n    id2: string\n    weigth: number\n}\n\nexport interface InsideClusterGraph {\n    nodes: InsideClusterArtistNode[]\n    edges: InsideClusterArtistEdge[]\n}\n\nclass ChosenCluster extends React.Component<ChosenClusterProps, ChosenClusterState> {\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            elements:this.getChosenClusterGraphElements(this.props.chosenCluster)\n        }\n    }\n\n    getChosenClusterGraphElements(chosenCluster: Cluster): InsideClusterGraph {        \n        const nodes: InsideClusterArtistNode[] = [];\n        const edges: InsideClusterArtistEdge[] = [];\n\n        for (let i = 0; i < chosenCluster.artistsIds.length; i++) {\n            const currArtistId = chosenCluster.artistsIds[i];\n            const pos = chosenCluster.artistsPositions[currArtistId]\n            nodes.push({artist:this.props.artistDict[currArtistId], position: {x:pos.x, y:pos.y}})\n        }\n\n        for (let i = 0; i < this.props.artistEdges.length; i++) {\n            const id1 = this.props.artistEdges[i].id1;\n            const id2 = this.props.artistEdges[i].id2;\n            if (chosenCluster.artistsIds.includes(id1) && chosenCluster.artistsIds.includes(id2)) {\n                edges.push({id: id1+id2, id1: id1, id2: id2, weigth: this.props.artistEdges[i].weight})\n            }\n        }\n        \n        return {nodes, edges}\n    }\n\n    getSimilarClusters(): JSX.Element[] {        \n        const id = this.props.chosenCluster.id\n        const clusterEdgesWithChosenCluster: ClusterEdge[] = []\n\n        for (let i = 0; i < this.props.clusterEdges.length; i++) {\n            const clusterEdge = this.props.clusterEdges[i]            \n            if (clusterEdge.id2 !== clusterEdge.id1 && \n                (clusterEdge.id1 === id || clusterEdge.id2 === id)) {                \n                clusterEdgesWithChosenCluster.push(clusterEdge)\n            }\n        }\n        clusterEdgesWithChosenCluster.sort((a, b) => a.weight > b.weight ? -1 : 1)        \n\n        const similarClusters: JSX.Element[] = []\n        const minimalClusterSimilarity = 2\n\n        const imgWid = 60\n        const imgHei = 60\n        let artistDivStyle: CSS.Properties = {\n            width: `${imgWid}px`,\n            height: `${imgHei}px`,\n            backgroundSize: `${imgHei}px ${imgWid}px`,\n        }\n\n        for (let i = 0; i < clusterEdgesWithChosenCluster.length; i++) {                        \n            const edge = clusterEdgesWithChosenCluster[i];            \n            if (edge.weight > minimalClusterSimilarity) {                        \n                const secondId = id === edge.id1 ? edge.id2 : edge.id1\n                const similarCluster = this.props.clusters[this.props.clusters.map(e => e.id).indexOf(secondId)]\n                const similarClusterArtistsElements: JSX.Element[] = []                                \n\n                for (let j = 0; j < Math.min(similarCluster.artistsIds.length, 3); j++) {\n                    const artistId = similarCluster.artistsIds[j];\n                    const currArtist = this.props.artistDict[artistId]\n                    const artistDivStyleNew = { \n                        ...artistDivStyle,\n                        backgroundImage:`url(${currArtist.image})`\n                    }\n                    similarClusterArtistsElements.push( \n                        <div className=\"artistWrapper\">                       \n                            <div title={currArtist.name} style={artistDivStyleNew} className=\"artistDiv\"></div>                        \n                        </div>\n                    )                                        \n                }\n                \n                similarClusters.push(\n                    <div className=\"similar-cluster-div padding-margin pointer\" onClick={\n                            () => {\n                                this.props.closeChosenArtist()\n                                this.props.setChosenCluster(similarCluster)                                \n                                this.setState({\n                                    elements:this.getChosenClusterGraphElements(similarCluster)\n                                })                                \n                            }                            \n                        }>\n                        <p>Similar to: {similarCluster.genres[0]}</p>                                                \n                        <div className=\"artistsRow\">\n                            {similarClusterArtistsElements}\n                        </div>\n                    </div>\n                )\n            }\n        } \n        return similarClusters\n    }\n\n    onClick = () => {    \n        this.props.closeChosenClusterGraph()\n        this.props.closeChosenArtist()\n    }\n\n    render() {        \n        const similarClusters = this.getSimilarClusters()\n\n        return (\n            <div className=\"chosen-cluster-div\">\n                <div className=\"chosen-cluster-column\">\n                    <div className=\"similar-cluster-row\">\n                        <div className=\"go-back-div padding-margin pointer\" onClick={this.onClick}>\n                            <TiArrowBack size={50}/>\n                            <h3 className=\"h3-no-padding\">Go back to the graph</h3>\n                        </div>\n                        {similarClusters}\n                    </div>                \n                    <div className=\"chosen-cluster-graph-div\">\n                        <ChosenClusterGraphPrecomputed graphElements={this.state.elements}/>\n                    </div>                    \n                </div>  \n                \n                <ChosenArtistBar/>\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = (state: State) => {\n    return {        \n        artistEdges: state.graph.artistEdges,\n        clusters: state.graph.clusters,\n        clusterEdges: state.graph.clusterEdges,\n        artistDict: state.graph.artistDict\n    }\n}\n\nexport default connect(\n    mapStateToProps,\n    {\n        closeChosenClusterGraph,\n        closeChosenArtist,\n        setChosenCluster\n    }\n  )(ChosenCluster)\n","import React from 'react'\nimport { connect } from 'react-redux'\nimport Draggable, { DraggableEvent } from 'react-draggable'\nimport { State } from '../store/types'\nimport { setChosenCluster, } from '../store/actions'\nimport { Cluster, StringDict, ArtistFull } from '../store/types'\nimport ReactCountryFlag from 'react-country-flag'\nimport CSS from 'csstype';\nimport './cluster-node.css'\n\nvar countries = require(\"i18n-iso-countries\");\ncountries.registerLocale(require(\"i18n-iso-countries/langs/en.json\"));\n\ninterface ClusterNodeProps {\n    cluster: Cluster\n    positionX: number\n    positionY: number\n    positionChanged: Function\n    setChosenCluster: typeof setChosenCluster\n    chosenCluster?: Cluster\n\n    fontSizeConst: number\n    clusterWidth: number\n    artistDict: StringDict<ArtistFull>\n}\n\ninterface ClusterNodeState {\n    positionX: number\n    positionY: number\n    dragging: boolean\n    fontSizeDefault: number\n}\n\nclass ClusterNode extends React.Component<ClusterNodeProps, ClusterNodeState> {\n    constructor(props: ClusterNodeProps) {\n        super(props);\n        this.state = {\n            positionX: props.positionX,\n            positionY: props.positionY,\n            dragging: false,\n            fontSizeDefault: 12\n        }\n        this.onDrag = this.onDrag.bind(this)\n        this.onStop = this.onStop.bind(this)\n    }\n\n    componentDidUpdate(prevProps: ClusterNodeProps, prevState: ClusterNodeState) {\n        if (prevProps.positionX !== this.props.positionX) {\n            this.setState({positionX: this.props.positionX})\n        }\n    }   \n\n    onDrag(e: DraggableEvent, ui: any) {\n        e.stopPropagation(); e.preventDefault();\n\n        const oldX = this.state.positionX\n        const oldY = this.state.positionY\n\n        const newX = oldX + ui.deltaX\n        const newY = oldY + ui.deltaY\n\n        this.setState({dragging: true, positionX: newX, positionY: newY})\n        this.props.positionChanged(newX, newY, this.props.cluster.id)\n    }\n\n    onStop(e: DraggableEvent) {\n        e.stopPropagation(); e.preventDefault();\n        const dragging = this.state.dragging;\n        this.setState({dragging:false})\n        if (!dragging) {\n            this.handleClick(e);\n        }\n    }\n\n    handleClick(e: any) {\n        this.props.setChosenCluster(this.props.cluster)\n    }\n\n    createArtistWrapper(title: string, style: {}, key: number): JSX.Element {\n        return(\n            <div key={key} className=\"artistWrapper\">\n                <div className=\"colourWrapper\">\n                    <div title={title} style={style} className=\"artistDiv\"></div>\n                </div>\n            </div>\n        )\n    }\n\n    createEmptyWrapper(key: number): JSX.Element {\n        return <div key={key} className=\"artistWrapper\"><div></div></div>\n    }\n\n    //TODO: precompute some variables\n    clusterDiv(): JSX.Element {\n        const imgSize = this.props.clusterWidth / 4.6\n        let artistDivStyle: CSS.Properties = {\n            width: `${imgSize}px`,\n            height: `${imgSize}px`,\n            backgroundSize: `${imgSize}px ${imgSize}px`,\n        }\n\n        const rows: JSX.Element[] = [];\n        const number_of_artists = this.props.cluster.artistsIds.length\n\n        let currKey = 0\n        let l: JSX.Element[] = []\n        for (let i = 0; i < Math.min(number_of_artists, 4); i++) {\n            const currArtist = this.props.artistDict[this.props.cluster.artistsIds[i]]\n            const artistDivStyleNew = { ...artistDivStyle,\n                backgroundImage:`url(${currArtist.image})`}\n            l.push(this.createArtistWrapper(currArtist.name, artistDivStyleNew, currKey++))\n        }\n        rows.push(<div key={1} className=\"artistsRow\">{l}</div>)\n\n        l = []\n        if (number_of_artists > 4) {\n            l.push(this.createEmptyWrapper(currKey++))\n            l.push(this.createEmptyWrapper(currKey++))\n\n            for (let i = 4; i < Math.min(6, number_of_artists); i++) {\n                const currArtist = this.props.artistDict[this.props.cluster.artistsIds[i]]\n                const artistDivStyleNew = { ...artistDivStyle,\n                    backgroundImage:`url(${currArtist.image})`}\n                l.push(this.createArtistWrapper(currArtist.name, artistDivStyleNew, currKey++))\n            }\n\n            if (number_of_artists > 6) {\n                const artistDivStyleNew = { ...artistDivStyle,\n                    backgroundImage: `url(${process.env.PUBLIC_URL + '/three-dots.png'})`}\n                l.push(this.createArtistWrapper(\"AND OTHERS\", artistDivStyleNew, currKey++))\n            }\n            l.push(this.createEmptyWrapper(currKey++))\n            l.push(this.createEmptyWrapper(currKey++))\n            rows.push(<div key={2} className=\"artistsRow\">{l}</div>)\n        }\n\n\n        let headerString = \"\"\n        const numberOfGenres = this.props.cluster.genres.length\n        if (numberOfGenres === 0) {\n            headerString = \"...unknown genre...\"\n        }\n        else {\n            for (let i = 0; i < Math.min(numberOfGenres, this.props.fontSizeConst + 1); i++) {\n                if(i === 0) {\n                    headerString += this.props.cluster.genres[i]\n                }\n                else {\n                    headerString += ', ' + this.props.cluster.genres[i]\n                }\n            }\n        }\n\n        let wrapperStyle: CSS.Properties = {\n            width: `${this.props.clusterWidth}px`,\n        }\n        return (<div className=\"nodeWrapper\" style={wrapperStyle}>\n            {\n                this.props.cluster.country &&\n                <div style={{\n                    position: \"absolute\",\n                    margin: 0,\n                    left:0,  // TODO: make this variable dynamic!!!\n                    opacity: 0.4,\n                    zIndex: -1,\n                    alignItems: 'center',\n                }}>\n                    <ReactCountryFlag\n                        countryCode={countries.alpha3ToAlpha2(this.props.cluster.country)}\n                        svg\n                        style={{\n                            width: this.props.clusterWidth + 30,\n                            height: '260px' // TODO: make this variable dynamic!!!\n                        }}\n                    />\n                </div>\n            }\n\n            <div className=\"nodeHeader\">\n                <div className=\"header noselect\" style={{fontSize: this.state.fontSizeDefault / this.props.fontSizeConst + this.props.fontSizeConst}}>\n                    {headerString}\n                </div>\n            </div>\n            {rows}\n\n        </div>)\n    }\n\n    render() {\n        const clusterDiv = this.clusterDiv()\n        return (\n            <Draggable\n                onDrag={this.onDrag}\n                onStop={this.onStop}\n                onStart={(e:DraggableEvent) => {e.stopPropagation(); e.preventDefault();}}\n                bounds=\"parent\"\n                defaultPosition={{ x: this.props.positionX, y: this.props.positionY }}\n                position={{x: this.state.positionX, y:this.state.positionY}}\n            >\n                {clusterDiv}\n            </Draggable>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        chosenCluster: state.chosenCluster,\n        artistDict: state.graph.artistDict\n    }),\n    {\n        setChosenCluster,\n    }\n)(ClusterNode)\n","import React from 'react'\nimport {computeEdgeCoordinates} from '../methods/edge-calculation'\n\ninterface ClusterEdgeProps {\n    x1: number\n    y1: number\n    x2: number\n    y2: number\n    weigth: number\n    clusterWidth: number\n}\n\nexport default class ClusterEdge extends React.Component<ClusterEdgeProps, {}> {\n\n    render() {\n        const thickness = this.props.weigth\n        const {x1fin, y1fin, x2fin, y2fin, top, left, hei, wid} = computeEdgeCoordinates(\n            this.props.x1, this.props.y1, this.props.x2, this.props.y2, thickness)\n        \n        const st: React.CSSProperties ={\n            top: top + 30,\n            left: left + this.props.clusterWidth / 2\n        }\n\n        const curvature = 20\n\n        return(\n            <svg style={st} className=\"position-absolute\" width={wid+thickness+curvature} height={hei+thickness+curvature}>\n                <path \n                    d={`M ${x1fin},${y1fin} \n                        C ${x1fin+curvature},${y1fin+curvature} ${x2fin+curvature},${y2fin+curvature} ${x2fin},${y2fin}`} \n                    strokeWidth={thickness} \n                    fill=\"none\" \n                    stroke=\"black\"\n                />\n            </svg>\n        )\n    }\n}\n","/* eslint-disable @typescript-eslint/no-useless-constructor */\n\nimport React from 'react'\nimport { connect } from 'react-redux'\nimport { Graph, Cluster, State, StringDict, Position } from '../store/types'\nimport { setGraph,loadGraph,graphFromFileIsLoaded } from '../store/actions'\nimport { TransformWrapper, TransformComponent } from \"react-zoom-pan-pinch\";\nimport {computeHeigthFromPositions, computeClusterPositions} from '../methods/graph-layout'\nimport ChosenCluster from './chosen-cluster'\nimport ClusterNode from './cluster-node'\nimport ClusterEdge from './cluster-edge'\nimport './draggable-canvas.css'\nimport SpotifyWebApi from 'spotify-web-api-js'\nimport { isUndefined } from 'util';\n\n// TODO: load graph should be in try catch block\n\nclass ProgressBar extends React.Component<{progress:number}, {}> {\n    constructor(props: any) {\n        super(props);\n    }\n\n    render () {\n        return (\n            <div className=\"progressbar\">\n                <div className=\"progress\" style={{ width: `${this.props.progress*100}%`}}/>\n            </div>\n        )\n    }\n}\n\ninterface DraggableCanvasProps {\n    loadGraph: typeof loadGraph\n    graph: Graph\n\n    graphLoaded: boolean\n    graphLoading: boolean\n    spotifyError: boolean\n\n    graphLoadingMessage: string,\n    graphLoadingRelatedArtistsProgress: number,\n\n    chosenCluster: Cluster\n\n    accessToken: string\n    sp: SpotifyWebApi.SpotifyWebApiJs\n\n    graphFromFileIsLoaded: Function\n    isGraphFromFileLoaded: boolean\n}\n\ninterface DraggableCanvasState {\n    dimensions?: {w:number, h:number}\n    clusterPositions?: StringDict<Position>\n    clusterWidth: number\n    clusterHeight: number\n    currentScale: number\n\n    originalRefWidth: number\n    originalRefHeight: number\n}\n\nclass DraggableCanvas extends React.Component<DraggableCanvasProps, DraggableCanvasState> {\n    boxRef: any\n    wrapperRef: any\n\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            clusterWidth: 150,\n            clusterHeight: 150,\n            currentScale: 1,\n            originalRefHeight: 0,\n            originalRefWidth: 0\n        }\n\n        this.wrapperRef = React.createRef();\n        this.boxRef = React.createRef();\n\n        this.positionChangedHandler = this.positionChangedHandler.bind(this)\n    }\n\n    getClusterPositions(width: number, height: number): StringDict<Position> {\n        const clusterWidth = this.state.clusterWidth\n        const clusterHeigth = this.state.clusterHeight\n\n        let newHeight = height\n        console.debug(this.props.graph.clusters.length)\n        if (this.props.graph.clusters.length < 15) { newHeight -= (clusterHeigth + 20) }\n        else if (this.props.graph.clusters.length > 30) { newHeight += clusterHeigth }\n        const positions = computeClusterPositions(width, newHeight, clusterWidth, clusterHeigth, this.props.graph.clusterSquares)\n        const newHeigth = computeHeigthFromPositions(positions, clusterHeigth);\n\n        const currDimensions = this.state.dimensions ? this.state.dimensions : {w:500, h: 1000}\n        currDimensions.h = newHeigth\n        return positions\n    }\n\n    positionChangedHandler(x: number, y: number, artist_id: string) {\n        if (this.state.clusterPositions == null) {\n            return []\n        }\n        const pos = this.state.clusterPositions\n        pos[artist_id] = { x: x, y: y }\n        this.setState({clusterPositions: pos});\n    }\n\n    createNodes(): JSX.Element[] {\n        if (this.state.clusterPositions === null || isUndefined(this.state.clusterPositions)) {\n            return []\n        }\n\n        const nodes = []\n        for (let i = 0; i < this.props.graph.clusters.length; i++) {\n            const element = this.props.graph.clusters[i];\n            nodes.push(\n                <ClusterNode\n                    key={element.id}\n                    fontSizeConst={this.state.currentScale}\n                    cluster={element}\n                    positionX={this.state.clusterPositions[element.id].x}\n                    positionY={this.state.clusterPositions[element.id].y}\n                    positionChanged={this.positionChangedHandler}\n                    clusterWidth={this.state.clusterWidth}\n                />\n            )\n        }\n        return nodes\n    }\n\n    createEdges(): JSX.Element[] {\n        const edges = []\n        if (this.state.clusterPositions == null) {\n            return []\n        }\n\n        for (let i = 0; i < this.props.graph.clusterEdges.length; i++) {\n            const source = this.props.graph.clusterEdges[i].id1\n            const target = this.props.graph.clusterEdges[i].id2\n            const clusterEdgeKey = source + target\n            if (source !== target) {\n                const edgeWeigth = Math.log2(this.props.graph.clusterEdges[i].weight) * 3\n                edges.push(\n                    <ClusterEdge\n                        key={clusterEdgeKey}\n                        x1={this.state.clusterPositions[source].x}\n                        y1={this.state.clusterPositions[source].y}\n                        x2={this.state.clusterPositions[target].x}\n                        y2={this.state.clusterPositions[target].y}\n                        weigth={edgeWeigth}\n                        clusterWidth={this.state.clusterWidth}\n                    />\n                )\n            }\n        }\n\n        return edges\n    }\n\n    graphLoadedCallback(width: number, height: number) {\n        const clusterPositions =  this.getClusterPositions(width, height);\n        const notOverlappedPositions = clusterPositions;\n        this.setState({clusterPositions:notOverlappedPositions})\n    }\n\n    onResizeRecomputePositions() {\n        if (isUndefined(this.state.dimensions)) return\n        if (isUndefined(this.state.clusterPositions)) return\n\n        const origWidth = this.state.dimensions.w\n        const origHei = this.state.dimensions.h\n        const newWidth = this.wrapperRef.current.clientWidth;\n        // const newHeight = this.wrapperRef.current.clientHeight;\n\n        if (origWidth === newWidth) return\n\n        const currentPositions = this.state.clusterPositions\n        const ratio = Math.floor((newWidth / origWidth)*1024) / 1024\n        for (let key in currentPositions) {\n            currentPositions[key].x = ratio * currentPositions[key].x\n        }\n\n        this.setState({\n            dimensions: {w:newWidth, h:origHei},\n            clusterPositions: currentPositions\n        })\n    }\n\n    componentDidMount() {\n        window.addEventListener('resize', () => {this.onResizeRecomputePositions()});\n        let width = this.wrapperRef.current.clientWidth;\n        let height = this.wrapperRef.current.clientHeight;\n        this.setState(\n            {\n                dimensions: {w:width, h:height},\n                originalRefWidth: width,\n                originalRefHeight: height\n            },\n            () => this.props.loadGraph(this.props.accessToken, this.props.sp, () => this.graphLoadedCallback(width, height))\n        )\n    }\n\n    componentDidUpdate(prevProps: DraggableCanvasProps, prevState: DraggableCanvasState) {\n        if (this.props.isGraphFromFileLoaded) {\n            let w = 500\n            let h = 500\n            if (!isUndefined(this.state.dimensions)) {\n                w = this.state.dimensions.w\n                h = this.state.dimensions.h\n            }\n            // w = this.state.originalRefWidth \n            h = this.state.originalRefHeight\n            this.graphLoadedCallback(w, h)\n            this.props.graphFromFileIsLoaded(false)\n        }\n    }\n\n    render() {\n        // TODO: fix these error and loading lines\n        // TODO put these divs into methods\n        if (this.props.graphLoading) {\n            return (\n                <div className=\"page-wrapper\">\n                    <div className=\"generic-description\">{this.props.graphLoadingMessage}</div>\n                    <ProgressBar progress={this.props.graphLoadingRelatedArtistsProgress}/>\n                </div>\n            )\n        }\n\n        if (this.props.spotifyError) {\n            return (\n                <div>Error while loading</div>\n\n            )\n        }\n\n        const clusterIsChosen = this.props.chosenCluster !== undefined\n        let display = \"\";\n        if (clusterIsChosen) {\n            display = \"none\";\n        }\n\n        const w = this.state.dimensions ? this.state.dimensions.w : 500\n        const h = this.state.dimensions ? this.state.dimensions.h : 500\n        const divToReturn = (\n            <div className=\"wrapper\" ref={this.wrapperRef}>\n                <TransformWrapper\n                    defaultScale={1}\n                    defaultPositionX={1}\n                    defaultPositionY={1}\n                    options={{\n                        maxScale:4,\n                        limitToWrapper: true,\n                    }}\n                    onWheelStop={(e:any) => { this.setState({currentScale: e.scale}) }}\n                >\n                    {({\n                        zoomIn,\n                        zoomOut,\n                        setTransform,\n                        ...rest\n                    }: any) => (\n                    <React.Fragment>\n                        {clusterIsChosen && <ChosenCluster key={this.props.chosenCluster.id} chosenCluster={this.props.chosenCluster}/>}\n                        <TransformComponent>\n                            <div className=\"box\" ref={this.boxRef}\n                                style={{ width: w, height: h, display:display }}\n                            >\n                                {\n                                    this.state.dimensions &&\n                                    this.createEdges()\n                                }\n                                {\n                                    this.state.dimensions &&\n                                    this.createNodes()\n                                }\n                            </div>\n                        </TransformComponent>\n                    </React.Fragment>\n                    )}\n                </TransformWrapper>\n            </div>\n        )\n        return divToReturn\n    }\n}\n\n\nconst mapStateToProps = (state: State) => {\n    return {\n        graphLoaded: state.graphLoaded,\n        graphLoading: state.graphLoading,\n        spotifyError: state.isGraphLoadingError,\n        graphLoadingMessage: state.graphLoadingMessage,\n        graphLoadingRelatedArtistsProgress: state.graphLoadingRelatedArtistsProgress,\n\n        graph: state.graph,\n        chosenCluster: state.chosenCluster,\n\n        accessToken: state.accessToken,\n        sp: state.spotifyWebApiObject,\n        \n        isGraphFromFileLoaded: state.isGraphFromFileLoaded\n    }\n}\n\nconst mapDispatchToProps = (dispatch: any) => {\n    return {\n        setGraph: setGraph,\n        graphFromFileIsLoaded: (isLoaded: boolean) => dispatch(graphFromFileIsLoaded(isLoaded)),\n        loadGraph: (accessToken: string, sp:SpotifyWebApi.SpotifyWebApiJs, callback: Function) => dispatch(loadGraph(accessToken, sp, callback))\n    }\n}\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps\n  )(DraggableCanvas)\n","import React from 'react'\nimport { connect } from 'react-redux'\nimport { State, SongFull, StringDict, ArtistSimplified, ArtistFull } from '../store/types'\nimport { isUndefined } from 'util'\nimport { setPaused } from '../store/actions'\nimport './draggable-canvas.css'\nimport './styles.css'\n\ninterface PlayerProps {\n    accessToken?: string\n    songToPlay?: SongFull\n    paused: boolean\n    setPaused: Function\n    nonFavouriteArtistDict: StringDict<ArtistSimplified>\n    favouriteArtistDict: StringDict<ArtistFull>\n}\n\nclass Player extends React.Component<PlayerProps, {}> {\n    playerRef: any\n    constructor(props: any) {\n        super(props);\n        this.playerRef = React.createRef();\n    }\n\n    componentDidUpdate() {\n        if (this.playerRef.current !== null) {\n            if (this.props.paused) {\n                this.playerRef.current.pause()\n            }\n            else {\n                this.playerRef.current.play()\n            }\n        }\n    }\n\n    render() {\n        if (isUndefined(this.props.accessToken)) {\n            return(\n                <div></div>\n            )\n        }\n        else if (isUndefined(this.props.songToPlay)) {\n            return (\n                <div className=\"empty-player\">\n                    <div className=\"generic-description-small-margin\">Choose some artist and some song and listen to a preview</div>\n                </div>\n            )\n        }\n        else {\n            let mp3Link = ''\n            let artistsDescriptionNames = []\n            for (let i = 0; i < this.props.songToPlay.artistsIds.length; i++) {\n                const aID = this.props.songToPlay.artistsIds[i];\n                if (aID in this.props.favouriteArtistDict) {\n                    artistsDescriptionNames.push(this.props.favouriteArtistDict[aID].name)\n                }\n                else if (aID in this.props.nonFavouriteArtistDict) {\n                    artistsDescriptionNames.push(this.props.nonFavouriteArtistDict[aID].name)\n                }\n                else {\n                    artistsDescriptionNames.push(aID)\n                }\n            }\n            const artistsDescription = artistsDescriptionNames.join(', ')\n            mp3Link = this.props.songToPlay.previewLink\n            \n            return (\n                <div className=\"player\">\n                    <div className=\"flex1\">\n                        <p className=\"playingSongName\"><b>{this.props.songToPlay.name}</b></p>\n                        <p className=\"playingSongArtists\">{artistsDescription}</p>                        \n                    </div>\n                    <audio onPlay={() => this.props.setPaused(false)} \n                        onPause={() => this.props.setPaused(true)} \n                        ref={this.playerRef} \n                        autoPlay controls src={mp3Link} className=\"playerControls\"\n                    >\n                        Your browser does not support the\n                        <code>audio</code> element.\n                    </audio>\n                </div>\n            )\n        }\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        paused: state.paused,\n        accessToken: state.accessToken,\n        songToPlay: state.songToPlay,\n        favouriteArtistDict: state.graph.artistDict,\n        nonFavouriteArtistDict: state.nonFavouriteArtistDict\n    }),\n    {\n        setPaused\n    }\n)(Player)\n","import * as React from 'react';\nimport './page-content.css'\nimport DraggableCanvas from './draggable-canvas'\nimport Player from './player'\n\nclass PageContent extends React.Component<{}, {}> {\n    render() {\n        return (\n            <div className=\"mainDiv\">\n                <div className=\"mainDivContent\">\n                    <DraggableCanvas/>\n                </div>\n                <Player/>\n            </div>\n        )\n    }\n}\n\nexport default PageContent\n","import * as React from 'react';\nimport { connect } from 'react-redux';\nimport { State, StringDict, ArtistFull, Cluster, Graph} from '../store/types'\nimport {isUndefined} from 'util'\nimport {loadGraphFromFile} from '../store/actions'\nimport './side-bar.css'\nimport './styles.css'\n\n\ninterface SideBarProps {\n    chosenCluster?: Cluster\n    chosenArtist?: ArtistFull\n    graph: Graph\n    artistDict: StringDict<ArtistFull>\n    loadGraphFromFile: Function\n    graphLoaded: boolean\n}\n\ninterface SideBarState {}\n\nclass SideBar extends React.Component<SideBarProps, SideBarState> {\n    constructor(props: SideBarProps) {\n        super(props);\n        this.dowloadGraph = this.dowloadGraph.bind(this)\n        this.uploadGraph = this.uploadGraph.bind(this)\n    }\n\n    chosenClusterArtists(): JSX.Element {\n        let chosenClusterArtists: JSX.Element[] = []\n        if (this.props.chosenCluster !== undefined) {\n            chosenClusterArtists =\n                this.props.chosenCluster.artistsIds.map(\n                    id => <li className=\"shift-left\">{this.props.artistDict[id].name}</li>\n                )\n        }\n        return <ul>{chosenClusterArtists}</ul>\n    }\n\n    chosenClusterProperties(): JSX.Element {\n        let properties: JSX.Element[] = []\n        if (this.props.chosenCluster !== undefined) {\n            properties = this.props.chosenCluster.genres.map(a => <li className=\"shift-left\">{a}</li>)\n        }\n        return <ul>{properties}</ul>\n    }\n\n    dowloadGraph() {\n        if (!this.props.graph) return \n\n        const element = document.createElement('a');\n        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(JSON.stringify(this.props.graph, null, 4)));\n        element.setAttribute('download', 'mySpotifyGraph.json');\n        element.style.display = 'none';\n        document.body.appendChild(element);\n        element.click();\n        document.body.removeChild(element);\n    }\n    \n    uploadGraph(selectorFiles: FileList) {\n        const corruptedFileAlert = 'Sorry, this file seems to be not in the correct format.\\n Error:'\n        console.log(selectorFiles)\n        // TODO: condition for file format\n        // TODO: JSON validator.. :/\n        const file = selectorFiles[0]\n        const reader = new FileReader()\n        const loadGraphFromFileFunc = (g: Graph) => (this.props.loadGraphFromFile(g))\n\n        reader.onload = function(event) {\n            if (event.target !== null && event.target.result !== null) {\n                try {\n                    const resultString = event.target.result.toString()\n                    const resultJSON = isUndefined(resultString) ? {} : JSON.parse(resultString)\n                    const g: Graph = resultJSON\n                    loadGraphFromFileFunc(g)\n                } catch (error) {\n                    alert(corruptedFileAlert + error)\n                    console.debug('error while graph loading from file:',error)\n                }\n            }\n            else {\n                alert(corruptedFileAlert)\n            }\n        };\n        \n        reader.readAsText(file);\n    }\n\n    render() {                \n        return (\n            <div className=\"sideBar\">\n                <div className=\"sideBarHeader\">\n                    <img width={40} height={40} className=\"spotify-image\" alt=\"\" src=\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Ik0xOS4wOTggMTAuNjM4Yy0zLjg2OC0yLjI5Ny0xMC4yNDgtMi41MDgtMTMuOTQxLTEuMzg3LS41OTMuMTgtMS4yMi0uMTU1LTEuMzk5LS43NDgtLjE4LS41OTMuMTU0LTEuMjIuNzQ4LTEuNCA0LjIzOS0xLjI4NyAxMS4yODUtMS4wMzggMTUuNzM4IDEuNjA1LjUzMy4zMTcuNzA4IDEuMDA1LjM5MiAxLjUzOC0uMzE2LjUzMy0xLjAwNS43MDktMS41MzguMzkyem0tLjEyNiAzLjQwM2MtLjI3Mi40NC0uODQ3LjU3OC0xLjI4Ny4zMDgtMy4yMjUtMS45ODItOC4xNDItMi41NTctMTEuOTU4LTEuMzk5LS40OTQuMTUtMS4wMTctLjEyOS0xLjE2Ny0uNjIzLS4xNDktLjQ5NS4xMy0xLjAxNi42MjQtMS4xNjcgNC4zNTgtMS4zMjIgOS43NzYtLjY4MiAxMy40OCAxLjU5NS40NC4yNy41NzguODQ3LjMwOCAxLjI4NnptLTEuNDY5IDMuMjY3Yy0uMjE1LjM1NC0uNjc2LjQ2NS0xLjAyOC4yNDktMi44MTgtMS43MjItNi4zNjUtMi4xMTEtMTAuNTQyLTEuMTU3LS40MDIuMDkyLS44MDMtLjE2LS44OTUtLjU2Mi0uMDkyLS40MDMuMTU5LS44MDQuNTYyLS44OTYgNC41NzEtMS4wNDUgOC40OTItLjU5NSAxMS42NTUgMS4zMzguMzUzLjIxNS40NjQuNjc2LjI0OCAxLjAyOHptLTUuNTAzLTE3LjMwOGMtNi42MjcgMC0xMiA1LjM3My0xMiAxMiAwIDYuNjI4IDUuMzczIDEyIDEyIDEyIDYuNjI4IDAgMTItNS4zNzIgMTItMTIgMC02LjYyNy01LjM3Mi0xMi0xMi0xMnoiLz48L3N2Zz4=\"></img>\n                    <h1>Spotify graph</h1>\n                </div>\n                <div>Graph of your musical taste ♬♫</div>\n\n                { this.props.graphLoaded && \n                    <div className=\"download-button pointer\" onClick={this.dowloadGraph}>\n                        Download graph to JSON\n                    </div> \n                }\n                { this.props.graphLoaded && \n                    <input className=\"download-button\" type=\"file\" accept=\".json\" onChange={ (e) => { \n                        if (e.target.files !== null) this.uploadGraph(e.target.files)\n                    }}/>\n                }\n\n                <div className=\"sideBarContent\">\n                    { this.props.chosenCluster &&\n                        <div className=\"box-with-margin\">\n                            <h2>mostly these genres</h2>\n                            {this.chosenClusterProperties()}\n                        </div>\n                    }\n                    { this.props.chosenCluster &&\n                        <div className=\"box-with-margin\">\n                            <h2 className=\"text-align-center\">group of artists</h2>\n                            {this.chosenClusterArtists()}\n                        </div>\n                    }\n\n                    { !!!this.props.chosenCluster && this.props.graph &&\n                        <div className=\"box-with-margin\">\n                            <p>We took the artists from your <b>liked</b> songs and the artists that <b>you follow</b>.</p>\n                            <p>We found <b>{Object.values(this.props.graph.artistDict).length} artist</b> that you like.</p>                            \n                            <p>We divided them into clusters you're seing right now. The clusters are based on <b>genres</b> and <b>preferences</b> of other users of Spotify</p>\n                            <p>Click the cluster and explore how the artists are connected.</p>\n                        </div>\n                    }\n                </div>                \n            </div>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        chosenCluster: state.chosenCluster,\n        chosenArtist: state.chosenArtist,\n        graph: state.graph,\n        sp: state.spotifyWebApiObject,\n        artistDict: state.graph.artistDict,\n        graphLoaded: state.graphLoaded\n    }),\n    { \n        loadGraphFromFile \n    }\n)(SideBar)\n","import React from 'react'\nimport { Redirect } from \"react-router-dom\";\nimport PageContent from './page-content'\nimport SideBar from './side-bar'\nimport '../App.css'\nimport { connect } from 'react-redux'\nimport { State } from '../store/types'\nimport {setAccessToken} from '../store/actions'\nimport { withRouter } from \"react-router-dom\";\nimport { RouteComponentProps } from \"react-router\";\n\n\ninterface MyGraphPageProps extends RouteComponentProps<any> {        \n    loggedIn: boolean\n    setAccessToken: typeof setAccessToken\n}\n\ninterface MyGraphPageState {\n    loggingLoading: boolean\n    loggingFailed: boolean\n}\n\nclass MyGraphPage extends React.Component<MyGraphPageProps, MyGraphPageState> {\n    constructor(props: MyGraphPageProps) {\n        super(props);\n        this.state = {\n            loggingLoading: true,\n            loggingFailed: false\n        }\n\n        this.afterSpotifyLogin()\n    }\n    \n    afterSpotifyLogin() {\n        const urlParams = window.location.search\n        var query = urlParams.substr(1);\n        var result: any = {};\n        query.split(\"&\").forEach(function(part: string) {\n            var item = part.split(\"=\");\n            result[item[0]] = decodeURIComponent(item[1]);   \n        })\n        if (!('code' in result) || result['code'] === '' || result['code'] === null) {\n            this.state = {loggingFailed:true, loggingLoading:false}\n            return\n        }\n\n        const currentPathName = this.props.history.location.pathname\n        this.props.history.push({\n            pathname: currentPathName,\n            search: ''\n        })\n\n        const linkToBackendWithoutCode = process.env.NODE_ENV === \"production\" ? process.env.REACT_APP_PROD_BACKEND_URL_LOGGED_IN : process.env.REACT_APP_DEV_BACKEND_URL_LOGGED_IN\n        const linkToBackend = linkToBackendWithoutCode +  result['code']\n        let accessToken: string = ''\n        fetch(linkToBackend)\n        .then((response) => {\n            if(response.status !== 200) {\n                throw response.status\n            }       \n            const tryAccessToken = response.headers.get('access-token')\n            if (tryAccessToken !== null) {\n                accessToken = tryAccessToken\n                this.props.setAccessToken(accessToken)\n                // this.props.setSpotifyApi(accessToken)\n            }\n\n            this.setState({loggingLoading:false})\n        })\n        .catch((error) => {\n            console.debug(error)\n            this.setState({loggingFailed:true, loggingLoading:false})\n            alert('Sorry, we did not manage to log you in Spotify.')\n        })\n    }\n\n\n    render() {\n        if (this.state.loggingLoading) {\n            return (\n                <div className=\"App\">\n                    <div className=\"page-wrapper\">\n                        <div className=\"loader\"/>\n                        <div className=\"generic-description\">Logging into Spotify</div>\n                    </div>\n                </div>\n            )\n        }\n\n        if (this.state.loggingFailed) {\n            return <Redirect to=\"/login\"/>\n        }        \n\n        return (\n            <div className=\"App\">\n                <SideBar/>\n                <PageContent />\n            </div>\n        )\n    }\n}\n\nexport default withRouter<MyGraphPageProps, any>(\n    connect(\n        (state: State) => ({\n            loggedIn: state.userLoggedIn\n        }),\n        (dispatch: any) => ({\n            setAccessToken: (accessToken: string) => dispatch(setAccessToken(accessToken)),\n        })\n    )(MyGraphPage)\n)\n","import React from 'react'\nimport { Provider } from 'react-redux'\nimport { createStoreInstance } from './store/reducers'\nimport { BrowserRouter, Switch, Route } from \"react-router-dom\";\nimport WelcomePage from './components/welcome-page'\nimport './App.css'\nimport LoginPage from './components/login-page'\nimport MyGraphPage from './components/my-graph-page';\n\nexport const storeInstance = createStoreInstance()\n\nconst App: React.FC = () => {\n    return (\n        <Provider store={storeInstance}>\n            {/* <BrowserRouter basename=\"/spotifygraph\"> */}\n            <BrowserRouter basename={process.env.PUBLIC_URL}>\n                <Switch>\n                    <Route path=\"/login\" component={LoginPage}/>\n                    <Route path=\"/mygraph\" component={MyGraphPage}/>\n                    <Route path=\"/\"  component={WelcomePage}/>\n                </Switch>\n            </BrowserRouter>            \n        </Provider>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n// import * as serviceWorker from './serviceWorker';\n\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}