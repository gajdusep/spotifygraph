{"version":3,"sources":["store/reducers.tsx","components/welcome-page.tsx","components/login-page.tsx","methods/graph-parsing-methods.tsx","methods/spotify-methods.tsx","store/types.tsx","store/actions.tsx","methods/graph-layout.tsx","methods/edge-calculation.tsx","components/artist-edge.tsx","methods/colors.tsx","components/artist-node.tsx","components/chosen-cluster-graph.tsx","components/chosen-artist-bar.tsx","components/recommendation-panel.tsx","components/chosen-cluster.tsx","components/cluster-node.tsx","components/cluster-edge.tsx","components/progress-bar.tsx","components/draggable-canvas.tsx","components/player.tsx","components/page-content.tsx","components/side-bar.tsx","components/my-graph-page.tsx","App.tsx","index.tsx"],"names":["middleWare","loggerMiddleware","createLogger","predicate","getState","action","process","collapsed","push","thunk","getInitialState","isGraphLoadingError","graphLoaded","graphLoading","chosenArtistLoading","userLoggedIn","graph","clusters","clusterEdges","artistEdges","clusterSquares","artistDict","spotifyWebApiObject","SpotifyWebApi","graphLoadingRelatedArtistsProgress","graphLoadingMessage","paused","isGraphFromFileLoaded","nonFavouriteArtistDict","rootReducer","state","reducer","WelcomePage","props","className","onClick","history","href","target","React","Component","withRouter","connect","loggedIn","LoginPage","p","params","client_id","response_type","redirect_uri","scope","join","Object","entries","map","kv","encodeURIComponent","window","location","assign","this","spotifyLoginLink","loginWithSpotify","parseClusters","artistsDict","clusterJsons","i","length","key","id","clusterArtists","clusterArtistsPositions","artistsPositions","artistsSpotifyId","artistPosition","x","y","sort","a","b","score","currCluster","genres","artistsIds","aFull","country","processClusterPositions","positions","square","clusterSquare","values","asyncTimeout","ms","Promise","resolve","setTimeout","getCookie","name","document","cookie","xsrfCookies","split","c","trim","filter","startsWith","decodeURIComponent","songFromJSONData","element","preview_url","console","debug","previewLink","artists","externalUrl","external_urls","spotify","getFollowedArtistsIds","sp","limit","result","maxRetries","after","success","retries","options","getFollowedArtists","response","getResponseHeader","parseInt","headers","isUndefined","items","artObj","cursors","getAllRelatedArtists","artistsToExploreIds","alreadyLoadedRelatedArtists","progressBarCallback","artistsToExploreLen","aID","getArtistRelatedArtists","obtainedRelArtists","objectFull","getLikedSongs","offset","next","getMySavedTracks","trackObj","track","getArtistsIdsFromLikedSongs","likedSongs","likedSongsArtistsIdsNonDistinct","objectTrackFull","reduce","acc","currVal","concat","artistObjectSimplified","Set","getAllArtistsFull","allArtistsIds","getArtists","slice","Error","createArtistDictWithFullInformation","artistsFull","relatedArtistsFinal","followedArtistsIdsSet","dictToReturn","artist","artistImage","images","url","isFollowed","has","popularity","followedScore","image","relatedArtistsIds","song","j","songArtist","simplArtist","art","dictArtistFullToReduced","artistsDictFull","artistsDictReduced","artFull","fetchAllDataFromSpotify","accessToken","setGraphLoadingMessageFunction","setGraphLoadingProgress","setGraphLoadingError","setAccessToken","likedSongsArtistsIds","followedArtistsIds","relatedArtistsStorageName","storageRelatedArtistsValue","localStorage","getItem","JSON","parse","setItem","stringify","csfrtoken","calculateGraphLink","jsonReponse","fetch","method","body","fetchReponse","ok","json","status","statusText","text","artistEdgesJSONs","edge","id1","id2","weight","clusterEdgesJsons","g","PositionType","t","SongFullType","ArtistFullType","ArtistEdgeType","ClusterType","type","optional","ClusterEdgeType","GraphType","setChosenArtist","payload","produce","chosenArtist","setChosenCluster","cluster","chosenCluster","setGraph","setGraphLoadingMessage","message","setGraphLoadingErrorMessage","errorMessage","graphLoadingErrorMessage","progress","graphLoadingSuccess","setChosenArtistError","error","chosenArtistError","setChosenArtistLoading","loading","setChosenArtistData","artistData","chosenArtistData","setPaused","updateNotFavouriteArtists","artistsToUpdate","currentNotFavouriteDict","favouriteDict","setChosenArtistDataAll","dispatch","s","notLikedSongs","artistToUpdate","areSongsEqual","s1","s2","getArtistTopTracks","then","topTracks","currentArtistId","currArtistToUpdate","tracks","songToCheck","indexOfLiked","findIndex","likedSong","catch","finally","graphFromFileIsLoaded","isLoaded","getBigComponentsPositions","bigClusterSquares","finalPositions","screenParams","clusterId","clusterPosition","newX","width","clusterWidth","newY","height","tryFillFreeSpace","clusterInComponent","clusterComponents","freeRectMatrix","possibleRectanglePositions","notUsedClusterComponents","freeRectMatrixRows","freeRectMatrixCols","wholeLoop","foundSomeCoords","clusterComponent","rowLoop","row","col","coordCombinations","coordIndex","coordArray","isLegit","every","rIndex","cIndex","clusterIds","keys","k","rect","left","top","notUsedIndex","getRestComponentsPositions","oneClusterComponents","twoClusterComponents","threeClusterComponents","currentHeight","rectangles","pos","clusterHeigth","getPossibleFreePositions","notUsedThreeClusterComponents","notUsedTwoClusterComponents","notUsedOneClusterComponents","newRects","currentY","currentX","middleX","middleY","circleRadius","angle","Math","random","coords","cos","PI","sin","squareChange","clusterRect","hasCollisions","computeHeigthFromPositions","maxY","_colliding","start1","end1","start2","end2","rects","res","r","rect2","rect1","clusterHeight","numberToWidth","floor","numberToheight","noRectangles","computeEdgeCoordinates","x1","y1","x2","y2","thickness","wid","hei","y1fin","y2fin","x1fin","x2fin","ArtistEdge","weigth","st","artistWidth","edgeColor","maximumEdgeWeigth","style","d","strokeWidth","fill","stroke","COLORS","lightAzureBlue","darkAzureBlue","pink","green","grey","orange","ArtistNode","currentPositionX","positionX","currentPositionY","positionY","dragging","onDrag","bind","onStop","e","ui","stopPropagation","preventDefault","setState","newCurrX","deltaX","newCurrY","deltaY","positionChangedCallback","handleClick","setChosenArtistDataAllFunc","color","indexOf","artistImageDivStyle","backgroundImage","backgroundSize","borderRadius","alignSelf","minimumScore","bounds","defaultPosition","backgroundColor","ChosenClusterGraph","boxRef","wrapperRef","getSliderLimits","artistsSliderLimits","edgesSliderLimits","currSliderValue","nodes","artistSliderValue","minimum","edgesSliderValue","descriptionHover","minimumEdgeWeight","maximumEdges","createRef","positionChangedHandler","changeArtistSliderValue","changeEdgeSliderValue","prevprops","prevstate","graphElements","prepareAfterGraphDataUpdate","prepareAfterSliderUpdate","current","clientWidth","clientHeight","createdNodes","createNodes","elem","newArtistsPositions","compX","position","compY","maximum","artistScore","edgesValues","edges","el","ceil","l","artist_id","node1id","node2id","edgeWeigth","clusterEdgeKey","node1","idArtistDict","node2","err","currentTarget","valueAsNumber","min","max","step","value","onChange","showDescriptionStyle","display","handle","createEdgeSlider","createArtistSlider","onMouseEnter","changeHover","onMouseLeave","size","ref","getDraggableSlider","createEdges","ChosenArtistBar","prepareSongs","liked","notLiked","chosenSongId","songId","prevProps","prevState","includes","maxHeight","playerIcon","setSongToPlay","chosenSongColorIndicator","songToPlay","setPause","likedSongColorIndicator","alert","setChosenSong","marginRight","flexDirection","justifyContent","alignContent","open","spotifyApiObject","addToMySavedTracks","likedSongsOld","notLikedSongsOld","songs","toReturn","getSongDiv","margin","getSongsDivs","RecommendationPanel","questionMarkHover","artistsToRecommend","getArtistsToRecommend","counter","getCounter","clusterArtistsIds","topIds","getTopIds","fetchArtistsPromise","finalArtists","related","relID","count","counterKeys","counterValues","toSort","val","o","artistFull","wrapperStyle","padding","nodeHeight","token","title","borderColor","flex","textAlign","divs","createRecommendArtistDiv","showHover","ChosenCluster","closeChosenClusterGraph","closeChosenArtist","elements","getChosenClusterGraphElements","currArtistId","clusterEdgesWithChosenCluster","clusterEdge","similarClusters","artistDivStyle","secondId","similarCluster","similarClusterArtistsElements","artistId","currArtist","artistDivStyleNew","getSimilarClusters","undefined","countries","require","registerLocale","ClusterNode","fontSizeDefault","oldX","oldY","positionChanged","imgSize","rows","numberOfArtists","currKey","createArtistWrapper","createEmptyWrapper","headerString","numberOfGenres","fontSizeConst","opacity","zIndex","alignItems","countryCode","alpha3ToAlpha2","svg","fontSize","clusterDiv","onStart","ClusterEdge","ProgressBar","DraggableCanvas","currentScale","originalRefHeight","originalRefWidth","clusterPositions","newHeight","toRet","bigComponent","clustersInSquares","computeClusterPositions","newHeigth","dimensions","w","h","origWidth","origHei","newWidth","currentPositions","ratio","addEventListener","onResizeRecomputePositions","loadGraph","graphLoadedCallback","source","log2","createGraphLoadingDiv","createSpotifyErrorDiv","clusterIsChosen","defaultScale","defaultPositionX","defaultPositionY","maxScale","limitToWrapper","onWheelStop","scale","zoomIn","zoomOut","setTransform","Fragment","callback","Player","playerRef","pause","play","mp3Link","artistsDescriptionNames","favouriteArtistDict","artistsDescription","onPlay","onPause","autoPlay","controls","src","PageContent","SideBar","dowloadGraph","uploadGraph","createElement","setAttribute","appendChild","click","removeChild","selectorFiles","corruptedFileAlert","log","file","reader","FileReader","onload","event","resultString","toString","loadGraphFromFile","loadGraphFromFileFunc","readAsText","properties","alt","graphLoadingError","accept","files","createChosenClusterGenres","createChosenClusterArtists","jsonToParse","decode","isRight","MyGraphPage","loggingLoading","loggingFailed","afterSpotifyLogin","query","search","substr","forEach","part","item","currentPathName","pathname","linkToBackend","tryAccessToken","get","to","storeInstance","createStore","compose","applyMiddleware","App","store","basename","path","component","ReactDOM","render","getElementById"],"mappings":"kfAMMA,EAAkB,GAClBC,EAAmBC,uBAAa,CAClCC,UAAW,SAACC,EAAoBC,GAArB,OAA+CC,GAC1DC,UAAW,SAACH,EAAUC,GAAX,OAAsB,KAErCL,EAAWQ,KAAKC,KAChBT,EAAWQ,KAAKP,GAGhB,IAAMS,EAAkB,WACpB,MAAQ,CACJC,qBAAqB,EACrBC,aAAa,EACbC,cAAc,EACdC,qBAAqB,EACrBC,cAAc,EACdC,MAAQ,CAAEC,SAAU,GAAIC,aAAc,GAAIC,YAAa,GAAIC,eAAgB,GAAIC,WAAY,IAC3FC,oBAAqB,IAAIC,IACzBC,mCAAoC,EACpCC,oBAAqB,GACrBC,QAAQ,EACRC,uBAAuB,EACvBC,uBAAwB,KAI1BC,EAAc,WAGd,IAFFC,EAEC,uDAFcpB,IACfL,EACC,uCACD,OAAKA,EAAO0B,QACA1B,EAAO0B,QAAQD,GADCA,G,4CCpB1BE,G,8DACF,WAAYC,GAA0B,uCAC5BA,G,qDAGA,IAAD,OACL,OACI,yBAAKC,UAAU,OACX,yBAAKA,UAAU,gBACX,yBAAKA,UAAU,wBACX,6CACA,+EACA,oJAEJ,4BAAQA,UAAU,kBAAkBC,QAAS,WAAQ,EAAKF,MAAMG,QAAQ5B,KAAK,YAA7E,8BACA,yBAAK0B,UAAU,uBACX,0DAA+B,uBAAGG,KAAK,2CAA2CC,OAAO,UAA1D,kB,GAhB7BC,IAAMC,YAwBjBC,cACXC,aACI,SAACZ,GAAD,MAAmB,CACfa,SAAUb,EAAMf,gBAEpB,GAJJ2B,CAKEV,IClCeY,E,kDACjB,WAAYX,GAAwB,uCAC1BA,G,+DAKN,IAwByBY,EARnBC,EAAS,CACXC,UAjBc,mCAkBdC,cAAc,OACdC,aAJA3C,kDAKA4C,MAnBU,CACV,YACA,kBACA,oBACA,2BACA,6BACA,oBACA,sBACA,mBACA,0BACA,yBASYC,KAAK,KACjBrB,MARU,qBAed,MADa,2CAHYe,EAGgDC,EAFrEM,OAAOC,QAAQR,GAAGS,KAAI,SAAAC,GAAE,OAAIA,EAAGD,IAAIE,oBAAoBL,KAAK,QAAMA,KAAK,Q,yCAO3EM,OAAOC,SAASC,OAAOC,KAAKC,sB,+BAGtB,IAAD,OACL,OACI,yBAAK3B,UAAU,OACX,yBAAKA,UAAU,gBACX,yBAAKA,UAAU,uBACX,wEAEJ,4BAAQA,UAAU,kBAAkBC,QAAS,kBAAM,EAAK2B,qBAAxD,0C,GAjDmBvB,IAAMC,W,+ECEhCuB,EAAgB,SAACC,EAAqCC,GAE/D,IADA,IAAIhD,EAAsB,GACjBiD,EAAI,EAAGA,EAAID,EAAaE,OAAQD,IAAK,CAO1C,IANA,IAAME,EAAMH,EAAaC,GAAGG,GAGtBC,EAA+B,GAC/BC,EAAgD,GAEtD,MAAiDnB,OAAOC,QAAQY,EAAaC,GAAGM,kBAAhF,eAAmG,CAAC,IAAD,sBAAvFC,EAAuF,KAArEC,EAAqE,KAC/FJ,EAAe9D,KAAKwD,EAAYS,IAChCF,EAAwBE,GAAoB,CAAEE,EAAGD,EAAeC,EAAGC,EAAGF,EAAeE,GAGzFN,EAAeO,MAAK,SAACC,EAAGC,GAAQ,OAAOA,EAAEC,MAAQF,EAAEE,SAEnD,IAAMC,EAAwB,CAC1BZ,GAAID,EACJc,OAAQjB,EAAaC,GAAGgB,OACxBC,WAAYb,EAAehB,KAAI,SAAA8B,GAAK,OAAIA,EAAMf,MAC9CG,iBAAkBD,EAClBc,QAASpB,EAAaC,GAAGmB,SAE7BpE,EAAST,KAAKyE,GAElB,OAAOhE,GAQEqE,EAA0B,SAACC,GAEpC,IADA,IAAInE,EAAkC,GAC7B8C,EAAI,EAAGA,EAAIqB,EAAUpB,OAAQD,IAAK,CAEvC,IAAMsB,EAASD,EAAUrB,GACnBuB,EAA+B,GACrC,GAAIrC,OAAOsC,OAAOF,GAAQrB,OAAS,EAAG,CAClC,IAAK,IAAIE,KAAMmB,EAAQ,CACnB,IAAIb,EAAIa,EAAOnB,GAAIM,EACfC,EAAIY,EAAOnB,GAAIO,EACnBa,EAAcpB,GAAM,CAAEM,EAAGA,EAAGC,EAAGA,GAEnCxD,EAAeZ,KAAKiF,IAI5B,OAAOrE,GClDLuE,EAAe,SAACC,GAClB,OAAO,IAAIC,SAAQ,SAAAC,GAAO,OAAIC,WAAWD,EAASF,OAGhDI,EAAY,SAACC,GACf,IAAKC,SAASC,OACV,MAAO,GAGX,IAAMC,EAAcF,SAASC,OAAOE,MAAM,KACrC/C,KAAI,SAAAgD,GAAC,OAAIA,EAAEC,UACXC,QAAO,SAAAF,GAAC,OAAIA,EAAEG,WAAWR,EAAO,QAErC,OAA2B,IAAvBG,EAAYjC,OACL,GAEJuC,mBAAmBN,EAAY,GAAGC,MAAM,KAAK,KAI3CM,EAAmB,SAACC,GAK7B,OAJ4B,OAAxBA,EAAQC,aACRC,QAAQC,MAAMH,EAAQvC,GAAI,IAAKuC,EAAQX,KAAMW,GAG1C,CACHX,KAAMW,EAAQX,KACd5B,GAAIuC,EAAQvC,GACZ2C,YAAaJ,EAAQC,YACrB1B,WAAYyB,EAAQK,QAAQ3D,KAAI,SAAAwB,GAAC,OAAIA,EAAET,MACvC6C,YAAaN,EAAQO,cAAcC,UASrCC,EAAqB,uCAAG,WAAOC,GAAP,6BAAAxC,EAAA,sDAEtByC,EAAQ,GACRC,EAAmB,GAGjBC,EAAa,EACfC,EAAQ,KAPc,OASlBC,GAAU,EACVC,EAAU,EAVQ,uBAaRC,EAAcH,EAAQ,CAAEH,MAAOA,EAAOG,MAAOA,GAAU,CAAEH,MAAOA,GAbxD,UAcGD,EAAGQ,mBAAmBD,GAdzB,QAcdE,EAdc,0EAgBRpC,EAAa,KAAIqC,kBAAkB,eAA4D,IAA3CC,SAAS,KAAIC,QAAQ,eAAiB,GA9DzF,KA8CO,QAiBdP,GAAU,EACVC,GAAW,EAlBG,YAoBD,IAAZD,GAAqBC,EAAUH,EApBlB,wBAuBlBU,sBAAYJ,GACZL,EAAQ,MAGRF,EAAOhH,KAAP,MAAAgH,EAAM,YAASO,EAASd,QAAQmB,MAAM9E,KAAI,SAAC+E,GAAD,OAAyCA,EAAOhE,QAC1FqD,EAAQK,EAASd,QAAQqB,QAAQZ,OA5Bf,WA8BjBA,EA9BiB,iDAgCnBF,GAhCmB,0DAAH,sDA2CrBe,EAAoB,uCAAG,WACzBjB,EACAkB,EACAC,EACAC,GAJyB,+BAAA5D,EAAA,sDAMnB0C,EAAqB,GACrBC,EAAa,EACbkB,EAAsBH,EAAoBrE,OAEvCD,EAAI,EAVY,YAUTA,EAAIyE,GAVK,oBAWfC,EAAMJ,EAAoBtE,GAChCwE,EAAoBxE,EAAIyE,KAEpBC,KAAOH,GAdU,iBAejBjB,EAAOhH,KAAKiI,EAA4BG,IAfvB,wBAiBbb,OAjBa,EAkBbJ,GAAU,EACVC,EAAU,EAnBG,mCAsBQN,EAAGuB,wBAAwBD,GAtBnC,QAsBTb,EAtBS,2EAwBHpC,EAAa,KAAIqC,kBAAkB,eAA4D,IAA3CC,SAAS,KAAIC,QAAQ,eAAiB,GAjH7F,KAyFM,QAyBTP,GAAU,EACVC,GAAW,EA1BF,YA4BI,IAAZD,GAAqBC,EAAUH,EA5BvB,yBA8BbU,sBAAYJ,GACZP,EAAOhH,KAAK,KAGNsI,EAAqBf,EAASd,QAAQ3D,KAAI,SAACyF,GAAD,OAAgBA,EAAW1E,MAC3EoE,EAA4BG,GAAOE,EACnCtB,EAAOhH,KAAKsI,IApCC,QAUgB5E,IAVhB,gDAwClBsD,GAxCkB,2DAAH,4DAgDpBwB,EAAa,uCAAG,WAAO1B,GAAP,6BAAAxC,EAAA,sDAEdmE,EAAS,EACT1B,EAAQ,GACRC,EAAuC,GAGrCC,EAAa,EACfyB,EAAO,KARO,OAUVvB,GAAU,EACVC,EAAU,EAXA,iCAcWN,EAAG6B,iBAAiB,CAAE5B,MAAO,GAAI0B,OAAQA,IAdpD,QAcNlB,EAdM,0EAgBApC,EAAa,KAAIqC,kBAAkB,eAA4D,IAA3CC,SAAS,KAAIC,QAAQ,eAAiB,GAzJzF,KAyID,QAiBNP,GAAU,EACVC,GAAW,EAlBL,YAoBO,IAAZD,GAAqBC,EAAUH,EApB1B,wBAuBVU,sBAAYJ,GACZmB,EAAO,MAGPD,GAAU1B,EACVC,EAAOhH,KAAP,MAAAgH,EAAM,YAASO,EAASK,MAAM9E,KAAI,SAAC8F,GAAD,OAA2CA,EAASC,WACtFH,EAAOnB,EAASmB,MA7BN,WA+BTA,EA/BS,iDAiCX1B,GAjCW,0DAAH,sDAyCb8B,EAA8B,SAACC,GACjC,IAAMC,EACFD,EAAWjG,KAAI,SAACmG,GAAD,OAAqBA,EAAgBxC,WAC/CyC,QAAO,SAACC,EAAKC,GAAN,OAAkBD,EAAIE,OAAOD,KAAU,IAC9CtG,KAAI,SAACwG,GAAD,OAA4BA,EAAuBzF,MAChE,OAAO,YAAI,IAAI0F,IAAIP,KASVQ,EAAiB,uCAAG,WAAO1C,EAAmC2C,GAA1C,2BAAAnF,EAAA,sDAEvB0C,EAAwC,GACxCC,EAAa,EACfwB,EAAS,EACT1B,EAAQ,GALiB,OAQrBQ,OARqB,EASrBJ,GAAU,EACVC,EAAU,EAVW,iCAaAN,EAAG4C,WAAWD,EAAcE,MAAMlB,EAAQA,EAAS1B,IAbnD,QAajBQ,EAbiB,0EAeXpC,EAAa,KAAIqC,kBAAkB,eAA4D,IAA3CC,SAAS,KAAIC,QAAQ,eAAiB,GA/MzF,KAgMU,QAgBjBP,GAAU,EACVC,GAAW,EAjBM,YAmBJ,IAAZD,GAAqBC,EAAUH,EAnBf,4BAqBrBU,sBAAYJ,GArBS,uBAsBf,IAAIqC,MAAM,2BAtBK,QAwBrB5C,EAAOhH,KAAP,MAAAgH,EAAM,YAASO,EAASd,UACxBgC,GAAU1B,EAzBW,WA4BpB0B,EAASgB,EAAc9F,OA5BH,iDA8BtBqD,GA9BsB,0DAAH,wDAwCxB6C,EAAsC,SACxCC,EACAC,EACAC,EACAjB,GAEA,GAAIe,EAAYnG,SAAWoG,EAAoBpG,OAE3C,OADA2C,QAAQC,MAAM,+CACP,GAKX,IADA,IAAM0D,EAAuC,GACpCvG,EAAI,EAAGA,EAAIoG,EAAYnG,OAAQD,IAAK,CACzC,IAAMwG,EAASJ,EAAYpG,GACrByG,EAAcD,EAAOE,QAAUF,EAAOE,OAAOzG,OAAS,EAAIuG,EAAOE,OAAOF,EAAOE,OAAOzG,OAAS,GAAG0G,IAAM,GACxGC,EAAaN,EAAsBO,IAAIL,EAAOrG,IAE9C2G,EAAaN,EAAOM,WACpBC,EAAgBH,EAxPN,EAwPqC,EAErDL,EAAaC,EAAOrG,IAAM,CACtBa,OAAQwF,EAAOxF,OACfb,GAAIqG,EAAOrG,GACX6G,MAAOP,EACPG,WAAYA,EACZvB,WAAY,GACZtD,KAAMyE,EAAOzE,KACbkF,kBAAmBZ,EAAoBrG,GACvCc,MAhQmB,GAgQZgG,EAAsCC,GAKrD,IAAK,IAAI/G,EAAI,EAAGA,EAAIqF,EAAWpF,OAAQD,IAEnC,IADA,IAAMkH,EAAO7B,EAAWrF,GACfmH,EAAI,EAAGA,EAAID,EAAKnE,QAAQ9C,OAAQkH,IAAK,CAC1C,IAAMC,EAAaF,EAAKnE,QAAQoE,GAC5BC,EAAWjH,MAAMoG,GACjBA,EAAaa,EAAWjH,IAAIkF,WAAW/I,KAAK,CACxC2E,WAAYiG,EAAKnE,QAAQ3D,KAAI,SAAAiI,GAAW,OAAIA,EAAYlH,MACxD6C,YAAakE,EAAKjE,cAAcC,QAChCnB,KAAMmF,EAAKnF,KACX5B,GAAI+G,EAAK/G,GACT2C,YAAaoE,EAAKvE,cAOlC,IAAK,IAAIzC,KAAOqG,EAAc,CAC1B,IAAMe,EAAMf,EAAarG,GACzBqG,EAAarG,GAAKY,OAzRH,EAyRYwG,EAAIjC,WAAWpF,OAG9C,OAAOsG,GAGLgB,EACF,SAACC,GACG,IAAMC,EAAgD,GACtD,IAAK,IAAIvH,KAAOsH,EAAiB,CAC7B,IAAME,EAAUF,EAAgBtH,GAChCuH,EAAmBvH,GAAO,CACtBC,GAAIuH,EAAQvH,GACZ8G,kBAAmBS,EAAQT,kBAC3BjG,OAAQ0G,EAAQ1G,QAGxB,OAAOyG,GAeFE,EAAuB,uCAAG,WACnCC,EACAxE,EACAyE,EACAC,EACAC,GALmC,mDAAAnH,EAAA,yDAsB5BgH,EAtB4B,yCAX5B,CAAE7K,SAAU,GAAIC,aAAc,GAAIC,YAAa,GAAIC,eAAgB,GAAIC,WAAY,KAWvD,cAwBnCiG,EAAG4E,eAAeJ,GAxBiB,SA2BV9C,EAAc1B,GA3BJ,cA2B7BiC,EA3B6B,OA6BnCwC,EAA+B,4CAC/BjF,QAAQC,MAAM,gBAAiBwC,GAGzB4C,EAAuB7C,EAA4BC,GACzDzC,QAAQC,MAAM,4BAA6BoF,GAG3CJ,EAA+B,kDArCI,UAsCF1E,EAAsBC,GAtCpB,WAsC7B8E,EAtC6B,OAuCnCtF,QAAQC,MAAM,yBAA0BqF,GAGlCnC,EA1C6B,YA0CT,IAAIF,IAAIoC,EAAqBtC,OAAOuC,KAE9DtF,QAAQC,MAAM,oBAAqBkD,KAE/BA,EAAc9F,OAAS,GA9CQ,wBA+C/B8H,EAAqB,uDA/CU,kBAX5B,CAAEhL,SAAU,GAAIC,aAAc,GAAIC,YAAa,GAAIC,eAAgB,GAAIC,WAAY,KAWvD,eAoDnC0K,EAA+B,sEApDI,UAqDTlG,QAAQC,QAAQkE,EAAkB1C,EAAI2C,IArD7B,QA8DnC,GATMK,EArD6B,OAsDnCxD,QAAQC,MAAM,iBAAkBuD,GAG1B+B,EAA4B,iBAE5BC,EAA6BC,aAAaC,QAAQH,GAEpD5D,EAA8B,GACC,OAA/B6D,OAGC,CACD,IACI7D,EAA8BgE,KAAKC,MAAMJ,GAC3C,SACE7D,EAA8B,GAGE,OAAhCA,IACAA,EAA8B,IAzEH,OA8EnCsD,EAA+B,mHA9EI,UAgFDxD,EAAqBjB,EAAI2C,EAAexB,EAA6BuD,GAhFpE,WAgF7BzB,EAhF6B,OAiFnCgC,aAAaI,QAAQN,EAA2BI,KAAKG,UAAUnE,IAC/D3B,QAAQC,MAAM,wBAAyBwD,GAGjClJ,EAAagJ,EACfC,EACAC,EACA,IAAIR,IAAIqC,GACR7C,GAEJzC,QAAQC,MAAM,cAAe1F,GAEvBwL,EAAY7G,EAAU,aAE5B+F,EAA+B,0DAE3Be,EAA6DxM,yEAC7D6H,sBAAY2E,GAlGmB,0CAX5B,CAAE7L,SAAU,GAAIC,aAAc,GAAIC,YAAa,GAAIC,eAAgB,GAAIC,WAAY,KAWvD,eAoG/B0L,EAAmB,GApGY,oBAsGJC,MAAMF,EAAoB,CACjDG,OAAQ,OACRC,KAAMT,KAAKG,UAAUnB,EAAwBpK,IAC7C6G,QAAS,CACL,eAAgB,mBAChB,cAAe2E,KA3GQ,aAsGzBM,EAtGyB,QA+GdC,GA/Gc,kCAgHPD,EAAaE,OAhHN,QAgH3BN,EAhH2B,2CAkHjB3C,MAlHiB,KAkHX+C,EAAaG,OAAS,MAAQH,EAAaI,WAAa,MAlH7C,UAkH2DJ,EAAaK,OAlHxE,yHAqH/BvB,EAAqB,EAAD,IArHW,oBAyHnCnF,QAAQC,MAAMgG,GDvWeU,ECyWQV,EAAY5L,YAA3CA,EDxW0BsM,EAAiBnK,KAAI,SAACoK,GAAD,MAAW,CAAEC,IAAKD,EAAKC,IAAKC,IAAKF,EAAKE,IAAKC,OAAQH,EAAKG,WC0WvG5M,EAAW8C,EAAc1C,EAAY0L,EAAY9L,UDvXzB6M,ECyXSf,EAAY7L,aAA7CA,EDxXC4M,EAAkBxK,KAAI,SAAAsD,GAAO,MAAK,CAAE+G,IAAK/G,EAAQ+G,IAAKC,IAAKhH,EAAQgH,IAAKC,OAAQjH,EAAQiH,WC0XzFzM,EAAiBkE,EAAwByH,EAAY3L,gBAErD2M,EAAI,IAAIlI,SAAe,SAAAC,GAAO,OAAIA,EAAQ,CAC5C3E,YAAaA,EACbF,SAAUA,EACVC,aAAcA,EACdE,eAAgBA,EAChBC,WAAYA,OAxImB,KA4InCyF,QA5ImC,UA4IciH,EA5Id,gCA4I3BhH,MA5I2B,UA4IrB,4BA5IqB,wBA6I5BgH,GA7I4B,kCD1PN,IAACD,EAYDL,IC8OM,sBAAH,8D,eC1S7B,IAAMO,EAAeC,IAAO,CAC/BtJ,EAAGsJ,IACHrJ,EAAGqJ,MAIMC,EAAeD,IAAO,CAC/B9I,WAAY8I,IAAQA,KACpB/G,YAAa+G,IACb5J,GAAI4J,IACJhI,KAAMgI,IACNjH,YAAaiH,IAAQ,CAACA,IAAUA,QAUvBE,GANkBF,IAAO,CAClC5J,GAAI4J,IACJhI,KAAMgI,MAIoBA,IAAO,CACjC/I,OAAQ+I,IAAQA,KAChB5J,GAAI4J,IACJ/C,MAAO+C,IACPnD,WAAYmD,IACZ1E,WAAY0E,IAAQC,GACpBjI,KAAMgI,IACN9C,kBAAmB8C,IAAQA,KAC3BjJ,MAAOiJ,OAiBEG,IAboBH,IAAO,CACpC/I,OAAQ+I,IAAQA,KAChB5J,GAAI4J,IACJ9C,kBAAmB8C,IAAQA,OAIKA,IAAO,CACvC5J,GAAI4J,IACJhI,KAAMgI,MAIoBA,IAAO,CACjCN,IAAKM,IACLL,IAAKK,IACLJ,OAAQI,OAICI,GAAcJ,IAAO,CAC9B5J,GAAI4J,IACJ/I,OAAQ+I,IAAQA,KAChB9I,WAAY8I,IAAQA,KACpBzJ,iBAAkByJ,IAAaA,IAAUD,GACzC3I,QA/EJ,SACIiJ,GAOD,IANCrI,EAMF,iEANoBqI,EAAKrI,KAMzB,gBACE,OAAOgI,IAA+B,CAACK,EAAML,KAAchI,GAsElDsI,CAASN,OAITO,GAAkBP,IAAO,CAClCN,IAAKM,IACLL,IAAKK,IACLJ,OAAQI,MAQCQ,GAAYR,IAAO,CAC5BhN,SAAUgN,IAAQI,IAClBnN,aAAc+M,IAAQO,IACtBnN,WAAY4M,IAAaA,IAAUE,GACnChN,YAAa8M,IAAQG,IACrBhN,eAAgB6M,IAAQA,IAAaA,IAAUD,MCtEtCU,GAAkB,SAAChE,GAAD,MAAoD,CAC/E4D,KAAM,oBACNK,QAASjE,EACT3I,QAAS6M,aAAQ,SAAC9M,GACdA,EAAM+M,aAAenE,OAIhBoE,GAAmB,SAACC,GAAD,MAA+C,CAC3ET,KAAM,qBACNK,QAASI,EACThN,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMkN,cAAgBD,OA0BjBE,GAAW,SAACjO,GAAD,MAAyC,CAC7DsN,KAAM,YACNK,QAAS3N,EACTe,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMd,MAAQA,OAaTH,GAAe,iBAA4B,CACpDyN,KAAM,gBACNvM,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMjB,cAAe,OAIhBqO,GAAyB,SAACC,GAAD,MAA6C,CAC/Eb,KAAM,4BACNvM,QAAS6M,aAAQ,SAAC9M,GACdA,EAAML,oBAAsB0N,OAIvBC,GAA8B,SAACC,GAAD,MAAkD,CACzFf,KAAM,kCACNvM,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMwN,yBAA2BD,OAI5BrD,GAA0B,SAACuD,GAAD,MAA8C,CACjFjB,KAAM,4BACNvM,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMN,mCAAqC+N,OAYtCC,GAAsB,iBAA4B,CAC3DlB,KAAM,wBACNvM,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMjB,cAAe,EACrBiB,EAAMlB,aAAc,EACpBkB,EAAMnB,qBAAsB,OAIvB8O,GAAuB,SAACC,GAAD,MAA2C,CAC3EpB,KAAM,0BACNK,QAASe,EACT3N,QAAS6M,aAAQ,SAAC9M,GACdA,EAAM6N,kBAAoBD,OAIrBE,GAAyB,SAACC,GAAD,MAA+C,CACjFvB,KAAM,4BACNK,QAASkB,EACT9N,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMhB,oBAAsB+O,OAIvBC,GAAsB,SAACC,EAA8BlB,GAA/B,MAA8F,CAC7HP,KAAM,yBACNK,QAASoB,EACThO,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMkO,iBAAmBD,EACzBjO,EAAM+M,aAAeA,OAehBoB,GAAY,SAACvO,GAAD,MAA8C,CACnE4M,KAAM,aACNK,QAASjN,EACTK,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMJ,OAASA,OAuBVwO,GAA4B,SAACC,GAAD,MAA8D,CACnG7B,KAAM,+BACNK,QAASwB,EACTpO,QAAS6M,aAAQ,SAAC9M,GAId,IAHA,IAAMsO,EAA0BtO,EAAMF,uBAChCyO,EAAgBvO,EAAMd,MAAMK,WAEzB6C,EAAI,EAAGA,EAAIiM,EAAgBhM,OAAQD,IAAK,CAC7C,IAAM0C,EAAUuJ,EAAgBjM,GAC5B0C,EAAQvC,MAAMgM,IAIdD,EAAwBxJ,EAAQvC,IAAMuC,GAG9C9E,EAAMF,uBAAyBwO,OAiB1BE,GAAyB,SAClCzB,EACA/C,GAFkC,8CAGP,WAAOyE,GAAP,uBAAAzL,EAAA,0DACvBqD,sBAAY2D,IAAgC,OAAhBA,GAAwC,KAAhBA,EAD7B,uBAEvByE,EAASd,GAAqB,6DAFP,0BAM3Bc,EAAS7B,GAAgBG,IACzB0B,EAASX,IAAuB,KAC5BY,EAAI,IAAIjP,KACV2K,eAAeJ,GAEXvC,EAAyB,GACzBkH,EAA4B,GAC9BC,EAAqC,GAEnCC,EAAgB,SAACC,EAAcC,GACjC,OAAQD,EAAGvM,KAAOwM,EAAGxM,IAAMuM,EAAG3K,OAAS4K,EAAG5K,MAG9CuK,EAAEM,mBAAmBjC,EAAaxK,GAAI,MACjC0M,MAAK,SAAAC,GACF,IADgB,IAAD,WACN9M,GACL,IAtCa0C,EAAqCqK,EAsC5CC,GAtCOtK,EAsCkCoK,EAAUG,OAAOjN,GAtCd+M,EAsCkBpC,EAAaxK,GArC3DuC,EAAQK,QAAQyC,QAAO,SAAClC,EAA4B1C,GAElF,OADIA,EAAET,KAAO4M,GAAiBzJ,EAAOhH,KAAK,CAAE6D,GAAIS,EAAET,GAAI4B,KAAMnB,EAAEmB,OACvDuB,IACR,KAmCSkJ,EAAiBA,EAAe7G,OAAOqH,GACvC,IAAME,EAAczK,EAAiBqK,EAAUG,OAAOjN,IAChDmN,EAAexC,EAAatF,WAAW+H,WAAU,SAAAC,GAAS,OAAIZ,EAAcS,EAAaG,OAEzE,IAAlBF,EACAZ,EAAcjQ,KAAK4Q,IAGa,KAA5BA,EAAYpK,cACZoK,EAAYpK,YAAc6H,EAAatF,WAAW8H,GAAcrK,aAEpEuC,EAAW/I,KAAK4Q,KAbflN,EAAI,EAAGA,EAAI8M,EAAUG,OAAOhN,OAAQD,IAAM,EAA1CA,GAiBT,IAlBe,eAkBNA,GACL,IAAM0C,EAAUiI,EAAatF,WAAWrF,IAElB,IADDqF,EAAW+H,WAAU,SAAAC,GAAS,OAAIZ,EAAc/J,EAAS2K,OAE1EhI,EAAW/I,KAAKoG,IAJf1C,EAAI,EAAGA,EAAI2K,EAAatF,WAAWpF,OAAQD,IAAM,EAAjDA,GASTqM,EAASL,GAA0BQ,IACnCH,EAAST,GAAoB,CAAEvG,WAAYA,EAAYkH,cAAeA,GAAiB5B,OAE1F2C,OAAM,SAAC9B,GACJ5I,QAAQC,MAAM2I,GACda,EAASd,GAAqB,gEAAkEC,OAEnG+B,SAAQ,WACLlB,EAASX,IAAuB,OAvDb,4CAHO,uDAuFzB8B,GAAwB,SAACC,GAAD,MAAgD,CACjFrD,KAAM,4BACNK,QAASgD,EACT5P,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMH,sBAAwBgQ,OCxPhCC,GAA4B,SAC9BC,EACAC,EACAC,GAEA,IAAK,IAAI7N,EAAI,EAAGA,EAAI2N,EAAkB1N,OAAQD,IAAK,CAC/C,IAAMsB,EAASqM,EAAkB3N,GACjC,IAAK,IAAI8N,KAAaxM,EAAQ,CAC1B,IAAMyM,EAAkBzM,EAAOwM,GAEzBE,EAAOD,EAAgBtN,GAAKoN,EAAaI,MAAQJ,EAAaK,aAAe,IAC7EC,EAAOJ,EAAgBrN,EAAImN,EAAaO,OAC9CR,EAAeE,GAAa,CAAErN,EAAGuN,EAAMtN,EAAGyN,MAehDE,GAAmB,SACrBC,EACAC,EACAC,EACAC,EACAC,EACAd,GAE2B,IAAvBU,GAAmD,IAAvBA,GAAmD,IAAvBA,GAA4BE,EAAevO,OAGvG,IAAM0O,EAAqBH,EAAevO,OACpC2O,EAAqBJ,EAAe,GAAGvO,OAE7C4O,EACA,IAAK,IAAI7O,EAAI,EAAGA,EAAIuO,EAAkBtO,OAAQD,IAAK,CAC/C,IAAI8O,GAAkB,EAChBC,EAAmBR,EAAkBvO,GAE3CgP,EACA,IAAK,IAAIC,EAAM,EAAGA,EAAMT,EAAevO,OAAQgP,IAG3C,IAAK,IAAIC,EAAM,EAAGA,EAAMV,EAAeS,GAAKhP,OAAQiP,IAAO,CAEvD,IAAIC,EAAkC,GACX,IAAvBb,EACAa,EAAoB,CAChB,CAAC,CAACF,EAAKC,KAGiB,IAAvBZ,EACLa,EAAoB,CAChB,CAAC,CAACF,EAAKC,GAAM,CAACD,EAAKC,EAAM,IACzB,CAAC,CAACD,EAAKC,GAAM,CAACD,EAAM,EAAGC,KAGC,IAAvBZ,IACLa,EAAoB,CAChB,CAAC,CAACF,EAAKC,GAAM,CAACD,EAAKC,EAAM,GAAI,CAACD,EAAM,EAAGC,EAAM,IAC7C,CAAC,CAACD,EAAKC,GAAM,CAACD,EAAM,EAAGC,GAAM,CAACD,EAAM,EAAGC,EAAM,IAC7C,CAAC,CAACD,EAAKC,GAAM,CAACD,EAAKC,EAAM,GAAI,CAACD,EAAM,EAAGC,IACvC,CAAC,CAACD,EAAM,EAAGC,EAAM,GAAI,CAACD,EAAKC,EAAM,GAAI,CAACD,EAAM,EAAGC,MAIvD,IAAK,IAAIE,EAAa,EAAGA,EAAaD,EAAkBlP,OAAQmP,IAAc,CAC1E,IAAMC,EAAaF,EAAkBC,GAC/BE,EAAUD,EAAWE,OAAM,YAAuB,IAAD,mBAApBC,EAAoB,KAAZC,EAAY,KACnD,OAAOD,EAASb,GAAsBc,EAASb,GAAyD,IAAnCJ,EAAegB,GAAQC,MAE1FC,EAAaxQ,OAAOyQ,KAAKZ,GAC/B,GAAIO,EAAS,CAET,IAAK,IAAIM,EAAI,EAAGA,EAAItB,EAAoBsB,IAAK,CACzC,IAAMC,EAAOpB,EAA2BD,EAAea,EAAWO,GAAG,IAAIP,EAAWO,GAAG,IAAM,GAC7FhC,EAAe8B,EAAWE,IAAM,CAAEnP,EAAGoP,EAAKC,KAAMpP,EAAGmP,EAAKE,KACxDvB,EAAea,EAAWO,GAAG,IAAIP,EAAWO,GAAG,IAAM,EAGzDd,GAAkB,EAClB,MAAME,IAOtB,IAAKF,EAAiB,CAClB,IAAK,IAAIkB,EAAehQ,EAAGgQ,EAAezB,EAAkBtO,OAAQ+P,IAChEtB,EAAyBpS,KAAKiS,EAAkByB,IAEpD,MAAMnB,KAeZoB,GAA6B,SAC/BrC,EACAsC,EACAC,EACAC,EACAvC,EACAwC,GAIA,IAAIC,EAA0B,GAC9B,IAAK,IAAIpQ,KAAO0N,EAAgB,CAC5B,IAAI2C,EAAM3C,EAAe1N,GACzBoQ,EAAWhU,KAAK,CAAEwT,KAAMS,EAAI9P,EAAGsP,IAAKQ,EAAI7P,EAAGuN,MAAOJ,EAAaK,aAAcE,OAAQP,EAAa2C,gBANrG,MAQsDC,GACnD5C,EAAaI,MAAOoC,EAAexC,EAAaK,aAAe,GAAIL,EAAa2C,cAAgB,GAAIF,GADhG7B,EARP,EAQOA,2BAA4BD,EARnC,EAQmCA,eAG9BkC,EAAiD,GACjDC,EAA+C,GAC/CC,EAA+C,GAErDvC,GAAiB,EAAG+B,EAAwB5B,EAAgBC,EAA4BiC,EAA+B9C,GACvHS,GAAiB,EAAG8B,EAAsB3B,EAAgBC,EAA4BkC,EAA6B/C,GACnHS,GAAiB,EAAG6B,EAAsB1B,EAAgBC,EAA4BmC,EAA6BhD,GAWnH,IATA,IAAMiD,EAAwB,GAE1BC,EAAWT,EACXU,EAAW,EAGTC,EAAsC,GAA5BnD,EAAaK,aACvB+C,EAAuC,GAA7BpD,EAAa2C,cACvBU,EAA2C,GAA5BrD,EAAaK,aACzBlO,EAAI,EAAGA,EAAI0Q,EAA8BzQ,OAAQD,IAAK,CAoB3D,IAnBA,IAAM+O,EAAmB2B,EAA8B1Q,GACjD0P,EAAaxQ,OAAOyQ,KAAKZ,GACzBoC,EAAQC,KAAKC,SAEbC,EAAqB,CACvB,CACKJ,EAAiBE,KAAKG,IAAIJ,EAAQC,KAAKI,IAAOR,EAAUD,EACxDG,EAAiBE,KAAKK,IAAIN,EAAQC,KAAKI,IAAOP,EAAUH,GAE7D,CACII,EAAgBE,KAAKG,KAAKJ,EAAQ,EAAI,GAAKC,KAAKI,IAAOR,EAAUD,EACjEG,EAAgBE,KAAKK,KAAKN,EAAQ,EAAI,GAAKC,KAAKI,IAAOP,EAAUH,GAErE,CACII,EAAgBE,KAAKG,KAAKJ,EAAQ,EAAI,GAAKC,KAAKI,IAAOR,EAAUD,EACjEG,EAAgBE,KAAKK,KAAKN,EAAQ,EAAI,GAAKC,KAAKI,IAAOP,EAAUH,IAIhE3J,EAAI,EAAGA,EAAI,EAAGA,IACnByG,EAAe8B,EAAWvI,IAAM,CAAE1G,EAAG6Q,EAAOnK,GAAG,GAAIzG,EAAG4Q,EAAOnK,GAAG,IAChE0J,EAASvU,KAAK,CAAEwT,KAAMwB,EAAOnK,GAAG,GAAI4I,IAAKuB,EAAOnK,GAAG,GAAI8G,MAAOJ,EAAaK,aAAcE,OAAQP,EAAa2C,gBAGlH,IAAMkB,EAA8B,IAAfR,EAAqBrD,EAAaK,cACvD6C,GAAYW,GACGA,EAAe7D,EAAaI,QACvC8C,EAAW,EACXD,GAAYY,GAKpB,IAAK,IAAI1R,EAAI,EAAGA,EAAI2Q,EAA4B1Q,OAAQD,IAAK,CAQzD,IAPA,IAAM+O,EAAmB4B,EAA4B3Q,GAC/C0P,EAAaxQ,OAAOyQ,KAAKZ,GACzBuC,EAAqB,CACvB,CAACP,EAAUD,GACX,CAACC,EAA0B,EAAfG,EAAkBJ,IAGzB3J,EAAI,EAAGA,EAAI,EAAGA,IACnByG,EAAe8B,EAAWvI,IAAM,CAAE1G,EAAG6Q,EAAOnK,GAAG,GAAIzG,EAAG4Q,EAAOnK,GAAG,IAChE0J,EAASvU,KAAK,CAAEwT,KAAMwB,EAAOnK,GAAG,GAAI4I,IAAKuB,EAAOnK,GAAG,GAAI8G,MAAOJ,EAAaK,aAAcE,OAAQP,EAAa2C,iBAIlHO,GADoC,EAAfG,EAAmBrD,EAAaK,cAEtCL,EAAaI,MAAQJ,EAAaK,eAC7C6C,EAAW,EACXD,GAAYjD,EAAa2C,cAAgB,IAKjDM,EAAWT,EACX,IAAK,IAAIrQ,EAAI,EAAGA,EAAI4Q,EAA4B3Q,OAAQD,IAAK,CAKzD,IAJA,IAAM+O,EAAmB6B,EAA4B5Q,GAC/C8N,EAAY5O,OAAOyQ,KAAKZ,GAAkB,GAC1C4C,EAAyB,CAAE5B,IAAKe,EAAUhB,KAAMiB,EAAU9C,MAAOJ,EAAaK,aAAcE,OAAQP,EAAa2C,eAEhHoB,GAAcD,EAAad,IAC9Bc,EAAY7B,MAAQjC,EAAaK,aAE7ByD,EAAY7B,KAAOjC,EAAaK,aAAeL,EAAaI,QAC5D0D,EAAY7B,KAAO,EACnB6B,EAAY5B,KAAOlC,EAAa2C,cAAgB,IAGxD5C,EAAeE,GAAa,CAAErN,EAAGkR,EAAY7B,KAAMpP,EAAGiR,EAAY5B,KAClEgB,EAAWY,EAAY7B,KAAOjC,EAAaK,aAAe,GAC1D4C,EAAWa,EAAY5B,IACnBgB,EAAWlD,EAAaK,aAAeL,EAAaI,QACpD8C,EAAW,EACXD,GAAYjD,EAAa2C,iBAUxBqB,GAA6B,SACtCxQ,EAAiCmP,GAEjC,IAAIsB,EAAO,EACX,IAAK,IAAI5R,KAAOmB,EAAW,CACvB,IAAIkP,EAAMlP,EAAUnB,GACpB4R,EAAOvB,EAAI7P,EAAIoR,EAAOvB,EAAI7P,EAAIoR,EAElC,OAAOA,EAAOtB,GAWZuB,GAAa,SAACC,EAAgBC,EAAcC,EAAgBC,GAC9D,OAAOH,EAASG,GAAQD,EAASD,GAQ/BL,GAAgB,SAAC/B,EAAiBuC,GACpC,OAAOA,EAAM5M,QAAO,SAAC6M,EAAKC,GAAN,OAAYD,IANIE,EAMmB1C,EALhDkC,IADWS,EAMkCF,GAL5BxC,KAAM0C,EAAM1C,KAAO0C,EAAMvE,MAAOsE,EAAMzC,KAAMyC,EAAMzC,KAAOyC,EAAMtE,QAChF8D,GAAWS,EAAMzC,IAAKyC,EAAMzC,IAAMyC,EAAMpE,OAAQmE,EAAMxC,IAAKwC,EAAMxC,IAAMwC,EAAMnE,SAFnE,IAACoE,EAAkBD,KAM0B,IAG5D9B,GAA2B,SAC7BxC,EAAeG,EAAgBF,EAAsBuE,EAAuBL,GAE5E,IAAM5D,EAA6B,GAC/BkE,EAAgBtB,KAAKuB,MAAM1E,EAAQC,GACnC0E,EAAiBxB,KAAKuB,MAAMvE,EAASqE,GAEzCC,EAAkC,IAAlBA,EAAsB,EAAIA,EAC1CE,EAAoC,IAAnBA,EAAuB,EAAIA,EAI5C,IAFA,IAAMnE,EAA6B,GAC/BoE,EAAe,EACV7S,EAAI,EAAGA,EAAI4S,EAAgB5S,IAAK,CACrCwO,EAAexO,GAAK,GACpB,IAAK,IAAImH,EAAI,EAAGA,EAAIuL,EAAevL,IAAK,CACpC,IAAM0I,EAAkB,CAAEE,IAAK/P,EAAIyS,EAAe3C,KAAM3I,EAAI+G,EAAcD,MAAOC,EAAcE,OAAQqE,GACnGb,GAAc/B,EAAMuC,GACpB5D,EAAexO,GAAGmH,GAAK,GAGvB0L,GAAgB,EAChBrE,EAAexO,GAAGmH,GAAK0L,EACvBpE,EAA2BnS,KAAKuT,KAK5C,MAAO,CAAEpB,2BAA4BA,EAA4BD,eAAgBA,I,uDClWxEsE,GAAyB,SAACC,EAAYC,EAAYC,EAAYC,EAAYC,GAGnF,IAAIpD,EAAaD,EAAcsD,EAAaC,EAExCN,EAAKE,GACLnD,EAAOmD,EACPG,EAAML,EAAKE,IAGXnD,EAAOiD,EACPK,EAAMH,EAAKF,GAGXC,EAAKE,GACLnD,EAAMmD,EACNG,EAAML,EAAKE,IAGXnD,EAAMiD,EACNK,EAAMH,EAAKF,GAGf,IACIM,EAAQD,EAERE,EAAQ,EAAIJ,EAOhB,OANKH,EAAKE,GAAMH,EAAKE,GAChBD,EAAKE,GAAMH,EAAKE,KACjBK,EAAQ,EAAIH,EACZI,EAAQF,GAGL,CAAEG,MAVG,EAAIL,EAUAG,QAAOG,MARXL,EAQkBG,QAAOxD,MAAKD,OAAMuD,MAAKD,QCvBpCM,G,uKAEb,IAAMP,EAAgC,EAApBzT,KAAK3B,MAAM4V,OADxB,EAEuDb,GACxDpT,KAAK3B,MAAMgV,GAAIrT,KAAK3B,MAAMiV,GAAItT,KAAK3B,MAAMkV,GAAIvT,KAAK3B,MAAMmV,GAAIC,GADxDK,EAFH,EAEGA,MAAOF,EAFV,EAEUA,MAAOG,EAFjB,EAEiBA,MAAOF,EAFxB,EAEwBA,MAAOxD,EAF/B,EAE+BA,IAAKD,EAFpC,EAEoCA,KAAMuD,EAF1C,EAE0CA,IAAKD,EAF/C,EAE+CA,IAG9CQ,EAA0B,CAC5B7D,IAAKA,EAAM,GACXD,KAAMA,EAAOpQ,KAAK3B,MAAM8V,YAAc,GAIpCC,EAAS,cAAU,EAAV,KAAgB,IAAhB,KAAwB,IAAxB,KAAgCpU,KAAK3B,MAAM4V,OAASjU,KAAK3B,MAAMgW,kBAA/D,KAEf,OACI,yBAAKC,MAAOJ,EAAI5V,UAAU,oBAAoBiQ,MAAOmF,EAAMD,EAJ7C,GAIoE/E,OAAQiF,EAAMF,EAJlF,IAKV,0BACIc,EAAC,YAAOT,EAAP,YAAgBF,EAAhB,wCACOE,EAPF,GAML,YAC4BF,EAPvB,GAML,YACiDG,EAP5C,GAML,YACsEF,EAPjE,GAML,YAC2FE,EAD3F,YACoGF,GACrGW,YAAaf,EACbgB,KAAK,OACLC,OAAQN,S,GArBYzV,IAAMC,WCV/B+V,GATA,CACXC,eAAe,qBACfC,cAAc,mBACdC,KAAK,oBACLC,MAAM,iBACNC,KAAK,qBACLC,OAAO,mBCmCLC,I,8DACF,WAAY7W,GAAyB,IAAD,8BAChC,cAAMA,IACDH,MAAQ,CACTiX,iBAAkB9W,EAAM+W,UACxBC,iBAAkBhX,EAAMiX,UACxBC,UAAU,GAEd,EAAKC,OAAS,EAAKA,OAAOC,KAAZ,gBACd,EAAKC,OAAS,EAAKA,OAAOD,KAAZ,gBARkB,E,mDAW7BE,EAAmBC,GACtBD,EAAEE,kBAAmBF,EAAEG,iBACvB9V,KAAK+V,SAAS,CAAER,UAAU,IAC1B,IAAMS,EAAWhW,KAAK9B,MAAMiX,iBAAmBS,EAAGK,OAC5CC,EAAWlW,KAAK9B,MAAMmX,iBAAmBO,EAAGO,OAClDnW,KAAK+V,SAAS,CAAEZ,iBAAkBa,EAAUX,iBAAkBa,IAC9DlW,KAAK3B,MAAM+X,wBAAwBJ,EAAUE,EAAUlW,KAAK3B,MAAMyI,OAAOrG,M,6BAGtEkV,GACHA,EAAEE,kBAAmBF,EAAEG,iBACvB,IAAMP,EAAWvV,KAAK9B,MAAMqX,SAC5BvV,KAAK+V,SAAS,CAAER,UAAU,IACrBA,GACDvV,KAAKqW,gB,oCAKT,GAAIrW,KAAK3B,MAAM6J,YAAa,CACxB,GAAIlI,KAAK3B,MAAM4M,cAAgBjL,KAAK3B,MAAM4M,aAAaxK,KAAOT,KAAK3B,MAAMyI,OAAOrG,GAC5E,OAGAT,KAAK3B,MAAMiY,2BAA2BtW,KAAK3B,MAAMyI,OAAQ9G,KAAK3B,MAAM6J,gB,+BAM5E,IAAIqO,EAAQ5B,GAAOC,eACf5U,KAAK3B,MAAM4M,eACPjL,KAAK3B,MAAM4M,aAAaxK,KAAOT,KAAK3B,MAAMyI,OAAOrG,KACjD8V,EAAQ5B,GAAOG,MAEb9U,KAAK3B,MAAM4M,aAAaxK,MAAMT,KAAK3B,MAAMZ,aACsC,IAA7EuC,KAAK3B,MAAM4M,aAAa1D,kBAAkBiP,QAAQxW,KAAK3B,MAAMyI,OAAOrG,MACpE8V,EAAQ5B,GAAOM,SAM3B,IAGMwB,EAAsC,CACxCC,gBAAgB,OAAD,OAAS1W,KAAK3B,MAAMyI,OAAOQ,MAA3B,KACfqP,eAAe,GAAD,OAJC,GAID,cALA,GAKA,MACdpI,MAAM,GAAD,OANS,GAMT,MACLG,OAAO,GAAD,OANS,GAMT,MACNkI,aAAc,OACdC,UAAW,UAGf,OAAI7W,KAAK3B,MAAMyI,OAAO1F,MAAQpB,KAAK3B,MAAMyY,aAC9B,8BAIP,kBAAC,KAAD,CACItW,IAAKR,KAAK3B,MAAMyI,OAAOrG,GACvBsW,OAAO,SACPC,gBAAiB,CAAEjW,EAAGf,KAAK3B,MAAM+W,UAAWpU,EAAGhB,KAAK3B,MAAMiX,WAC1DE,OAAQxV,KAAKwV,OACbE,OAAQ1V,KAAK0V,QAEb,yBAAKpX,UAAU,6BACX,yBAAKgW,MAAK,6BAAOmC,GAAP,IAA4BQ,gBAAiBtC,GAAOC,kBAC1D,yBAAKN,MAAOmC,KAEhB,yBAAKnY,UAAU,8BAA8BgW,MAAO,CAAE2C,gBAAiBV,IAClEvW,KAAK3B,MAAMyI,OAAOzE,Y,GApFlB1D,IAAMC,YA4FhBE,gBACX,SAACZ,GAAD,MAAmB,CACfgK,YAAahK,EAAMgK,YACnB+C,aAAc/M,EAAM+M,aACpBxN,WAAYS,EAAMd,MAAMK,eAE5B,SAACkP,GAAD,MAAoB,CAChB2J,2BAA4B,SAACrL,EAA0B/C,GAA3B,OAAmDyE,EAASD,GAAuBzB,EAAc/C,QAPtHpJ,CASboW,IC1FIgC,I,wDAIF,WAAY7Y,GAAiC,IAAD,uBACxC,cAAMA,IAJV8Y,YAG4C,IAF5CC,gBAE4C,EAExC,IAFwC,EAG4B,EAAKC,gBADpD,KACbC,EAHgC,EAGhCA,oBAAqBC,EAHW,EAGXA,kBAAmBC,EAHR,EAGQA,gBAHR,OAIxC,EAAKtZ,MAAQ,CACTqQ,MAAO,EAAGG,OAAQ,EAClB+I,MAAO,GAAI7W,iBAAkB,GAC7B8W,kBAAmBJ,EAAoBK,QACvCC,iBAAkBJ,EAClBF,oBAAqBA,EACrBC,kBAAmBA,EACnBM,kBAAkB,EAClBC,kBAAmB,GACnBC,aAXiB,KAarB,EAAKX,WAAazY,IAAMqZ,YACxB,EAAKb,OAASxY,IAAMqZ,YAEpB,EAAKC,uBAAyB,EAAKA,uBAAuBxC,KAA5B,gBAC9B,EAAKyC,wBAA0B,EAAKA,wBAAwBzC,KAA7B,gBAC/B,EAAK0C,sBAAwB,EAAKA,sBAAsB1C,KAA3B,gBApBW,E,+DA4BzB2C,EAAoCC,GAC/CD,EAAUE,gBAAkBtY,KAAK3B,MAAMia,cACvCtY,KAAKuY,8BAEAF,EAAUX,oBAAsB1X,KAAK9B,MAAMwZ,mBAChD1X,KAAKwY,6B,0CAQTxY,KAAKuY,gC,oDAMsB,IAAD,EAC0CvY,KAAKqX,gBAAgBrX,KAAK9B,MAAM6Z,cAA5FT,EADkB,EAClBA,oBAAqBC,EADH,EACGA,kBAAmBC,EADtB,EACsBA,gBAChDxX,KAAK+V,SAAS,CACVuB,oBAAqBA,EACrBC,kBAAmBA,EACnBG,kBAAmBJ,EAAoBK,QACvCC,iBAAkBJ,IAEtB,IAAIjJ,EAAQvO,KAAKmX,OAAOsB,QAAQC,YAC5BhK,EAAS1O,KAAKmX,OAAOsB,QAAQE,aACjC3Y,KAAK+V,SAAS,CAAExH,MAAOA,EAAOG,OAAQA,IACtC,IAAMkK,EAAwD5Y,KAAK6Y,YAAYtK,EAAOG,GACtF1O,KAAK+V,SAAS,CAAE0B,MAAOmB,EAAanB,MAAO7W,iBAAkBgY,EAAajX,c,iDAQ1E,IADA,IAAM8V,EAAQ,GACLnX,EAAI,EAAGA,EAAIN,KAAK3B,MAAMia,cAAcb,MAAMlX,OAAQD,IAAK,CAC5D,IAAMwY,EAAO9Y,KAAK3B,MAAMia,cAAcb,MAAMnX,GAC5CmX,EAAM7a,KACF,kBAAC,GAAD,CACI4D,IAAKsY,EAAKhS,OAAOrG,GACjB2V,wBAAyBpW,KAAKiY,uBAC9B7C,UAAWpV,KAAK9B,MAAM0C,iBAAiBkY,EAAKhS,OAAOrG,IAAIM,EACvDuU,UAAWtV,KAAK9B,MAAM0C,iBAAiBkY,EAAKhS,OAAOrG,IAAIO,EACvD8F,OAAQgS,EAAKhS,OACbgQ,aAAc9W,KAAK9B,MAAMwZ,qBAIrC1X,KAAK+V,SAAS,CAAE0B,MAAOA,M,kCAWf/D,EAAaC,GAOrB,IANA,IAIM8D,EAAuB,GACzBsB,EAAkE,GAC7DzY,EAAI,EAAGA,EAAIN,KAAK3B,MAAMia,cAAcb,MAAMlX,OAAQD,IAAK,CAC5D,IAAMwY,EAAO9Y,KAAK3B,MAAMia,cAAcb,MAAMnX,GACtC0Y,EAAQF,EAAKG,SAASlY,GAAK2S,EARnB,IAQqC,IANjC,GAOZwF,EAAQJ,EAAKG,SAASjY,GAAK2S,EARlB,IAQqC,IAPlC,GAQlBoF,EAAoBD,EAAKhS,OAAOrG,IAAM,CAAEM,EAAGiY,EAAOhY,EAAGkY,GAErDzB,EAAM7a,KACF,kBAAC,GAAD,CACI4D,IAAKsY,EAAKhS,OAAOrG,GACjB2V,wBAAyBpW,KAAKiY,uBAC9B7C,UAAW4D,EACX1D,UAAW4D,EACXpS,OAAQgS,EAAKhS,OACbgQ,aAAc9W,KAAK9B,MAAMwZ,qBAIrC,MAAO,CAAED,QAAO9V,UAAWoX,K,sCAQfhB,GASZ,IAJA,IAAIT,EAAoC,CAAEK,QAAS,IAAMwB,SAAU,KAC/D5B,EAAkC,CAAEI,QAAS,IAAMwB,SAAU,KAGxD7Y,EAAI,EAAGA,EAAIN,KAAK3B,MAAMia,cAAcb,MAAMlX,OAAQD,IAAK,CAC5D,IACM8Y,EADOpZ,KAAK3B,MAAMia,cAAcb,MAAMnX,GACnBwG,OAAO1F,MAChCkW,EAAoB6B,QAAUC,EAAc9B,EAAoB6B,QAAUC,EAAc9B,EAAoB6B,QAC5G7B,EAAoBK,QAAUyB,EAAc9B,EAAoBK,QAAUyB,EAAc9B,EAAoBK,QAGhH,IAAM0B,EAAwBrZ,KAAK3B,MAAMia,cAAcgB,MAAM5Z,KAAI,SAAA6Z,GAAE,OAAIA,EAAGtF,UAAQhT,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAIC,KACrGoW,EAAkBI,QAAU0B,EAAY,GACxC9B,EAAkB4B,QAAUE,EAAYA,EAAY9Y,OAAS,GAE7D+W,EAAoB6B,QAAUzH,KAAK8H,KAAKlC,EAAoB6B,SAC5D7B,EAAoBK,QAAUjG,KAAK8H,KAAKlC,EAAoBK,SAAW,EACvEJ,EAAkB4B,QAAUzH,KAAK8H,KAAKjC,EAAkB4B,SACxD5B,EAAkBI,QAAUjG,KAAK8H,KAAKjC,EAAkBI,SAAW,EAEnE,IAAM8B,EAAIJ,EAAY9Y,OAGtB,MAAO,CACH+W,oBAAqBA,EACrBC,kBAAmBA,EACnBC,gBALoBiC,EAAI1B,EAAesB,EAAYI,EAAI1B,GAAgB,GAAMR,EAAkBI,W,6CAehF5W,EAAWC,EAAW0Y,GACzC,GAAmC,MAA/B1Z,KAAK9B,MAAM0C,iBACX,MAAO,GAEX,IAAMiQ,EAAM7Q,KAAK9B,MAAM0C,iBACvBiQ,EAAI6I,GAAa,CAAE3Y,EAAGA,EAAGC,EAAGA,GAC5BhB,KAAK+V,SAAS,CAAEnV,iBAAkBiQ,M,oCAOlC,IAAMyI,EAAQ,GACd,GAAmC,MAA/BtZ,KAAK9B,MAAM0C,iBACX,MAAO,GAGX,IACI,IAAK,IAAIN,EAAI,EAAGA,EAAIN,KAAK3B,MAAMia,cAAcgB,MAAM/Y,OAAQD,IAAK,CAC5D,IAAMwJ,EAAO9J,KAAK3B,MAAMia,cAAcgB,MAAMhZ,GACtCqZ,EAAU7P,EAAKC,IACf6P,EAAU9P,EAAKE,IACf6P,EAAa/P,EAAKmK,OAClB6F,EAAiBH,EAAUC,EAE3BG,EAAQ/Z,KAAK3B,MAAM2b,aAAaL,GAChCM,EAAQja,KAAK3B,MAAM2b,aAAaJ,GAElCG,IAAUE,GAASJ,EAAa7Z,KAAK9B,MAAM0Z,kBAC3CiC,EAAa7Z,KAAK9B,MAAM4Z,mBACxBiC,EAAM3Y,OAASpB,KAAK9B,MAAMwZ,mBAC1BuC,EAAM7Y,OAASpB,KAAK9B,MAAMwZ,mBAE1B4B,EAAM1c,KACF,kBAAC,GAAD,CACI4D,IAAKsZ,EACLzG,GAAIrT,KAAK9B,MAAM0C,iBAAiB+Y,GAAS5Y,EACzCuS,GAAItT,KAAK9B,MAAM0C,iBAAiB+Y,GAAS3Y,EACzCuS,GAAIvT,KAAK9B,MAAM0C,iBAAiBgZ,GAAS7Y,EACzCyS,GAAIxT,KAAK9B,MAAM0C,iBAAiBgZ,GAAS5Y,EACzCiT,OAAQnK,EAAKmK,OACbE,YAAa,GACbE,kBAAmBrU,KAAK9B,MAAMqZ,kBAAkB4B,YAMpE,MAAOe,GACHZ,EAAM1c,KAAK,+BAGf,OAAO0c,I,8CAGa3D,GACpB3V,KAAK+V,SAAS,CAAE2B,kBAAmB/B,EAAEwE,cAAcC,kB,2CAInD,IAAMzC,EAAU3X,KAAK9B,MAAMoZ,oBAAoBK,QACzCwB,EAAUnZ,KAAK9B,MAAMoZ,oBAAoB6B,QAC/C,OAAO,yBAAK7a,UAAU,wBAClB,2BACIoM,KAAK,QACL2P,IAAK1C,EACL2C,IAAKnB,EACLoB,MAAOpB,EAAUxB,GAAW,GAC5B6C,MAAOxa,KAAK9B,MAAMwZ,kBAClB+C,SAAUza,KAAKkY,wBACf5Z,UAAU,oB,4CAKAqX,GAClB3V,KAAK+V,SAAS,CAAE6B,iBAAkBjC,EAAEwE,cAAcC,kB,yCAIlD,IAAMzC,EAAUjG,KAAK4I,IAAIta,KAAK9B,MAAMqZ,kBAAkBI,QAAS3X,KAAK9B,MAAM4Z,mBACpEqB,EAAUnZ,KAAK9B,MAAMqZ,kBAAkB4B,QAC7C,OAAO,yBAAK7a,UAAU,wBAClB,2BACIoM,KAAK,QACL2P,IAAK1C,EACL2C,IAAKnB,EACLoB,MAAOpB,EAAUxB,GAAW,GAC5B6C,MAAOxa,KAAK9B,MAAM0Z,iBAClB6C,SAAUza,KAAKmY,sBACf7Z,UAAU,oB,oCAMlB0B,KAAK+V,SAAS,CAAE8B,kBAAmB7X,KAAK9B,MAAM2Z,qB,2CAG5B,IAAD,OACX6C,EAAuB1a,KAAK9B,MAAM2Z,iBAAmB,GAAK,CAAE8C,QAAS,QAC3E,OACI,kBAAC,KAAD,CAAWC,OAAO,SAAS7D,OAAO,UAC9B,yBAAKzY,UAAU,wBACX,6BACI,yBAAKA,UAAU,wBACV0B,KAAK6a,mBADV,SAIA,yBAAKvc,UAAU,wBACV0B,KAAK8a,qBADV,YAKJ,kBAAC,KAAD,CAAYC,aAAc,kBAAM,EAAKC,eAAeC,aAAc,kBAAM,EAAKD,eAAeE,KAAM,KAClG,gCAAQ,kBAAC,KAAD,CAAaA,KAAM,MAC3B,yBAAK5c,UAAU,qBAAqBgW,MAAOoG,GACvC,oGACA,wJACA,4JACA,sK,+BAQhB,OACI,yBAAKpc,UAAU,kCAAkC6c,IAAKnb,KAAKoX,YACvD,yBAAK9Y,UAAU,mBAAmB6c,IAAKnb,KAAKmX,OAAQ7C,MAAO,CAAE/F,MAAOvO,KAAK9B,MAAMqQ,QAC1EvO,KAAKob,qBACgB,IAArBpb,KAAK9B,MAAMqQ,OAA2C,IAA5BvO,KAAK9B,MAAMuZ,MAAMlX,QAAgBP,KAAKqb,cAC3C,IAArBrb,KAAK9B,MAAMqQ,OAAevO,KAAK9B,MAAMuZ,Y,GA9SzB9Y,IAAMC,YAqTxBE,gBACX,SAACZ,GAAD,MAAmB,CACf8b,aAAc9b,EAAMd,MAAMK,cAE9B,GAJWqB,CAKboY,I,2BClUIoE,I,wDAEF,WAAYjd,GAAa,IAAD,6BACpB,cAAMA,IACyBkd,eAAxBC,EAFa,EAEbA,MAAOC,EAFM,EAENA,SAFM,OAGpB,EAAKvd,MAAQ,CAACwd,aAAc,GAAI/V,WAAW6V,EAAO3O,cAAe4O,GAH7C,E,0DAMVE,GACNA,IAAW3b,KAAK9B,MAAMwd,aACtB1b,KAAK+V,SAAS,CAAC2F,aAAc,KAG7B1b,KAAK+V,SAAS,CAAC2F,aAAcC,M,yCAIlBC,EAAiCC,GAC7CD,EAAUxP,mBAAqBpM,KAAK3B,MAAM+N,kBAAoBpM,KAAK3B,MAAM+N,kBACxEpM,KAAK+V,SAAS,CACV2F,aAAc,GACd/V,WAAW3F,KAAK3B,MAAM+N,iBAAiBzG,WACvCkH,cAAe7M,KAAK3B,MAAM+N,iBAAiBS,kB,qCAMnD,IAAM7M,KAAK3B,MAAM+N,kBAAoB7H,sBAAYvE,KAAK3B,MAAM4M,cACxD,MAAO,CAACuQ,MAAM,GAAGC,SAAS,IAM9B,IAHA,IAAM9V,EAAwB,GACxBkH,EAA2B,GAExBvM,EAAI,EAAGA,EAAIN,KAAK3B,MAAM+N,iBAAiBzG,WAAWpF,OAAQD,IAAK,CACpE,IAAM0C,EAAUhD,KAAK3B,MAAM+N,iBAAiBzG,WAAWrF,GACnDN,KAAK3B,MAAM4M,aAAatF,aAAiBA,EAAWmW,SAAS9Y,GAC7D2C,EAAW/I,KAAKoG,GAEV6J,EAAciP,SAAS9Y,IAC7B6J,EAAcjQ,KAAKoG,GAM3B,OAHAE,QAAQC,MAAM,SAAUwC,GACxBzC,QAAQC,MAAM,kBAAmBnD,KAAK3B,MAAM4M,aAAatF,YACzDzC,QAAQC,MAAM,aAAc0J,GACrB,CAAC2O,MAAO7V,EAAY8V,SAAU5O,K,iCAG9BrF,EAAgBgU,GAA8B,IAAD,OAC9ClH,EAAQtU,KAAK9B,MAAMwd,eAAiBlU,EAAK/G,GAAK,CAACsb,UAAW,IAAM,CAACA,UAAW,GAE9EC,EAAa,kBAAC,KAAD,CAAqBd,KAAM,GAAI3c,QAAS,SAACoX,GACtDA,EAAEE,kBACF,EAAKxX,MAAM4d,cAAczU,MAGzB0U,EAA2BvH,GAAOC,eAClC5U,KAAK3B,MAAM8d,YAAcnc,KAAK3B,MAAM8d,WAAW1b,KAAO+G,EAAK/G,KAC3Dyb,EAA2BvH,GAAOG,KAE9BkH,EADAhc,KAAK3B,MAAMP,OACE,kBAAC,KAAD,CAAqBod,KAAM,GAAI3c,QAAS,SAACoX,GAAOA,EAAEE,kBAAmB,EAAKxX,MAAM+d,UAAS,MAGzF,kBAAC,KAAD,CAAsBlB,KAAM,GAAI3c,QAAS,SAACoX,GAAOA,EAAEE,kBAAmB,EAAKxX,MAAM+d,UAAS,OAI/G,IAAIC,EAA0B1H,GAAOC,eAUrC,OATI4G,IACAa,EAA0B1H,GAAOI,QAGZ,KAArBvN,EAAKpE,aAA2C,OAArBoE,EAAKpE,aAAwBmB,sBAAYiD,EAAKpE,gBACzE4Y,EAAa,kBAAC,KAAD,CAAgBd,KAAM,GAAI3c,QAAS,SAACoX,GAAOA,EAAEE,kBAAmByG,MAAM,kCACnFJ,EAA2BvH,GAAOK,MAIlC,yBAAKxU,IAAKgH,EAAK/G,GAAInC,UAAU,uBAAuBgW,MAAO,CAAC2C,gBAAiBiF,IACzE,yBAAK5d,UAAU,eAAegW,MAAO,CAAC2C,gBAAiBoF,GAA0B9d,QAAS,kBAAM,EAAKge,cAAc/U,EAAK/G,MACpH,yBAAKnC,UAAU,UACXgW,MAAO,CAACkI,YAAY,MAAO7B,QAAQ,cAAe8B,cAAc,SAAUC,eAAe,SAAUC,aAAa,WAE/GX,GAEL,yBAAK1d,UAAU,gBACVkJ,EAAKnF,OAGd,yBAAK/D,UAAU,mBAAmBgW,MAAOA,GACrC,yBAAKhW,UAAU,qBAAqBC,QAAS,WAAOsB,OAAO+c,KAAKpV,EAAKlE,eACjE,kBAAC,KAAD,MADJ,cAIKkY,GAAS,yBAAKld,UAAU,qBAAqBC,QAAS,WACvD,EAAKF,MAAMwe,iBAAiBC,mBAAmB,CAACtV,EAAK/G,KACpD0M,MAAK,WACFjK,QAAQC,MAAM,eACd,IAAI4Z,EAAgB,EAAK7e,MAAMyH,WAC/BoX,EAAgBA,EAAc9W,OAAOuB,GACrC,IAAIwV,EAAmB,EAAK9e,MAAM2O,cAAcjK,QAAO,SAAAgK,GAAC,OAAIA,EAAEnM,KAAO+G,EAAK/G,MAE1E,EAAKsV,SAAS,CAACpQ,WAAYoX,EAAelQ,cAAemQ,OAE5DpP,OAAM,SAAC9B,GACJ5I,QAAQC,MAAM,0CAA2C2I,QAG7D,kBAAC,KAAD,MAdU,2B,mCAuBjBmR,EAAmBzB,GAC5B,IAAOyB,EAAO,MAAO,GAGrB,IADA,IAAMC,EAA0B,GACvB5c,EAAI,EAAGA,EAAI2c,EAAM1c,OAAQD,IAC9B4c,EAAStgB,KACLoD,KAAKmd,WAAWF,EAAM3c,GAAIkb,IAGlC,OAAO0B,I,+BAKP,OAAIld,KAAK3B,MAAM0N,kBAEP,yBAAKzN,UAAU,qBACX,4BAAI,2BAAI0B,KAAK3B,MAAM0N,qBAItBxH,sBAAYvE,KAAK3B,MAAM4M,eAAiB1G,sBAAYvE,KAAK3B,MAAM+N,kBAEhE,yBAAK9N,UAAU,qBACX,kDAIH0B,KAAK3B,MAAMnB,oBAEZ,yBAAKoB,UAAU,qBACX,2CAMJ,yBAAKA,UAAU,qBACX,yBAAKA,UAAU,yBACX,wBAAIgW,MAAO,CAAC8I,OAAO,IACdpd,KAAK3B,MAAM4M,aAAa5I,MAE7B,yBAAKiS,MAAO,CACRoC,gBAAgB,OAAD,OAAQ1W,KAAK3B,MAAM4M,aAAa3D,MAAhC,KACfiH,MAAO,GAAIG,OAAQ,GAAIkI,aAAa,GAAD,OAAK,GAAL,KACnCD,eAAe,YACfgE,QAAS,iBAGT3a,KAAK3B,MAAM4M,aAAa/D,YACxB,wBAAIoN,MAAO,CAAE8I,OAAO,oBAApB,mCAGR,yBAAK9e,UAAU,4BACV0B,KAAKqd,aAAard,KAAK9B,MAAMyH,YAAY,GACzC3F,KAAKqd,aAAard,KAAK9B,MAAM2O,eAAe,S,GA9KvClO,IAAMC,YAsLrBE,gBACX,SAACZ,GAAD,MAAmB,CACfie,WAAYje,EAAMie,WAClBlR,aAAc/M,EAAM+M,aACpB/N,oBAAqBgB,EAAMhB,oBAC3B6O,kBAAmB7N,EAAM6N,kBACzBK,iBAAkBlO,EAAMkO,iBACxByQ,iBAAkB3e,EAAMR,oBACxBI,OAAQI,EAAMJ,WAElB,SAAC6O,GAAD,MAAyB,CACrByP,SAAU,SAACte,GAAD,OAAoB6O,EAASN,GAAUvO,KACjDme,cAAe,SAACzU,GAAD,OAAoBmF,EPlFd,SAACnF,GAAD,MAA8C,CACvEkD,KAAM,mBACNK,QAASvD,EACTrJ,QAAS6M,aAAQ,SAAC9M,GACPA,EAAMie,YAAcje,EAAMie,WAAW1b,KAAO+G,EAAK/G,KACpDvC,EAAMie,WAAa3U,EACnBtJ,EAAMJ,QAAS,OO4EyBme,CAAczU,QAZnD1I,CAcbwc,ICtMIgC,I,wDACF,WAAYjf,GAAkC,IAAD,8BACzC,cAAMA,IACDH,MAAQ,CACTqf,mBAAmB,EACnBC,mBAAoB,IAExB,EAAKC,wBANoC,E,oEASpB,IAAD,OACdC,EAAU1d,KAAK2d,WAAW3d,KAAK3B,MAAMuf,kBAAkBle,KAAI,SAAAe,GAAE,OAAI,EAAKpC,MAAMZ,WAAWgD,OAC7FyC,QAAQC,MAAM,UAAWua,GACzB,IAAMG,EAAS7d,KAAK8d,UAAUJ,GAE9B,GAAsB,IAAlBG,EAAOtd,OAAc,OAAO,8BAEhC,IAAMwd,EAAsB3X,EAAkBpG,KAAK3B,MAAMqF,GAAIma,GAC7D5b,QAAQC,QAAQ6b,GAAqB5Q,MAAK,SAACvJ,GAGvC,IAFA,IAAMoa,EAA6B,GAE1B1d,EAAI,EAAGA,EAAIsD,EAAOrD,OAAQD,IAAK,CACpC,IAAMkB,EAAQoC,EAAOtD,GACfyG,EAAcvF,EAAMwF,QAAUxF,EAAMwF,OAAOzG,OAAS,EAAIiB,EAAMwF,OAAOxF,EAAMwF,OAAOzG,OAAS,GAAG0G,IAAM,GAC1G+W,EAAaphB,KAAK,CACd0E,OAAQE,EAAMF,OACdb,GAAIe,EAAMf,GACV4B,KAAMb,EAAMa,KACZkF,kBAAmBmW,EAAQlc,EAAMf,IAAIwd,QACrC3W,MAAOP,EACPG,YAAY,EACZvB,WAAY,GACZvE,MAAO,IAIf,EAAK2U,SAAS,CAACyH,mBAAoBQ,S,iCAIhC3a,GAEP,IADA,IAAMqa,EAAmB,GAChBpd,EAAI,EAAGA,EAAI+C,EAAQ9C,OAAQD,IAEhC,IADA,IAAMY,EAAImC,EAAQ/C,GACTmH,EAAI,EAAGA,EAAIvG,EAAEqG,kBAAkBhH,OAAQkH,IAAK,CACjD,IAAMyW,EAAQhd,EAAEqG,kBAAkBE,GAClC,KAAMyW,KAASle,KAAK3B,MAAMZ,YACtB,GAAIygB,KAASR,EAAS,CAClB,IAAMjF,EAAUiF,EAAQQ,GACxBR,EAAQQ,GAAS,CAACC,MAAO1F,EAAQ0F,MAAQ,EAAGF,QAASxF,EAAQwF,QAAQhY,OAAO,CAAC/E,EAAET,WAE/Eid,EAAQQ,GAAS,CAACC,MAAO,EAAGF,QAAS,CAAC/c,EAAET,KAKxD,OAAOid,I,gCAGDA,GAON,IANA,IAGMU,EAAc5e,OAAOyQ,KAAKyN,GAC1BW,EAAgB7e,OAAOsC,OAAO4b,GAC9BY,EAA8B,GAC3Bhe,EAAI,EAAGA,EAAI8d,EAAY7d,OAAQD,IAAK,CACzC,IAAME,EAAM4d,EAAY9d,GAClBie,EAAMF,EAAc/d,GAC1Bge,EAAO1hB,KAAK,CAAC6D,GAAID,EAAK2d,MAAOI,EAAIJ,MAAOF,QAASM,EAAIN,UAEzDK,EAAOrd,MAAK,SAACC,EAAEC,GAAH,OAASA,EAAEgd,MAAQjd,EAAEid,SAGjC,IADA,IAAMX,EAAqB,GAClBld,EAAI,EAAGA,EAdW,MAenBA,GAAKge,EAAO/d,WACZ+d,EAAOhe,GAAG6d,MAfK,GAaiB7d,IAIpCkd,EAAmB5gB,KAAK0hB,EAAOhe,IAEnC,OAAOkd,EAAmB9d,KAAI,SAAA8e,GAAC,OAAIA,EAAE/d,Q,0IAWhBge,GAAyB,IAAD,OACzClI,EAAQ5B,GAAOE,cACf7U,KAAK3B,MAAM4M,cAAgBjL,KAAK3B,MAAM4M,aAAaxK,KAAOge,EAAWhe,KACrE8V,EAAQ5B,GAAOG,MAGnB,IAIM4J,EAA+B,CACjCzH,gBAAiBV,EACjBoE,QAAQ,OACRgE,QAAQ,GAAD,OALK,EAKL,MACPjQ,OAAO,GAAD,OAAIkQ,GAAJ,MACNhI,aAAc,OACdwG,OAAQ,mBAGN3G,EAAsC,CACxCC,gBAAgB,OAAD,OAAS+H,EAAWnX,MAApB,KACfqP,eAAe,GAAD,OAdC,GAcD,cAfA,GAeA,MACdpI,MAAM,GAAD,OAhBS,GAgBT,MACLG,OAAO,GAAD,OAhBS,GAgBT,MACNkI,aAAc,OACdC,UAAW,SACXuG,OAAQ,OAGNyB,EAAQta,sBAAYvE,KAAK3B,MAAM6J,aAAe,GAAKlI,KAAK3B,MAAM6J,YACpE,OACI,yBAAKoM,MAAOoK,EACRI,MAAOL,EAAWpc,KAClB9D,QAAS,WACL,EAAKF,MAAMiO,0BAA0B,CAACmS,IACtC,EAAKpgB,MAAMqO,uBAAuB+R,EAAYI,KAIlD,yBAAKvK,MAAK,6BAAOmC,GAAP,IAA4BsI,YAAapK,GAAOC,sB,oCAQlE5U,KAAK+V,SAAS,CAACwH,mBAAoBvd,KAAK9B,MAAMqf,sB,+BAGxC,IAAD,OACL,GAA6C,IAAzCvd,KAAK9B,MAAMsf,mBAAmBjd,OAC9B,OACI,yBAAKjC,UAAU,wBACX,yBAAKgW,MAAO,CAAC0K,KAAM,WAAYC,UAAU,WACrC,uBAAG3K,MAAO,CAAC8I,OAAO,QAAlB,2BACA,qHAMhB,IAAM8B,EAAOlf,KAAK9B,MAAMsf,mBAAmB9d,KAAI,SAAAwB,GAAC,OAAI,EAAKie,yBAAyBje,MAC5Eke,EAAYpf,KAAK9B,MAAMqf,kBAAoB,GAAK,CAAC5C,QAAQ,QAC/D,OACI,6BACI,yBAAKrc,UAAU,6BAA6BgW,MAAK,gBAAM8K,IACnD,iHACA,gIAEJ,yBAAK9gB,UAAU,kBACX,mDACA,kBAAC,KAAD,CACIyc,aAAc,kBAAM,EAAKC,eACzBC,aAAc,kBAAM,EAAKD,eACzBE,KAAM,MAEd,yBAAK5c,UAAU,wBACV4gB,Q,GAzKavgB,IAAMC,YAgLzBE,gBACX,SAACZ,GAAD,MAAmB,CACfT,WAAYS,EAAMd,MAAMK,WACxBiG,GAAIxF,EAAMR,oBACVwK,YAAahK,EAAMgK,YACnB+C,aAAc/M,EAAM+M,iBAExB,SAAC0B,GAAD,MAAoB,CAChBD,uBAAwB,SAACzB,EAA0B/C,GAA3B,OAAmDyE,EAASD,GAAuBzB,EAAc/C,KACzHoE,0BAA2B,SAACC,GAAD,OAAyCI,EAASL,GAA0BC,QAThGzN,CAWbwe,IC5LI+B,G,kDACF,WAAYhhB,GAAa,IAAD,8BACpB,cAAMA,IA6FVE,QAAU,WACN,EAAKF,MAAMihB,0BACX,EAAKjhB,MAAMkhB,qBA9FX,EAAKrhB,MAAQ,CACTshB,SAAS,EAAKC,8BAA8B,EAAKphB,MAAM+M,gBAHvC,E,0EAOMA,GAI1B,IAHA,IAAMqM,EAAmC,GACnC6B,EAAmC,GAEhChZ,EAAI,EAAGA,EAAI8K,EAAc7J,WAAWhB,OAAQD,IAAK,CACtD,IAAMof,EAAetU,EAAc7J,WAAWjB,GACxCuQ,EAAMzF,EAAcxK,iBAAiB8e,GAC3CjI,EAAM7a,KAAK,CAACkK,OAAO9G,KAAK3B,MAAMZ,WAAWiiB,GAAezG,SAAU,CAAClY,EAAE8P,EAAI9P,EAAGC,EAAE6P,EAAI7P,KAGtF,IAAK,IAAIV,EAAI,EAAGA,EAAIN,KAAK3B,MAAMd,YAAYgD,OAAQD,IAAK,CACpD,IAAMyJ,EAAM/J,KAAK3B,MAAMd,YAAY+C,GAAGyJ,IAChCC,EAAMhK,KAAK3B,MAAMd,YAAY+C,GAAG0J,IAClCoB,EAAc7J,WAAWua,SAAS/R,IAAQqB,EAAc7J,WAAWua,SAAS9R,IAC5EsP,EAAM1c,KAAK,CAAC6D,GAAIsJ,EAAIC,EAAKD,IAAKA,EAAKC,IAAKA,EAAKiK,OAAQjU,KAAK3B,MAAMd,YAAY+C,GAAG2J,SAIvF,MAAO,CAACwN,QAAO6B,W,2CAOf,IAJiC,IAAD,OAC1B7Y,EAAKT,KAAK3B,MAAM+M,cAAc3K,GAC9Bkf,EAA+C,GAE5Crf,EAAI,EAAGA,EAAIN,KAAK3B,MAAMf,aAAaiD,OAAQD,IAAK,CACrD,IAAMsf,EAAc5f,KAAK3B,MAAMf,aAAagD,GACxCsf,EAAY5V,MAAQ4V,EAAY7V,KAC/B6V,EAAY7V,MAAQtJ,GAAMmf,EAAY5V,MAAQvJ,GAC/Ckf,EAA8B/iB,KAAKgjB,GAG3CD,EAA8B1e,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAE+I,OAAS9I,EAAE8I,QAAU,EAAI,KAaxE,IAXA,IAAM4V,EAAiC,GAKnCC,EAAiC,CACjCvR,MAAM,GAAD,OAHM,GAGN,MACLG,OAAO,GAAD,OAHK,GAGL,MACNiI,eAAe,GAAD,OAJH,GAIG,cALH,GAKG,OAGTrW,EAAI,EAAGA,EAAIqf,EAA8Bpf,OAAQD,IAAK,CAC3D,IAAMwJ,EAAO6V,EAA8Brf,GACvCwJ,EAAKG,OAZoB,GAYgB,WAKzC,IAJA,IAAM8V,EAAWtf,IAAOqJ,EAAKC,IAAMD,EAAKE,IAAMF,EAAKC,IAC7CiW,EAAiB,EAAK3hB,MAAMhB,SAAS,EAAKgB,MAAMhB,SAASqC,KAAI,SAAAiW,GAAC,OAAIA,EAAElV,MAAI+V,QAAQuJ,IAChFE,EAA+C,GAE5CxY,EAAI,EAAGA,EAAIiK,KAAK2I,IAAI2F,EAAeze,WAAWhB,OAAQ,GAAIkH,IAAK,CACpE,IAAMyY,EAAWF,EAAeze,WAAWkG,GACrC0Y,EAAa,EAAK9hB,MAAMZ,WAAWyiB,GACnCE,EAAiB,6BAChBN,GADgB,IAEnBpJ,gBAAgB,OAAD,OAAQyJ,EAAW7Y,MAAnB,OAEnB2Y,EAA8BrjB,KAC1B,uBAAK0B,UAAU,iBACX,uBAAKwgB,MAAOqB,EAAW9d,KAAMiS,MAAO8L,EAAmB9hB,UAAU,gBAK7EuhB,EAAgBjjB,KACZ,uBAAK0B,UAAU,6CAA6CC,QACpD,WACI,EAAKF,MAAMkhB,oBACX,EAAKlhB,MAAM6M,iBAAiB8U,GAC5B,EAAKjK,SAAS,CACVyJ,SAAS,EAAKC,8BAA8BO,OAIxD,wCAAgBA,EAAe1e,OAAO,IACtC,uBAAKhD,UAAU,cACV2hB,KA/B4B,GAqCjD,OAAOJ,I,+BASP,IAAMA,EAAkB7f,KAAKqgB,qBAE7B,OACI,uBAAK/hB,UAAU,sBACX,uBAAKA,UAAU,yBACX,uBAAKA,UAAU,uBACX,uBAAKA,UAAU,qCAAqCC,QAASyB,KAAKzB,SAC9D,gBAAC,KAAD,CAAa2c,KAAM,KACnB,sBAAI5c,UAAU,iBAAd,yBAEHuhB,GAEL,uBAAKvhB,UAAU,4BACX,gBAAC,GAAD,CAAoBga,cAAetY,KAAK9B,MAAMshB,YAGlD,gBAAC,GAAD,CAAqB5B,kBAAmB5d,KAAK3B,MAAM+M,cAAc7J,cAGrE,gBAAC,GAAD,W,GAxHY5C,aAuIbG,gBATS,SAACZ,GACrB,MAAO,CACHX,YAAaW,EAAMd,MAAMG,YACzBF,SAAUa,EAAMd,MAAMC,SACtBC,aAAcY,EAAMd,MAAME,aAC1BG,WAAYS,EAAMd,MAAMK,cAM5B,CACI6hB,wBT5H+B,iBAA4B,CAC/D5U,KAAM,6BACNvM,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMkN,mBAAgBkV,OS0HtBf,kBTtHyB,iBAA4B,CACzD7U,KAAM,sBACNvM,QAAS6M,aAAQ,SAAC9M,GACdA,EAAM+M,kBAAeqV,OSoHrBpV,qBALOpM,CAOXugB,I,SC9KAkB,GAAYC,EAAQ,IACxBD,GAAUE,eAAeD,EAAQ,K,IAiC3BE,G,kDACF,WAAYriB,GAA0B,IAAD,8BACjC,cAAMA,IACDH,MAAQ,CACTkX,UAAW/W,EAAM+W,UACjBE,UAAWjX,EAAMiX,UACjBC,UAAU,EACVoL,gBAAiB,IAErB,EAAKnL,OAAS,EAAKA,OAAOC,KAAZ,gBACd,EAAKC,OAAS,EAAKA,OAAOD,KAAZ,gBATmB,E,+DAYlBmG,EAA6BC,GACxCD,EAAUxG,YAAcpV,KAAK3B,MAAM+W,WACnCpV,KAAK+V,SAAS,CAAEX,UAAWpV,KAAK3B,MAAM+W,c,6BAKvCO,EAAmBC,GACtBD,EAAEE,kBAAmBF,EAAEG,iBAEvB,IAAM8K,EAAO5gB,KAAK9B,MAAMkX,UAClByL,EAAO7gB,KAAK9B,MAAMoX,UAElBhH,EAAOsS,EAAOhL,EAAGK,OACjBxH,EAAOoS,EAAOjL,EAAGO,OAEvBnW,KAAK+V,SAAS,CAAER,UAAU,EAAMH,UAAW9G,EAAMgH,UAAW7G,IAC5DzO,KAAK3B,MAAMyiB,gBAAgBxS,EAAMG,EAAMzO,KAAK3B,MAAM8M,QAAQ1K,M,6BAGvDkV,GACHA,EAAEE,kBAAmBF,EAAEG,iBACvB,IAAMP,EAAWvV,KAAK9B,MAAMqX,SAC5BvV,KAAK+V,SAAS,CAAER,UAAU,IACrBA,GACDvV,KAAKqW,YAAYV,K,kCAIbA,GACR3V,KAAK3B,MAAM6M,iBAAiBlL,KAAK3B,MAAM8M,W,0CAGvB2T,EAAexK,EAAW9T,GAC1C,OACI,yBAAKA,IAAKA,EAAKlC,UAAU,iBACrB,yBAAKA,UAAU,iBACX,yBAAKwgB,MAAOA,EAAOxK,MAAOA,EAAOhW,UAAU,kB,yCAMxCkC,GACf,OAAO,yBAAKA,IAAKA,EAAKlC,UAAU,iBAAgB,iC,mCAmBhD,IAZA,IAAMyiB,EAAU/gB,KAAK3B,MAAMmQ,aAAe,IACtCsR,EAAiC,CACjCvR,MAAM,GAAD,OAAKwS,EAAL,MACLrS,OAAO,GAAD,OAAKqS,EAAL,MACNpK,eAAe,GAAD,OAAKoK,EAAL,cAAkBA,EAAlB,OAGZC,EAAsB,GACtBC,EAAkBjhB,KAAK3B,MAAM8M,QAAQ5J,WAAWhB,OAElD2gB,EAAU,EACVzH,EAAmB,GACdnZ,EAAI,EAAGA,EAAIoR,KAAK2I,IAAI4G,EAAiB,GAAI3gB,IAAK,CACnD,IAAM6f,EAAangB,KAAK3B,MAAMZ,WAAWuC,KAAK3B,MAAM8M,QAAQ5J,WAAWjB,IACjE8f,EAAiB,6BAChBN,GADgB,IAEnBpJ,gBAAgB,OAAD,OAASyJ,EAAW7Y,MAApB,OAEnBmS,EAAE7c,KAAKoD,KAAKmhB,oBAAoBhB,EAAW9d,KAAM+d,EAAmBc,MAKxE,GAHAF,EAAKpkB,KAAK,yBAAK4D,IAAK,EAAGlC,UAAU,cAAcmb,IAE/CA,EAAI,GACAwH,EAAkB,EAAG,CACrBxH,EAAE7c,KAAKoD,KAAKohB,mBAAmBF,MAC/BzH,EAAE7c,KAAKoD,KAAKohB,mBAAmBF,MAE/B,IAAK,IAAI5gB,EAAI,EAAGA,EAAIoR,KAAK2I,IAAI,EAAG4G,GAAkB3gB,IAAK,CACnD,IAAM6f,EAAangB,KAAK3B,MAAMZ,WAAWuC,KAAK3B,MAAM8M,QAAQ5J,WAAWjB,IACjE8f,EAAiB,6BAChBN,GADgB,IAEnBpJ,gBAAgB,OAAD,OAASyJ,EAAW7Y,MAApB,OAEnBmS,EAAE7c,KAAKoD,KAAKmhB,oBAAoBhB,EAAW9d,KAAM+d,EAAmBc,MAGxE,GAAID,EAAkB,EAAG,CACrB,IAAMb,EAAiB,6BAChBN,GADgB,IAEnBpJ,gBAAgB,OAAD,OAASha,+BAAT,OAEnB+c,EAAE7c,KAAKoD,KAAKmhB,oBAAoB,aAAcf,EAAmBc,MAErEzH,EAAE7c,KAAKoD,KAAKohB,mBAAmBF,MAC/BzH,EAAE7c,KAAKoD,KAAKohB,mBAAmBF,MAC/BF,EAAKpkB,KAAK,yBAAK4D,IAAK,EAAGlC,UAAU,cAAcmb,IAGnD,IAAI4H,EAAe,GACbC,EAAiBthB,KAAK3B,MAAM8M,QAAQ7J,OAAOf,OACjD,GAAuB,IAAnB+gB,EACAD,EAAe,2BAGf,IAAK,IAAI/gB,EAAI,EAAGA,EAAIoR,KAAK2I,IAAIiH,EAAgBthB,KAAK3B,MAAMkjB,cAAgB,GAAIjhB,IAEpE+gB,GADM,IAAN/gB,EACgBN,KAAK3B,MAAM8M,QAAQ7J,OAAOhB,GAG1B,KAAON,KAAK3B,MAAM8M,QAAQ7J,OAAOhB,GAK7D,IAAIoe,EAA+B,CAC/BnQ,MAAM,GAAD,OAAKvO,KAAK3B,MAAMmQ,aAAhB,OAET,OAAQ,yBAAKlQ,UAAU,cAAcgW,MAAOoK,GAEpC1e,KAAK3B,MAAM8M,QAAQ1J,SACnB,yBAAK6S,MAAO,CACR2E,SAAU,WACVmE,OAAQ,EACRhN,KAAM,EACNoR,QAAS,GACTC,QAAS,EACTC,WAAY,WAEZ,kBAAC,KAAD,CACIC,YAAapB,GAAUqB,eAAe5hB,KAAK3B,MAAM8M,QAAQ1J,SACzDogB,KAAG,EACHvN,MAAO,CACH/F,MAAOvO,KAAK3B,MAAMmQ,aAAe,GACjCE,OAAQ,YAMxB,yBAAKpQ,UAAU,cACX,yBAAKA,UAAU,kBAAkBgW,MAAO,CAAEwN,SAAU9hB,KAAK9B,MAAMyiB,gBAAkB3gB,KAAK3B,MAAMkjB,cAAgBvhB,KAAK3B,MAAMkjB,gBAClHF,IAGRL,K,+BAML,IAAMe,EAAa/hB,KAAK+hB,aACxB,OACI,kBAAC,KAAD,CACIvM,OAAQxV,KAAKwV,OACbE,OAAQ1V,KAAK0V,OACbsM,QAAS,SAACrM,GAAwBA,EAAEE,kBAAmBF,EAAEG,kBACzDiB,OAAO,SACPC,gBAAiB,CAAEjW,EAAGf,KAAK3B,MAAM+W,UAAWpU,EAAGhB,KAAK3B,MAAMiX,WAC1D2D,SAAU,CAAElY,EAAGf,KAAK9B,MAAMkX,UAAWpU,EAAGhB,KAAK9B,MAAMoX,YAElDyM,O,GA9KSpjB,IAAMC,WAoLjBE,gBACX,SAACZ,GAAD,MAAmB,CACfT,WAAYS,EAAMd,MAAMK,cAE5B,CACIyN,qBALOpM,CAOb4hB,ICrNmBuB,G,uKAGb,IAAMxO,EAAYzT,KAAK3B,MAAM4V,OADxB,EAEqDb,GACtDpT,KAAK3B,MAAMgV,GAAIrT,KAAK3B,MAAMiV,GAAItT,KAAK3B,MAAMkV,GAAIvT,KAAK3B,MAAMmV,GAAIC,GADzDK,EAFF,EAEEA,MAAOF,EAFT,EAESA,MAAOG,EAFhB,EAEgBA,MAAOF,EAFvB,EAEuBA,MAAOxD,EAF9B,EAE8BA,IAAKD,EAFnC,EAEmCA,KAAMuD,EAFzC,EAEyCA,IAAKD,EAF9C,EAE8CA,IAG7CQ,EAAyB,CAC3B7D,IAAKA,EAAM,GACXD,KAAMA,EAAOpQ,KAAK3B,MAAMmQ,aAAe,GAK3C,OACI,yBAAK8F,MAAOJ,EAAI5V,UAAU,oBAAoBiQ,MAAOmF,EAAID,EAH3C,GAGgE/E,OAAQiF,EAAIF,EAH5E,IAIV,0BACIc,EAAC,YAAOT,EAAP,YAAgBF,EAAhB,uCACOE,EANF,GAKL,YAC0BF,EANrB,GAKL,YAC6CG,EANxC,GAKL,YACgEF,EAN3D,GAKL,YACmFE,EADnF,YAC4FF,GAC7FW,YAAaf,EACbgB,KAAK,OACLC,OAAO,e,GArBc/V,IAAMC,WCX1BsjB,G,kDACjB,WAAY7jB,GAA0B,uCAC5BA,G,qDAIN,OACI,yBAAKC,UAAU,eACX,yBAAKA,UAAU,WAAWgW,MAAO,CAAE/F,MAAM,GAAD,OAA2B,IAAtBvO,KAAK3B,MAAMsN,SAAhB,a,GARfhN,IAAMC,WC4DzCujB,I,wDAIF,WAAY9jB,GAAa,IAAD,8BACpB,cAAMA,IAJV8Y,YAGwB,IAFxBC,gBAEwB,EAEpB,EAAKlZ,MAAQ,CACTsQ,aAAc,IACduE,cAAe,IACfqP,aAAc,EACdC,kBAAmB,EACnBC,iBAAkB,GAGtB,EAAKlL,WAAazY,IAAMqZ,YACxB,EAAKb,OAASxY,IAAMqZ,YAEpB,EAAKC,uBAAyB,EAAKA,uBAAuBxC,KAA5B,gBAbV,E,mEAgBD1U,EAAWC,EAAW0Y,GACzC,GAAmC,MAA/B1Z,KAAK9B,MAAMqkB,iBACX,MAAO,GAEX,IAAM1R,EAAM7Q,KAAK9B,MAAMqkB,iBACvB1R,EAAI6I,GAAa,CAAE3Y,EAAGA,EAAGC,EAAGA,GAC5BhB,KAAK+V,SAAS,CAAEwM,iBAAkB1R,M,0CAGlBtC,EAAeG,GAC/B,IAAMF,EAAexO,KAAK9B,MAAMsQ,aAC1BsC,EAAgB9Q,KAAK9B,MAAM6U,cAE7ByP,EAAY9T,EACZ1O,KAAK3B,MAAMjB,MAAMC,SAASkD,OAAS,GAAMiiB,GAAc1R,EAAgB,GAClE9Q,KAAK3B,MAAMjB,MAAMC,SAASkD,OAAS,KAAMiiB,GAAa1R,GAC/D,IAAMnP,EZ1EV,SAAC4M,EAAeG,EAAgBF,EAAsBsC,EAAuBtT,GAEzE,IAAMilB,EAA8B,GACpClU,GAAS,GAOT,IALA,IAAMiC,EAAuB,GACvBC,EAAuB,GACvBC,EAAyB,GACzBgS,EAAe,GAEZpiB,EAAI,EAAGA,EAAI9C,EAAe+C,OAAQD,IAAK,CAC5C,IAAMsB,EAASpE,EAAe8C,GAExBqiB,EAAoBnjB,OAAOyQ,KAAKrO,GAAQrB,OACpB,IAAtBoiB,EACAnS,EAAqB5T,KAAKgF,GAEC,IAAtB+gB,EACLlS,EAAqB7T,KAAKgF,GAEC,IAAtB+gB,EACLjS,EAAuB9T,KAAKgF,GAG5B8gB,EAAa9lB,KAAKgF,GAI1B,IACMuM,EAA6B,CAAEI,MAAOA,EAAOG,OAAQA,EAAQF,aAAcA,EAD1D,GACyFsC,cAAeA,EAAgB,IAC/I9C,GAA0B0U,EAAcD,EAAOtU,GAC/C,IAAMwC,EAAgBwB,GAA2BsQ,EAAO3R,GAExD,OADAP,GAA2BkS,EAAOjS,EAAsBC,EAAsBC,EAAwBvC,EAAcwC,GAC7G8R,EYyCWG,CAAwBrU,EAAOiU,EAAWhU,EAAcsC,EAAe9Q,KAAK3B,MAAMjB,MAAMI,gBACpGqlB,EAAY1Q,GAA2BxQ,EAAWmP,IAEjC9Q,KAAK9B,MAAM4kB,WAAa9iB,KAAK9B,MAAM4kB,WAAa,CAAEC,EAAG,IAAKC,EAAG,MACrEA,EAAIH,EACnB7iB,KAAK+V,SAAS,CAAEwM,iBAAkB5gB,M,mDAKlC,IAAI4C,sBAAYvE,KAAK9B,MAAM4kB,cACvBve,sBAAYvE,KAAK9B,MAAMqkB,kBAA3B,CAEA,IAAMU,EAAYjjB,KAAK9B,MAAM4kB,WAAWC,EAClCG,EAAUljB,KAAK9B,MAAM4kB,WAAWE,EAChCG,EAAWnjB,KAAKoX,WAAWqB,QAAQC,YAEzC,GAAIuK,IAAcE,EAAlB,CAEA,IAAMC,EAAmBpjB,KAAK9B,MAAMqkB,iBAC9Bc,EAAQ3R,KAAKuB,MAAOkQ,EAAWF,EAAa,MAAQ,KAC1D,IAAK,IAAIziB,KAAO4iB,EACZA,EAAiB5iB,GAAKO,EAAIsiB,EAAQD,EAAiB5iB,GAAKO,EAG5Df,KAAK+V,SAAS,CACV+M,WAAY,CAAEC,EAAGI,EAAUH,EAAGE,GAC9BX,iBAAkBa,Q,0CAIL,IAAD,OAChBvjB,OAAOyjB,iBAAiB,UAAU,WAAQ,EAAKC,gCAC/C,IAAIhV,EAAQvO,KAAKoX,WAAWqB,QAAQC,YAChChK,EAAS1O,KAAKoX,WAAWqB,QAAQE,aACrC3Y,KAAK+V,SACD,CACI+M,WAAY,CAAEC,EAAGxU,EAAOyU,EAAGtU,GAC3B4T,iBAAkB/T,EAClB8T,kBAAmB3T,IAEvB,kBAAM,EAAKrQ,MAAMmlB,UAAU,EAAKnlB,MAAM6J,YAAa,EAAK7J,MAAMqF,IAAI,kBAAM,EAAK+f,oBAAoBlV,EAAOG,W,yCAI7FkN,EAAiCC,GAChD,GAAI7b,KAAK3B,MAAMN,sBAAuB,CAClC,IAAIglB,EAAI,IACJC,EAAI,IACHze,sBAAYvE,KAAK9B,MAAM4kB,cACxBC,EAAI/iB,KAAK9B,MAAM4kB,WAAWC,EAC1BC,EAAIhjB,KAAK9B,MAAM4kB,WAAWE,GAG9BA,EAAIhjB,KAAK9B,MAAMmkB,kBACfriB,KAAKyjB,oBAAoBV,EAAGC,GAC5BhjB,KAAK3B,MAAMyP,uBAAsB,M,oCAMrC,GAAoC,OAAhC9N,KAAK9B,MAAMqkB,kBAA6Bhe,sBAAYvE,KAAK9B,MAAMqkB,kBAC/D,MAAO,GAIX,IADA,IAAM9K,EAAQ,GACLnX,EAAI,EAAGA,EAAIN,KAAK3B,MAAMjB,MAAMC,SAASkD,OAAQD,IAAK,CACvD,IAAM0C,EAAUhD,KAAK3B,MAAMjB,MAAMC,SAASiD,GAC1CmX,EAAM7a,KACF,kBAAC,GAAD,CACI4D,IAAKwC,EAAQvC,GACb8gB,cAAevhB,KAAK9B,MAAMkkB,aAC1BjX,QAASnI,EACToS,UAAWpV,KAAK9B,MAAMqkB,iBAAiBvf,EAAQvC,IAAIM,EACnDuU,UAAWtV,KAAK9B,MAAMqkB,iBAAiBvf,EAAQvC,IAAIO,EACnD8f,gBAAiB9gB,KAAKiY,uBACtBzJ,aAAcxO,KAAK9B,MAAMsQ,gBAIrC,OAAOiJ,I,oCAKP,IAAM6B,EAAQ,GACd,GAAmC,MAA/BtZ,KAAK9B,MAAMqkB,iBACX,MAAO,GAGX,IAAK,IAAIjiB,EAAI,EAAGA,EAAIN,KAAK3B,MAAMjB,MAAME,aAAaiD,OAAQD,IAAK,CAC3D,IAAMojB,EAAS1jB,KAAK3B,MAAMjB,MAAME,aAAagD,GAAGyJ,IAC1CrL,EAASsB,KAAK3B,MAAMjB,MAAME,aAAagD,GAAG0J,IAC1C8P,EAAiB4J,EAAShlB,EAChC,GAAIglB,IAAWhlB,EAAQ,CACnB,IAAMmb,EAAkE,EAArDnI,KAAKiS,KAAK3jB,KAAK3B,MAAMjB,MAAME,aAAagD,GAAG2J,QAC9DqP,EAAM1c,KACF,kBAAC,GAAD,CACI4D,IAAKsZ,EACLzG,GAAIrT,KAAK9B,MAAMqkB,iBAAiBmB,GAAQ3iB,EACxCuS,GAAItT,KAAK9B,MAAMqkB,iBAAiBmB,GAAQ1iB,EACxCuS,GAAIvT,KAAK9B,MAAMqkB,iBAAiB7jB,GAAQqC,EACxCyS,GAAIxT,KAAK9B,MAAMqkB,iBAAiB7jB,GAAQsC,EACxCiT,OAAQ4F,EACRrL,aAAcxO,KAAK9B,MAAMsQ,iBAMzC,OAAO8K,I,8CAIP,OACI,yBAAKhb,UAAU,gBACX,yBAAKA,UAAU,uBAAuB0B,KAAK3B,MAAMR,qBACjD,kBAAC,GAAD,CAAa8N,SAAU3L,KAAK3B,MAAMT,wC,8CAM1C,IAAI2N,EAAU,2BAKd,OAJIvL,KAAK3B,MAAMqN,2BACXH,GAAWvL,KAAK3B,MAAMqN,0BAItB,yBAAKpN,UAAU,gBACX,yBAAKA,UAAU,uBAAuBiN,M,+BAKxC,IAAD,OACL,GAAIvL,KAAK3B,MAAMpB,aACX,OAAO+C,KAAK4jB,wBAGhB,GAAI5jB,KAAK3B,MAAMtB,oBACX,OAAOiD,KAAK6jB,wBAGhB,IAAMC,OAA+CxD,IAA7BtgB,KAAK3B,MAAM+M,cAC7BuP,EAAUmJ,EAAkB,OAAS,GACrCf,EAAI/iB,KAAK9B,MAAM4kB,WAAa9iB,KAAK9B,MAAM4kB,WAAWC,EAAI,IACtDC,EAAIhjB,KAAK9B,MAAM4kB,WAAa9iB,KAAK9B,MAAM4kB,WAAWE,EAAI,IAE5D,OACI,yBAAK1kB,UAAU,UAAU6c,IAAKnb,KAAKoX,YAC/B,kBAAC,IAAD,CACI2M,aAAc,EACdC,iBAAkB,EAClBC,iBAAkB,EAClBhgB,QAAS,CACLigB,SAAU,EACVC,gBAAgB,GAEpBC,YAAa,SAACzO,GAAa,EAAKI,SAAS,CAAEqM,aAAczM,EAAE0O,WAE1D,cACGC,OADH,EAEGC,QAFH,EAGGC,aAHH,0DAMO,kBAAC,IAAMC,SAAP,KAEQX,GACA,kBAAC,GAAD,CAAetjB,IAAK,EAAKnC,MAAM+M,cAAc3K,GAAI2K,cAAe,EAAK/M,MAAM+M,gBAE/E,kBAAC,IAAD,KACI,yBAAK9M,UAAU,MAAM6c,IAAK,EAAKhE,OAC3B7C,MAAO,CAAE/F,MAAOwU,EAAGrU,OAAQsU,EAAGrI,QAASA,IAGnC,EAAKzc,MAAM4kB,YACX,EAAKzH,cAGL,EAAKnd,MAAM4kB,YACX,EAAKjK,yB,GA3NnBla,IAAMC,YAiQrBE,gBA1BS,SAACZ,GACrB,MAAO,CACHlB,YAAakB,EAAMlB,YACnBC,aAAciB,EAAMjB,aACpBF,oBAAqBmB,EAAMnB,oBAC3Bc,oBAAqBK,EAAML,oBAC3B6N,yBAA0BxN,EAAMwN,yBAChC9N,mCAAoCM,EAAMN,mCAC1CR,MAAOc,EAAMd,MACbgO,cAAelN,EAAMkN,cAErBlD,YAAahK,EAAMgK,YACnBxE,GAAIxF,EAAMR,oBAEVK,sBAAuBG,EAAMH,0BAIV,SAAC4O,GACxB,MAAO,CACHtB,SAAUA,GACVyC,sBAAuB,SAACC,GAAD,OAAuBpB,EAASmB,GAAsBC,KAC7EyV,UAAW,SAACtb,EAAqBxE,EAAmCghB,GAAzD,OAAgF/X,EbxB1E,SAACzE,EAAqBxE,EAAmCghB,GAAzD,8CACrB,WAAO/X,GAAP,SAAAzL,EAAA,sDACIyL,EAAS1P,MAETgL,EACIC,EAAaxE,GACb,SAAC6H,GAAsBoB,EAASrB,GAAuBC,OACvD,SAACI,GAAuBgB,EAASvE,GAAwBuD,OACzD,SAACF,GAA2BkB,EAASnB,GAA4BC,OAEhE0B,MAAK,SAAAhD,GAAC,OAAIwC,EAAStB,GAASlB,OAC5BgD,MAAK,kBAAMuX,OACXvX,MAAK,kBAAMR,EAASf,SACpBgC,OAAM,SAAC9B,GACJ5I,QAAQC,MAAM2I,GACda,EApM6C,CACzDjC,KAAM,sBACNvM,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMjB,cAAe,EACrBiB,EAAMnB,qBAAsB,UAkLhC,2CADqB,sDawBmFymB,CAAUtb,EAAaxE,EAAIghB,QAIxH5lB,CAGbqjB,IC9SIwC,G,kDAEF,WAAYtmB,GAAa,IAAD,8BACpB,cAAMA,IAFVumB,eACwB,EAEpB,EAAKA,UAAYjmB,IAAMqZ,YAFH,E,iEAMW,OAA3BhY,KAAK4kB,UAAUnM,UACXzY,KAAK3B,MAAMP,OACXkC,KAAK4kB,UAAUnM,QAAQoM,QAGvB7kB,KAAK4kB,UAAUnM,QAAQqM,U,+BAKzB,IAAD,OACL,GAAIvgB,sBAAYvE,KAAK3B,MAAM6J,aACvB,OACI,8BAGH,GAAI3D,sBAAYvE,KAAK3B,MAAM8d,YAC5B,OACI,yBAAK7d,UAAU,gBACX,yBAAKA,UAAU,oCAAf,6DAOR,IAFA,IAAIymB,EACAC,EAA0B,GACrB1kB,EAAI,EAAGA,EAAIN,KAAK3B,MAAM8d,WAAW5a,WAAWhB,OAAQD,IAAK,CAC9D,IAAM0E,EAAMhF,KAAK3B,MAAM8d,WAAW5a,WAAWjB,GACzC0E,KAAOhF,KAAK3B,MAAM4mB,oBAClBD,EAAwBpoB,KAAKoD,KAAK3B,MAAM4mB,oBAAoBjgB,GAAK3C,MAE5D2C,KAAOhF,KAAK3B,MAAML,uBACvBgnB,EAAwBpoB,KAAKoD,KAAK3B,MAAML,uBAAuBgH,GAAK3C,MAGpE2iB,EAAwBpoB,KAAKoI,GAGrC,IAAMkgB,EAAqBF,EAAwBzlB,KAAK,MAGxD,OAFAwlB,EAA+C,MAArC/kB,KAAK3B,MAAM8d,WAAW/Y,YAAsB,GAAKpD,KAAK3B,MAAM8d,WAAW/Y,YAG7E,yBAAK9E,UAAU,UACX,yBAAKA,UAAU,SACX,uBAAGA,UAAU,mBAAkB,2BAAI0B,KAAK3B,MAAM8d,WAAW9Z,OACzD,uBAAG/D,UAAU,sBAAsB4mB,IAEvC,2BAAOC,OAAQ,kBAAM,EAAK9mB,MAAMgO,WAAU,IACtC+Y,QAAS,kBAAM,EAAK/mB,MAAMgO,WAAU,IACpC8O,IAAKnb,KAAK4kB,UACVS,UAAQ,EAACC,UAAQ,EAACC,IAAKR,EAASzmB,UAAU,kBAH9C,oCAMI,uCANJ,kB,GAvDCK,IAAMC,WAqEZE,gBACX,SAACZ,GAAD,MAAmB,CACfJ,OAAQI,EAAMJ,OACdoK,YAAahK,EAAMgK,YACnBiU,WAAYje,EAAMie,WAClB8I,oBAAqB/mB,EAAMd,MAAMK,WACjCO,uBAAwBE,EAAMF,0BAElC,CACIqO,cATOvN,CAWb6lB,ICrFaa,I,6KAXP,OACI,uBAAKlnB,UAAU,WACX,uBAAKA,UAAU,kBACX,gBAAC,GAAD,OAEJ,gBAAC,GAAD,W,GAPUK,cCmBpB8mB,I,wDACF,WAAYpnB,GAAsB,IAAD,8BAC7B,cAAMA,IACDqnB,aAAe,EAAKA,aAAajQ,KAAlB,gBACpB,EAAKkQ,YAAc,EAAKA,YAAYlQ,KAAjB,gBAHU,E,2DAQ7B,GAAKzV,KAAK3B,MAAMjB,MAAhB,CAEA,IAAM4F,EAAUV,SAASsjB,cAAc,KACvC5iB,EAAQ6iB,aAAa,OAAQ,iCAAmCjmB,mBAAmBiJ,KAAKG,UAAUhJ,KAAK3B,MAAMjB,MAAO,KAAM,KAC1H4F,EAAQ6iB,aAAa,WAAY,uBACjC7iB,EAAQsR,MAAMqG,QAAU,OACxBrY,SAASgH,KAAKwc,YAAY9iB,GAC1BA,EAAQ+iB,QACRzjB,SAASgH,KAAK0c,YAAYhjB,M,kCAIlBijB,GAA0B,IAAD,OAC3BC,EAAqB,mEAC3BhjB,QAAQijB,IAAIF,GACZ,IAAMG,EAAOH,EAAc,GACrBI,EAAS,IAAIC,WAGnBD,EAAOE,OAAS,SAAUC,GACtB,GAAqB,OAAjBA,EAAM9nB,QAA2C,OAAxB8nB,EAAM9nB,OAAOkF,OACtC,IACI,IAAM6iB,EAAeD,EAAM9nB,OAAOkF,OAAO8iB,YALvB,SAACvc,GAAc,EAAK9L,MAAMsoB,kBAAkBxc,GAQ9Dyc,CAFmBriB,sBAAYkiB,GAAgB,GAAK5d,KAAKC,MAAM2d,IAGjE,MAAO3a,GACLwQ,MAAM4J,EAAqBpa,GAC3B5I,QAAQC,MAAM,uCAAwC2I,QAI1DwQ,MAAM4J,IAIdG,EAAOQ,WAAWT,K,mDAIqB,IAAD,OACtC,OAAI7hB,sBAAYvE,KAAK3B,MAAM+M,eAAuB,4BAG9C,0BAAKpL,KAAK3B,MAAM+M,cAAc7J,WAAW7B,KAAI,SAAAe,GAAE,OAC3C,sBAAInC,UAAU,cACT,EAAKD,MAAMZ,WAAWgD,GAAI4B,Y,kDAQvC,IAAIykB,EAA4B,GAIhC,YAHiCxG,IAA7BtgB,KAAK3B,MAAM+M,gBACX0b,EAAa9mB,KAAK3B,MAAM+M,cAAc9J,OAAO5B,KAAI,SAAAwB,GAAC,OAAI,sBAAI5C,UAAU,cAAc4C,OAE/E,0BAAK4lB,K,+BAGN,IAAD,OACL,OACI,uBAAKxoB,UAAU,WACX,uBAAKA,UAAU,iBACX,uBAAKiQ,MAAO,GAAIG,OAAQ,GAAIpQ,UAAU,gBAAgByoB,IAAI,GAAGxB,IAAI,+mCACjE,4CAEJ,uEAGIvlB,KAAK3B,MAAMrB,aACX,uBAAKsB,UAAU,0BAA0BC,QAASyB,KAAK0lB,cAAvD,2BAKC1lB,KAAK3B,MAAMrB,aAAegD,KAAK3B,MAAM2oB,oBACtC,yBAAO1oB,UAAU,kBAAkBoM,KAAK,OAAOuc,OAAO,QAAQxM,SAAU,SAAC9E,GAC9C,OAAnBA,EAAEjX,OAAOwoB,OAAgB,EAAKvB,YAAYhQ,EAAEjX,OAAOwoB,UAI/D,uBAAK5oB,UAAU,kBAEP0B,KAAK3B,MAAM+M,eACX,uBAAK9M,UAAU,mBACX,iDACC0B,KAAKmnB,6BAIVnnB,KAAK3B,MAAM+M,eACX,uBAAK9M,UAAU,mBACX,sBAAIA,UAAU,qBAAd,oBACC0B,KAAKonB,+BAIVpnB,KAAK3B,MAAM+M,eAAiBpL,KAAK3B,MAAMjB,OACvC,uBAAKkB,UAAU,mBACX,0DAAiC,kCAAjC,+BAAyE,uCAAzE,KACA,qCAAY,yBAAIkB,OAAOsC,OAAO9B,KAAK3B,MAAMjB,MAAMK,YAAY8C,OAA/C,WAAZ,mBACA,4GAAmF,mCAAnF,QAAqG,wCAArG,8BACA,gG,GAjHN5B,cA0HPG,gBACX,SAACZ,GAAD,MAAmB,CACfkN,cAAelN,EAAMkN,cACrBhO,MAAOc,EAAMd,MACbsG,GAAIxF,EAAMR,oBACVD,WAAYS,EAAMd,MAAMK,WACxBT,YAAakB,EAAMlB,YACnBgqB,kBAAmB9oB,EAAMnB,uBAE7B,CACI4pB,kBhByKyB,SAACU,GAAD,8CAC7B,WAAO1a,GAAP,mBAAAzL,EAAA,yDAEU0C,EAASiH,GAAUyc,OAAOD,GACzBE,kBAAQ3jB,GAHnB,uBAKQ0Y,MAAM,iCALd,0BASI,IAAShc,EAAI,EAAGA,EAAI+mB,EAAYhqB,SAASkD,OAAQD,IACvC6K,EAAUkc,EAAYhqB,SAASiD,IACjCiE,sBAAY4G,EAAQ5J,aAA6C,IAA9B4J,EAAQ5J,WAAWhB,UACtD4K,EAAQ5J,WAAa/B,OAAOyQ,KAAK9E,EAAQvK,mBAZrD,gBAgBUqB,QAAQC,QACVyK,EAzS2D,CACnEjC,KAAM,8BACNvM,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMkN,mBAAgBkV,EACtBpiB,EAAM+M,kBAAeqV,QAuShBnT,MAAK,kBAAMR,EAAS1P,SACpBkQ,MAAK,kBAAMR,EAAStB,GAASgc,OAC7Bla,MAAK,kBAAMR,EAASmB,IAAsB,OAC1CX,MAAK,kBAAMR,EAASf,SAtB7B,2CAD6B,wDgBnLlB9M,CAYb2mB,IC1II+B,G,kDACF,WAAYnpB,GAA0B,IAAD,8BACjC,cAAMA,IACDH,MAAQ,CACTupB,gBAAgB,EAChBC,eAAe,GAGnB,EAAKC,oBAP4B,E,gEAUhB,IAAD,OAEZC,EADc/nB,OAAOC,SAAS+nB,OACZC,OAAO,GACzBlkB,EAAc,GAKlB,GAJAgkB,EAAMnlB,MAAM,KAAKslB,SAAQ,SAAUC,GAC/B,IAAIC,EAAOD,EAAKvlB,MAAM,KACtBmB,EAAOqkB,EAAK,IAAMnlB,mBAAmBmlB,EAAK,OAExC,SAAUrkB,GAA8B,KAAnBA,EAAM,MAAsC,OAAnBA,EAAM,KAA1D,CAKA,IAAMskB,EAAkBloB,KAAK3B,MAAMG,QAAQsB,SAASqoB,SACpDnoB,KAAK3B,MAAMG,QAAQ5B,KAAK,CACpBurB,SAAUD,EACVL,OAAQ,KAGZ,IACMO,EADmE1rB,yEACxBkH,EAAM,KACnDsE,EAAsB,GAC1BkB,MAAMgf,GACDjb,MAAK,SAAChJ,GACH,GAAwB,MAApBA,EAASuF,OACT,MAAMvF,EAASuF,OAEnB,IAAM2e,EAAiBlkB,EAASG,QAAQgkB,IAAI,gBACrB,OAAnBD,IACAngB,EAAcmgB,EACd,EAAKhqB,MAAMiK,eAAeJ,IAG9B,EAAK6N,SAAS,CAAE0R,gBAAgB,OAEnC7Z,OAAM,SAAC9B,GACJ5I,QAAQC,MAAM2I,GACd,EAAKiK,SAAS,CAAE2R,eAAe,EAAMD,gBAAgB,IACrDnL,MAAM,2DA7BVtc,KAAK9B,MAAQ,CAAEwpB,eAAe,EAAMD,gBAAgB,K,+BAkCxD,OAAIznB,KAAK9B,MAAMupB,eAEP,yBAAKnpB,UAAU,OACX,yBAAKA,UAAU,gBACX,yBAAKA,UAAU,WACf,yBAAKA,UAAU,uBAAf,0BAMZ0B,KAAK9B,MAAMwpB,cACJ,kBAAC,IAAD,CAAUa,GAAG,WAIpB,yBAAKjqB,UAAU,OACX,kBAAC,GAAD,MACA,kBAAC,GAAD,W,GAxEUK,IAAMC,WA8EjBC,eACXC,aACI,SAACZ,GAAD,MAAmB,MACnB,SAACyO,GAAD,MAAoB,CAChBrE,eAAgB,SAACJ,GAAD,OAAyByE,EjBhGvB,SAACzE,GAAD,MAAiD,CAC3EwC,KAAM,mBACNK,QAAS7C,EACT/J,QAAS6M,aAAQ,SAAC9M,GACdA,EAAMgK,YAAcA,EACpBhK,EAAMf,cAAe,MiB2FiCmL,CAAeJ,QAHzEpJ,CAKE0oB,KClGOgB,GxB+BqBC,YAC9BxqB,EACAnB,IACA4rB,YACIC,IAAe,WAAf,EAAmBvsB,KwBnBZwsB,GAdO,WAClB,OACI,kBAAC,IAAD,CAAUC,MAAOL,IACb,kBAAC,IAAD,CAAeM,SAAUpsB,iBACrB,kBAAC,IAAD,KACI,kBAAC,IAAD,CAAOqsB,KAAK,SAASC,UAAWhqB,IAChC,kBAAC,IAAD,CAAO+pB,KAAK,WAAWC,UAAWxB,KAClC,kBAAC,IAAD,CAAOuB,KAAK,IAAIC,UAAW5qB,QCX/C6qB,IAASC,OAAO,kBAAC,GAAD,MAAS5mB,SAAS6mB,eAAe,W","file":"static/js/main.76920ce4.chunk.js","sourcesContent":["import { createStore, applyMiddleware, compose } from 'redux';\nimport { State, ActionWrapper } from './types';\nimport thunk from 'redux-thunk';\nimport { createLogger } from 'redux-logger';\nimport SpotifyWebApi from 'spotify-web-api-js'\n\nconst middleWare: any = [];\nconst loggerMiddleware = createLogger({\n    predicate: (getState: Function, action: ActionWrapper) => process.env.NODE_ENV === 'development' && action.type !== 'SET_GRAPH_LOADING_MESSAGE',\n    collapsed: (getState, action) => true\n});\nmiddleWare.push(thunk)\nmiddleWare.push(loggerMiddleware)\n\n\nconst getInitialState = (): State => {\n    return ({\n        isGraphLoadingError: false,\n        graphLoaded: false,\n        graphLoading: false,\n        chosenArtistLoading: false,\n        userLoggedIn: false,\n        graph: ({ clusters: [], clusterEdges: [], artistEdges: [], clusterSquares: [], artistDict: {} }),\n        spotifyWebApiObject: new SpotifyWebApi(),\n        graphLoadingRelatedArtistsProgress: 0,\n        graphLoadingMessage: \"\",\n        paused: false,\n        isGraphFromFileLoaded: false,\n        nonFavouriteArtistDict: {}\n    })\n}\n\nconst rootReducer = (\n    state: State = getInitialState(),\n    action: ActionWrapper<any>\n) => {\n    if (!action.reducer) return state\n    else return action.reducer(state)\n}\n\nconst createStoreInstance = () => createStore(\n    rootReducer,\n    getInitialState(),\n    compose(\n        applyMiddleware(...middleWare)\n    ))\n\nexport { createStoreInstance }\n","/* eslint-disable @typescript-eslint/no-useless-constructor */\n\nimport React from 'react'\nimport { connect } from 'react-redux'\nimport { withRouter } from 'react-router-dom'\nimport { RouteComponentProps } from 'react-router'\n\nimport { State } from '../store/types'\n\nimport './welcome-page.css'\nimport '../App.css'\n\ninterface WelcomePageProps extends RouteComponentProps<any> {\n    loggedIn: boolean\n}\n\nclass WelcomePage extends React.Component<WelcomePageProps, {}> {\n    constructor(props: WelcomePageProps) {\n        super(props);\n    }\n\n    render() {\n        return (\n            <div className=\"App\">\n                <div className=\"page-wrapper\">\n                    <div className=\"page-description-div\">\n                        <h1>Spotify graph</h1>\n                        <p>A project that will show you your musical taste.</p>\n                        <p>We will fetch data from your spotify account, divide them into groups and visualize these groups in form of a graph.</p>\n                    </div>\n                    <button className=\"very-big-button\" onClick={() => { this.props.history.push('/login') }}>Continue to get your graph</button>\n                    <div className=\"generic-description\">\n                        <p>Have a look at the code on: <a href=\"https://gitlab.com/gajdusep/spotifygraph\" target=\"_blank\">GitLab</a></p>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default withRouter<WelcomePageProps, any>(\n    connect(\n        (state: State) => ({\n            loggedIn: state.userLoggedIn\n        }),\n        {}\n    )(WelcomePage))\n","/* eslint-disable @typescript-eslint/no-useless-constructor */\n\nimport React from 'react'\n\nimport './welcome-page.css'\nimport '../App.css'\n\ninterface LoginPageProps { }\n\ninterface LoginPageState {}\n\n/** Login page that redirects to Spotify login page. */\nexport default class LoginPage extends React.Component<LoginPageProps, LoginPageState> {\n    constructor(props: LoginPageProps) {\n        super(props);\n    }\n\n    /** Creates Spotify login link with all necessary parameters */\n    spotifyLoginLink() {\n        const client_id = 'dfb05fa5c36b41d48407ad5e3773d39b'\n        const scope = [\n            'streaming',\n            'user-read-email',\n            'user-read-private',\n            'user-read-playback-state',\n            'user-modify-playback-state',\n            'user-library-read',\n            'user-library-modify',\n            'user-follow-read',\n            'playlist-modify-private',\n            'playlist-read-private',\n        ]\n        const state = 'rndstringsomehash'\n        const redirect_uri = process.env.NODE_ENV === \"production\" ?\n            process.env.REACT_APP_PROD_SPOTIFY_REDIRECT_URL : process.env.REACT_APP_DEV_SPOTIFY_REDIRECT_URL\n        const params = {\n            client_id:client_id,\n            response_type:'code',\n            redirect_uri:redirect_uri,\n            scope:scope.join(' '),\n            state:state,\n        }\n\n        const encodeGetParams = (p:Object): string =>\n            Object.entries(p).map(kv => kv.map(encodeURIComponent).join(\"=\")).join(\"&\");\n\n        const link = 'https://accounts.spotify.com/authorize?' + encodeGetParams(params)\n        return link\n    }\n\n    loginWithSpotify() {\n        window.location.assign(this.spotifyLoginLink())\n    }\n\n    render() {\n        return (\n            <div className=\"App\">\n                <div className=\"page-wrapper\">\n                    <div className=\"generic-description\">\n                        <div>Please login with your spotify account</div>\n                    </div>\n                    <button className=\"very-big-button\" onClick={() => this.loginWithSpotify()}>Log in with your Spotify account</button>\n                </div>\n            </div>\n        )\n    }\n}\n","import { ArtistFull, Cluster, ArtistEdge, ClusterEdge, ClusterSquare, StringDict, Position, NumberDict } from '../store/types'\n\n/* ALL THE FOLLOWING METHODS ARE PARSING THE JSONS\n   THAT WERE RECEIVED FROM THE BACKEND\n*/ \n \ninterface clusterJson {\n    id: string\n    genres: string[]\n    country: string\n    artistsPositions: NumberDict<Position>\n}\n\n/** Parses clusters */\nexport const parseClusters = (artistsDict: StringDict<ArtistFull>, clusterJsons: clusterJson[]): Cluster[] => {\n    let clusters: Cluster[] = []\n    for (let i = 0; i < clusterJsons.length; i++) {\n        const key = clusterJsons[i].id\n\n        // prepare the cluster artists:\n        const clusterArtists: ArtistFull[] = []\n        const clusterArtistsPositions: StringDict<Position> = {}\n\n        for (const [artistsSpotifyId, artistPosition] of Object.entries(clusterJsons[i].artistsPositions)) {\n            clusterArtists.push(artistsDict[artistsSpotifyId])\n            clusterArtistsPositions[artistsSpotifyId] = { x: artistPosition.x, y: artistPosition.y }\n        }\n\n        clusterArtists.sort((a, b) => { return b.score - a.score })\n\n        const currCluster: Cluster = ({\n            id: key,\n            genres: clusterJsons[i].genres,\n            artistsIds: clusterArtists.map(aFull => aFull.id),\n            artistsPositions: clusterArtistsPositions,\n            country: clusterJsons[i].country\n        })\n        clusters.push(currCluster)\n    }\n    return clusters\n}\n\ninterface ClusterSquareJSON {\n    [id: string]: { x: number, y: number }\n}\n\n/** Parses cluster positions */\nexport const processClusterPositions = (positions: ClusterSquareJSON[]): ClusterSquare[] => {\n    let clusterSquares: ClusterSquare[] = []\n    for (let i = 0; i < positions.length; i++) {\n\n        const square = positions[i]\n        const clusterSquare: ClusterSquare = {};\n        if (Object.values(square).length > 0) {\n            for (let id in square) {\n                let x = square[id].x\n                let y = square[id].y\n                clusterSquare[id] = { x: x, y: y }\n            }\n            clusterSquares.push(clusterSquare)\n        }\n    }\n\n    return clusterSquares\n}\n\ninterface ClusterEdgeJSON {\n    id1: string,\n    id2: string,\n    weight: number\n}\n\n/** Parses cluster edges */\nexport const parseClusterEdges = (clusterEdgesJsons: ClusterEdgeJSON[]): ClusterEdge[] => {\n    return clusterEdgesJsons.map(element => ({ id1: element.id1, id2: element.id2, weight: element.weight })\n    )\n}\n\ninterface ArtistEdgeJSON {\n    id1: string,\n    id2: string,\n    weight: number\n}\n\n/** Parses artist edges */\nexport const parseArtistEdges = (artistEdgesJSONs: ArtistEdgeJSON[]): ArtistEdge[] => {\n    let artistEdges: ArtistEdge[] = artistEdgesJSONs.map((edge) => ({ id1: edge.id1, id2: edge.id2, weight: edge.weight }))\n    return artistEdges\n}\n","import SpotifyWebApi from 'spotify-web-api-js'\nimport { ArtistFull, ArtistReduced, StringDict, Graph, SongFull } from '../store/types';\nimport { processClusterPositions, parseClusters, parseClusterEdges, parseArtistEdges } from './graph-parsing-methods'\nimport { isUndefined } from 'util';\n\n// requests retry interval\nconst RETRY_INTERVAL = 4000\n\n// parameters for score computing\nconst isFollowedConst = 5\nconst likedSongConst = 1\nconst spotifyPopularityConst = 0.1\n\nconst asyncTimeout = (ms: number) => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nconst getCookie = (name: string): string => {\n    if (!document.cookie) {\n        return ''\n    }\n\n    const xsrfCookies = document.cookie.split(';')\n        .map(c => c.trim())\n        .filter(c => c.startsWith(name + '='));\n\n    if (xsrfCookies.length === 0) {\n        return ''\n    }\n    return decodeURIComponent(xsrfCookies[0].split('=')[1]);\n}\n\n/** Translates SpotifyAPI TrackObjectFull to SongFUll */\nexport const songFromJSONData = (element: SpotifyApi.TrackObjectFull): SongFull => {\n    if (element.preview_url === null) {\n        console.debug(element.id, ':', element.name, element)\n    }\n\n    return {\n        name: element.name,\n        id: element.id,\n        previewLink: element.preview_url,\n        artistsIds: element.artists.map(a => a.id),\n        externalUrl: element.external_urls.spotify\n    }\n}\n\n/**\n * Fetches all artists followed by the logged-in user\n * @param sp SpotifyWebApiJs object\n * @returns IDs of followed artists\n */\nconst getFollowedArtistsIds = async (sp: SpotifyWebApi.SpotifyWebApiJs\n): Promise<string[]> => {\n    let limit = 50\n    let result: string[] = []\n\n    let response\n    const maxRetries = 3\n    let after = null\n    do {\n        let success = true\n        let retries = 0\n        do {\n            try {\n                const options: {} = after ? { limit: limit, after: after } : { limit: limit }\n                response = await sp.getFollowedArtists(options)\n            } catch (err) {\n                await asyncTimeout(err.getResponseHeader['retry-after'] ? parseInt(err.headers['retry-after'] + 1) * 1000 : RETRY_INTERVAL);\n                success = false\n                retries += 1\n            }\n        } while (success === false && retries < maxRetries)\n\n        // the request was not successfull even after retries\n        if (isUndefined(response)) {\n            after = null\n        }\n        else {\n            result.push(...response.artists.items.map((artObj: SpotifyApi.ArtistObjectFull) => artObj.id))\n            after = response.artists.cursors.after\n        }\n    } while (after)\n\n    return result\n}\n\n/**\n  * Fetches related artists of the given artists\n  * @param sp SpotifyWebApiJs object\n  * @param artistsToExploreIds list of artist IDs - we will get related artists information from them\n  * @param alreadyLoadedRelatedArtists already saved related artists from the localStorage\n  * @param progressBarCallback callback to be called to let progress bar know about the progress\n  * @returns list of lists of IDs, the order of related artists is the same as in the artistsToExploreIds list\n  */\nconst getAllRelatedArtists = async (\n    sp: SpotifyWebApi.SpotifyWebApiJs,\n    artistsToExploreIds: string[],\n    alreadyLoadedRelatedArtists: StringDict<string[]>,\n    progressBarCallback: Function\n): Promise<string[][]> => {\n    const result: string[][] = []\n    const maxRetries = 3\n    const artistsToExploreLen = artistsToExploreIds.length\n\n    for (let i = 0; i < artistsToExploreLen; i++) {\n        const aID = artistsToExploreIds[i]\n        progressBarCallback(i / artistsToExploreLen)\n\n        if (aID in alreadyLoadedRelatedArtists) {\n            result.push(alreadyLoadedRelatedArtists[aID])\n        } else {\n            let response\n            let success = true\n            let retries = 0\n            do {\n                try {\n                    response = await sp.getArtistRelatedArtists(aID)\n                } catch (err) {\n                    await asyncTimeout(err.getResponseHeader['retry-after'] ? parseInt(err.headers['retry-after'] + 1) * 1000 : RETRY_INTERVAL);\n                    success = false\n                    retries += 1\n                }\n            } while (success === false && retries < maxRetries)\n\n            if (isUndefined(response)) {\n                result.push([])\n            }\n            else {\n                const obtainedRelArtists = response.artists.map((objectFull) => objectFull.id)\n                alreadyLoadedRelatedArtists[aID] = obtainedRelArtists\n                result.push(obtainedRelArtists)\n            }\n        }\n    }\n    return result\n}\n\n/**\n * Gets all liked songs of the logged-in user\n * @param sp SpotifyWebApiJs object\n * @returns Promise of list of TrackObjectFull\n */\nconst getLikedSongs = async (sp: SpotifyWebApi.SpotifyWebApiJs\n): Promise<SpotifyApi.TrackObjectFull[]> => {\n    let offset = 0\n    let limit = 50\n    let result: SpotifyApi.TrackObjectFull[] = []\n\n    let response\n    const maxRetries = 3\n    let next = null\n    do {\n        let success = true\n        let retries = 0\n        do {\n            try {\n                response = await sp.getMySavedTracks({ limit: 50, offset: offset })\n            } catch (err) {\n                await asyncTimeout(err.getResponseHeader['retry-after'] ? parseInt(err.headers['retry-after'] + 1) * 1000 : RETRY_INTERVAL);\n                success = false\n                retries += 1\n            }\n        } while (success === false && retries < maxRetries)\n\n        // the request was not successfull even after retries\n        if (isUndefined(response)) {\n            next = null\n        }\n        else {\n            offset += limit\n            result.push(...response.items.map((trackObj: SpotifyApi.SavedTrackObject) => trackObj.track))\n            next = response.next\n        }\n    } while (next)\n\n    return result\n}\n\n/**\n * Separates artist IDs from the track objects\n * @param likedSongs list of TrackObjectFull\n * @returns list of IDs of artists in the likedSongs\n */\nconst getArtistsIdsFromLikedSongs = (likedSongs: SpotifyApi.TrackObjectFull[]) => {\n    const likedSongsArtistsIdsNonDistinct =\n        likedSongs.map((objectTrackFull) => objectTrackFull.artists)\n            .reduce((acc, currVal) => acc.concat(currVal), [])\n            .map((artistObjectSimplified) => artistObjectSimplified.id)\n    return [...new Set(likedSongsArtistsIdsNonDistinct)]\n}\n\n/**\n * Fetches the full information about the artists given in parameter\n * @param sp SpotifyWebApiJs object\n * @param allArtistsIds list of IDs of artists to be obtained\n * @returns list of ArtistObjectFull\n */\nexport const getAllArtistsFull = async (sp: SpotifyWebApi.SpotifyWebApiJs, allArtistsIds: string[])\n    : Promise<SpotifyApi.ArtistObjectFull[]> => {\n    const result: SpotifyApi.ArtistObjectFull[] = []\n    const maxRetries = 3\n    let offset = 0\n    let limit = 50\n\n    do {\n        let response\n        let success = true\n        let retries = 0\n        do {\n            try {\n                response = await sp.getArtists(allArtistsIds.slice(offset, offset + limit))\n            } catch (err) {\n                await asyncTimeout(err.getResponseHeader['retry-after'] ? parseInt(err.headers['retry-after'] + 1) * 1000 : RETRY_INTERVAL);\n                success = false\n                retries += 1\n            }\n        } while (success === false && retries < maxRetries)\n\n        if (isUndefined(response)) {\n            throw new Error(\"Unable to load artists.\")\n        } else {\n            result.push(...response.artists)\n            offset += limit\n        }\n\n    } while (offset < allArtistsIds.length)\n\n    return result\n}\n\n/**\n * Creates Artist Dictionary: [artistId]:ArtistFull\n * @param artistsFull ArtistObjectFull objects\n * @param relatedArtistsFinal related artists corresponding to the artistsFull list\n * @param followedArtistsIdsSet IDs of artists that are followed by the logged-in user\n * @param likedSongs songs liked by the logged-in user\n */\nconst createArtistDictWithFullInformation = (\n    artistsFull: SpotifyApi.ArtistObjectFull[],\n    relatedArtistsFinal: string[][],\n    followedArtistsIdsSet: Set<string>,\n    likedSongs: SpotifyApi.TrackObjectFull[]\n): StringDict<ArtistFull> => {\n    if (artistsFull.length !== relatedArtistsFinal.length) {\n        console.debug('ERROR: NOT EVERY ARTIST HAS RELATED ARTISTS')\n        return {}\n    }\n\n    // add every artists to the dictionary\n    const dictToReturn: StringDict<ArtistFull> = {}\n    for (let i = 0; i < artistsFull.length; i++) {\n        const artist = artistsFull[i];\n        const artistImage = artist.images && artist.images.length > 0 ? artist.images[artist.images.length - 1].url : ''\n        const isFollowed = followedArtistsIdsSet.has(artist.id)\n\n        const popularity = artist.popularity\n        const followedScore = isFollowed ? isFollowedConst : 0\n\n        dictToReturn[artist.id] = {\n            genres: artist.genres,\n            id: artist.id,\n            image: artistImage,\n            isFollowed: isFollowed,\n            likedSongs: [],\n            name: artist.name,\n            relatedArtistsIds: relatedArtistsFinal[i],\n            score: popularity * spotifyPopularityConst + followedScore\n        }\n    }\n\n    // add liked songs information to the artists\n    for (let i = 0; i < likedSongs.length; i++) {\n        const song = likedSongs[i];\n        for (let j = 0; j < song.artists.length; j++) {\n            const songArtist = song.artists[j]\n            if (songArtist.id in dictToReturn) {\n                dictToReturn[songArtist.id].likedSongs.push({\n                    artistsIds: song.artists.map(simplArtist => simplArtist.id),\n                    externalUrl: song.external_urls.spotify,\n                    name: song.name,\n                    id: song.id,\n                    previewLink: song.preview_url\n                })\n            }\n        }\n    }\n\n    // recomputed artists' score\n    for (let key in dictToReturn) {\n        const art = dictToReturn[key]\n        dictToReturn[key].score += art.likedSongs.length * likedSongConst\n    }\n\n    return dictToReturn\n}\n\nconst dictArtistFullToReduced =\n    (artistsDictFull: StringDict<ArtistFull>): StringDict<ArtistReduced> => {\n        const artistsDictReduced: StringDict<ArtistReduced> = {}\n        for (let key in artistsDictFull) {\n            const artFull = artistsDictFull[key]\n            artistsDictReduced[key] = {\n                id: artFull.id,\n                relatedArtistsIds: artFull.relatedArtistsIds,\n                genres: artFull.genres\n            }\n        }\n        return artistsDictReduced\n    }\n\nconst emptyGraph = (): Graph => {\n    return { clusters: [], clusterEdges: [], artistEdges: [], clusterSquares: [], artistDict: {} }\n}\n\n/**\n * Fetches all the necessary graph data.\n * @param accessToken Spotify access token\n * @param sp SpotifyWebApiJs object\n * @param setGraphLoadingMessageFunction callback informing about the loading\n * @param setGraphLoadingProgress callback informing about the progress\n * @param setGraphLoadingError callback informing about errors\n */\nexport const fetchAllDataFromSpotify = async (\n    accessToken: string,\n    sp: SpotifyWebApi.SpotifyWebApiJs,\n    setGraphLoadingMessageFunction: Function,\n    setGraphLoadingProgress: Function,\n    setGraphLoadingError: Function\n): Promise<Graph> => {\n    /*\n    1) REQ - liked songs\n    2) artists from liked songs\n    3) REQ - followed artists\n    4) concat from_liked and followed_artists\n    5) REQ - get all artists full objects\n    6) REQ - get related artists of concatenated\n    7) make a dict, {artistsId: artist} - where artist is full artist object (or our Artist type)\n    8) add additional info to the artists:\n        a)OK for every liked song - add to dict the songs\n        b)OK is artist followed?\n        c) calculate artist score\n        d)OK related artists ids (for future work)\n    */\n\n    if (!!!accessToken) return emptyGraph()\n\n    sp.setAccessToken(accessToken)\n\n    // 1) get liked songs\n    const likedSongs = await getLikedSongs(sp)\n\n    setGraphLoadingMessageFunction(\"Getting your liked songs from Spotify...\")\n    console.debug('liked songs: ', likedSongs)\n\n    // 2) artists from liked songs\n    const likedSongsArtistsIds = getArtistsIdsFromLikedSongs(likedSongs)\n    console.debug('liked songs artists ids: ', likedSongsArtistsIds)\n\n    // 3) followed artists\n    setGraphLoadingMessageFunction(\"Getting the artists you follow from Spotify...\")\n    const followedArtistsIds = await getFollowedArtistsIds(sp)\n    console.debug('followed artists ids: ', followedArtistsIds)\n\n    // 4) concat from_liked and followed_artists\n    const allArtistsIds = [...new Set(likedSongsArtistsIds.concat(followedArtistsIds))]\n    // const allArtistsIds = [...new Set(followedArtistsIds)] // debug option for less ids...\n    console.debug('all artists ids: ', allArtistsIds)\n\n    if (allArtistsIds.length < 1) {\n        setGraphLoadingError(\"Your graph is empty, we have nothing to show to you\")\n        return emptyGraph()\n    }\n\n    // 5) get all artists full objects\n    setGraphLoadingMessageFunction(\"Getting information about all the artists you are interested it...\")\n    const artistsFull = await Promise.resolve(getAllArtistsFull(sp, allArtistsIds))\n    console.debug('artists full: ', artistsFull);\n\n    // 6) get related artists of concatenated\n    const relatedArtistsStorageName = \"relatedArtists\"\n    // localStorage.setItem(relatedArtistsStorageName, JSON.stringify({})) // ONLY FOR DEBUGGING\n    const storageRelatedArtistsValue = localStorage.getItem(relatedArtistsStorageName)\n\n    let alreadyLoadedRelatedArtists = {}\n    if (storageRelatedArtistsValue === null) {\n\n    }\n    else {\n        try {\n            alreadyLoadedRelatedArtists = JSON.parse(storageRelatedArtistsValue)\n        } catch {\n            alreadyLoadedRelatedArtists = {}\n        }\n\n        if (alreadyLoadedRelatedArtists === null) {\n            alreadyLoadedRelatedArtists = {}\n        }\n    }\n\n\n    setGraphLoadingMessageFunction(\"Getting information about the related artists of all of your favourite artists... \\n This might take a while :(\")\n    // const relatedArtistsFinal = await Promise.resolve(getRelatedArtists(sp, allArtistsIds, 0, alreadyLoadedRelatedArtists, setGraphLoadingProgress))\n    const relatedArtistsFinal = await getAllRelatedArtists(sp, allArtistsIds, alreadyLoadedRelatedArtists, setGraphLoadingProgress)\n    localStorage.setItem(relatedArtistsStorageName, JSON.stringify(alreadyLoadedRelatedArtists))\n    console.debug('related artists final', relatedArtistsFinal)\n\n    // 7,8) make a dict, add aditional info\n    const artistDict = createArtistDictWithFullInformation(\n        artistsFull,\n        relatedArtistsFinal,\n        new Set(followedArtistsIds),\n        likedSongs\n    )\n    console.debug('artist dict', artistDict)\n\n    const csfrtoken = getCookie('csrftoken')\n\n    setGraphLoadingMessageFunction(\"We have all the data we need, now computing the graph!\")\n\n    let calculateGraphLink = process.env.NODE_ENV === \"production\" ? process.env.REACT_APP_PROD_BACKEND_URL_CALCULATE_GRAPH : process.env.REACT_APP_DEV_BACKEND_URL_CALCULATE_GRAPH\n    if (isUndefined(calculateGraphLink)) return emptyGraph()\n\n    let jsonReponse: any = {}\n    try {\n        const fetchReponse = await fetch(calculateGraphLink, {\n            method: 'POST',\n            body: JSON.stringify(dictArtistFullToReduced(artistDict)),\n            headers: {\n                'Content-Type': 'application/json',\n                'X-CSRFToken': csfrtoken,\n                // 'X-Api-Key': accessToken\n            }\n        })\n        if (fetchReponse.ok) {\n            jsonReponse = await fetchReponse.json()\n        } else {\n            throw new Error(fetchReponse.status + '.  ' + fetchReponse.statusText + '.  ' + await fetchReponse.text())\n        }\n    } catch (requestError) {\n        setGraphLoadingError(requestError)\n        throw requestError\n    }\n    \n    console.debug(jsonReponse)\n\n    const artistEdges = parseArtistEdges(jsonReponse.artistEdges)\n\n    const clusters = parseClusters(artistDict, jsonReponse.clusters)\n\n    const clusterEdges = parseClusterEdges(jsonReponse.clusterEdges)\n\n    const clusterSquares = processClusterPositions(jsonReponse.clusterSquares)\n\n    const g = new Promise<Graph>(resolve => resolve({\n        artistEdges: artistEdges,\n        clusters: clusters,\n        clusterEdges: clusterEdges,\n        clusterSquares: clusterSquares,\n        artistDict: artistDict,\n    }\n    ))\n\n    console.debug('graph from spotify fetch:', await g)\n    return g\n}\n","import { ThunkAction } from 'redux-thunk'\nimport SpotifyWebApi from 'spotify-web-api-js'\nimport * as t from 'io-ts'\n\nfunction optional<RT extends t.Any>(\n    type: RT,\n    name: string = `${type.name} | undefined`\n): t.UnionType<\n    [RT, t.UndefinedType],\n    t.TypeOf<RT> | undefined,\n    t.OutputOf<RT> | undefined,\n    t.InputOf<RT> | undefined\n> {\n    return t.union<[RT, t.UndefinedType]>([type, t.undefined], name);\n}\n\nexport type StringDict<T> = {\n    [id: string]: T\n}\n\nexport type NumberDict<T> = {\n    [id: number]: T\n}\n\n\nexport const PositionType = t.type({\n    x: t.number,\n    y: t.number\n})\nexport type Position = t.TypeOf<typeof PositionType>\n\nexport const SongFullType = t.type({\n    artistsIds: t.array(t.string),\n    externalUrl: t.string,\n    id: t.string,\n    name: t.string,\n    previewLink: t.union([t.string, t.null])\n})\nexport type SongFull = t.TypeOf<typeof SongFullType>\n\nexport const SongReducedType = t.type({\n    id: t.string,\n    name: t.string\n})\nexport type SongReduced = t.TypeOf<typeof SongReducedType>\n\nexport const ArtistFullType = t.type({\n    genres: t.array(t.string),\n    id: t.string,\n    image: t.string,\n    isFollowed: t.boolean,\n    likedSongs: t.array(SongFullType),\n    name: t.string,\n    relatedArtistsIds: t.array(t.string),\n    score: t.number,\n})\nexport type ArtistFull = t.TypeOf<typeof ArtistFullType>\n\nexport const ArtistReducedType = t.type({\n    genres: t.array(t.string),\n    id: t.string,\n    relatedArtistsIds: t.array(t.string)\n})\nexport type ArtistReduced = t.TypeOf<typeof ArtistReducedType>\n\nexport const ArtistSimplifiedType = t.type({\n    id: t.string,\n    name: t.string\n})\nexport type ArtistSimplified = t.TypeOf<typeof ArtistSimplifiedType>\n\nexport const ArtistEdgeType = t.type({\n    id1: t.string,\n    id2: t.string,\n    weight: t.number\n})\nexport type ArtistEdge = t.TypeOf<typeof ArtistEdgeType>\n\nexport const ClusterType = t.type({\n    id: t.string,\n    genres: t.array(t.string),\n    artistsIds: t.array(t.string),\n    artistsPositions: t.dictionary(t.string, PositionType),\n    country: optional(t.string)\n})\nexport type Cluster = t.TypeOf<typeof ClusterType>\n\nexport const ClusterEdgeType = t.type({\n    id1: t.string,\n    id2: t.string,\n    weight: t.number,\n})\nexport type ClusterEdge = t.TypeOf<typeof ClusterEdgeType>\n\nexport type ClusterSquare = {\n    [clusterId: string]: Position\n}\n\nexport const GraphType = t.type({\n    clusters: t.array(ClusterType),\n    clusterEdges: t.array(ClusterEdgeType),\n    artistDict: t.dictionary(t.string, ArtistFullType),\n    artistEdges: t.array(ArtistEdgeType),\n    clusterSquares: t.array(t.dictionary(t.string, PositionType))\n})\nexport type Graph = t.TypeOf<typeof GraphType>\n\nexport interface ChosenArtistData {\n    notLikedSongs: SongFull[]\n    likedSongs: SongFull[]\n}\n\nexport interface State {\n    chosenCluster?: Cluster\n\n    chosenArtist?: ArtistFull\n    chosenArtistData?: ChosenArtistData\n    chosenArtistError?: string\n    chosenArtistLoading: boolean\n\n    graph: Graph\n\n    // access variables\n    userLoggedIn: boolean\n    accessToken?: string\n\n    // the song being played\n    songToPlay?: SongFull\n    nonFavouriteArtistDict: StringDict<ArtistSimplified>\n\n    // the state indicating the graph loading process\n    graphLoaded: boolean\n    graphLoading: boolean\n    \n    isGraphLoadingError: boolean\n    graphLoadingErrorMessage?: string\n\n    graphLoadingMessage: string\n    graphLoadingRelatedArtistsProgress: number\n\n    isGraphFromFileLoaded: boolean\n\n    // prepared spotify web api for requests:\n    spotifyWebApiObject: SpotifyWebApi.SpotifyWebApiJs\n\n    // player state\n    paused: boolean\n}\n\nexport interface ActionWrapper<Payload = undefined> {\n    type: string\n    payload?: Payload\n    reducer: (state: State) => State\n}\n\nexport type ThunkActionWrapper<T> = ThunkAction<Promise<T>, State, {}, ActionWrapper<any>>\n","import { produce } from 'immer'\nimport { ActionWrapper, ThunkActionWrapper, State, ArtistFull, Cluster, Graph, SongFull, ChosenArtistData, ArtistSimplified } from './types'\nimport SpotifyWebApi from 'spotify-web-api-js'\nimport { isUndefined } from 'util'\nimport { fetchAllDataFromSpotify, songFromJSONData } from '../methods/spotify-methods'\nimport { isRight } from 'fp-ts/lib/Either'\nimport { GraphType } from '../store/types'\n// import { PathReporter } from 'io-ts/lib/PathReporter'\n\nexport const setAccessToken = (accessToken: string): ActionWrapper<string> => ({\n    type: 'SET_ACCESS_TOKEN',\n    payload: accessToken,\n    reducer: produce((state: State) => {\n        state.accessToken = accessToken\n        state.userLoggedIn = true\n    })\n})\n\nexport const setUserLoggedIn = (): ActionWrapper<void> => ({\n    type: 'LOG_IN',\n    reducer: produce((state: State) => {\n        state.userLoggedIn = true\n    })\n})\n\nexport const logOut = (): ActionWrapper<void> => ({\n    type: 'LOG_OUT',\n    reducer: produce((state: State) => {\n        state.accessToken = undefined\n        state.userLoggedIn = false\n    })\n})\n\nexport const setChosenArtist = (artist: ArtistFull): ActionWrapper<ArtistFull> => ({\n    type: 'SET_CHOSEN_ARTIST',\n    payload: artist,\n    reducer: produce((state: State) => {\n        state.chosenArtist = artist\n    })\n})\n\nexport const setChosenCluster = (cluster: Cluster): ActionWrapper<Cluster> => ({\n    type: 'SET_CHOSEN_CLUSTER',\n    payload: cluster,\n    reducer: produce((state: State) => {\n        state.chosenCluster = cluster\n    })\n})\n\nexport const clearChosenClusterAndArtist = (): ActionWrapper<void> => ({\n    type: 'CLEAR_CHOSEN_CLUSTER_ARTIST',\n    reducer: produce((state: State) => {\n        state.chosenCluster = undefined\n        state.chosenArtist = undefined\n    })\n})\n\nexport const closeChosenClusterGraph = (): ActionWrapper<void> => ({\n    type: 'CLOSE_CHOSEN_CLUSTER_GRAPH',\n    reducer: produce((state: State) => {\n        state.chosenCluster = undefined\n    })\n})\n\nexport const closeChosenArtist = (): ActionWrapper<void> => ({\n    type: 'CLOSE_CHOSEN_ARTIST',\n    reducer: produce((state: State) => {\n        state.chosenArtist = undefined\n    })\n})\n\nexport const setGraph = (graph: Graph): ActionWrapper<Graph> => ({\n    type: 'SET_GRAPH',\n    payload: graph,\n    reducer: produce((state: State) => {\n        state.graph = graph\n    })\n})\n\nexport const setGraphArtists = (artists: ArtistFull[]): ActionWrapper<ArtistFull[]> => ({\n    type: 'SET_GRAPH_ARTISTS',\n    payload: artists,\n    reducer: produce((state: State) => {\n        state.graphLoading = false\n        state.graphLoaded = true\n    })\n})\n\nexport const graphLoading = (): ActionWrapper<void> => ({\n    type: 'GRAPH_LOADING',\n    reducer: produce((state: State) => {\n        state.graphLoading = true\n    })\n})\n\nexport const setGraphLoadingMessage = (message: string): ActionWrapper<string> => ({\n    type: 'SET_GRAPH_LOADING_MESSAGE',\n    reducer: produce((state: State) => {\n        state.graphLoadingMessage = message\n    })\n})\n\nexport const setGraphLoadingErrorMessage = (errorMessage: string): ActionWrapper<string> => ({\n    type: 'SET_GRAPH_LOADING_ERROR_MESSAGE',\n    reducer: produce((state: State) => {\n        state.graphLoadingErrorMessage = errorMessage\n    })\n})\n\nexport const setGraphLoadingProgress = (progress: number): ActionWrapper<number> => ({\n    type: 'SET_GRAPH_LOADING_MESSAGE',\n    reducer: produce((state: State) => {\n        state.graphLoadingRelatedArtistsProgress = progress\n    })\n})\n\nexport const graphLoadingError = (): ActionWrapper<void> => ({\n    type: 'GRAPH_LOADING_ERROR',\n    reducer: produce((state: State) => {\n        state.graphLoading = false\n        state.isGraphLoadingError = true\n    })\n})\n\nexport const graphLoadingSuccess = (): ActionWrapper<void> => ({\n    type: 'GRAPH_LOADING_SUCCESS',\n    reducer: produce((state: State) => {\n        state.graphLoading = false\n        state.graphLoaded = true\n        state.isGraphLoadingError = false\n    })\n})\n\nexport const setChosenArtistError = (error: string): ActionWrapper<string> => ({\n    type: 'SET_CHOSEN_ARTIST_ERROR',\n    payload: error,\n    reducer: produce((state: State) => {\n        state.chosenArtistError = error\n    })\n})\n\nexport const setChosenArtistLoading = (loading: boolean): ActionWrapper<boolean> => ({\n    type: 'SET_CHOSEN_ARTIST_LOADING',\n    payload: loading,\n    reducer: produce((state: State) => {\n        state.chosenArtistLoading = loading\n    })\n})\n\nexport const setChosenArtistData = (artistData: ChosenArtistData, chosenArtist: ArtistFull): ActionWrapper<ChosenArtistData> => ({\n    type: 'SET_CHOSEN_ARTIST_DATA',\n    payload: artistData,\n    reducer: produce((state: State) => {\n        state.chosenArtistData = artistData\n        state.chosenArtist = chosenArtist\n    })\n})\n\nexport const setSongToPlay = (song: SongFull): ActionWrapper<SongFull> => ({\n    type: 'SET_SONG_TO_PLAY',\n    payload: song,\n    reducer: produce((state: State) => {\n        if (!!!state.songToPlay || state.songToPlay.id !== song.id) {\n            state.songToPlay = song\n            state.paused = false\n        }\n    })\n})\n\nexport const setPaused = (paused: boolean): ActionWrapper<boolean> => ({\n    type: 'SET_PAUSED',\n    payload: paused,\n    reducer: produce((state: State) => {\n        state.paused = paused\n    })\n})\n\nexport const setSpotifyApi = (accessToken: string): ActionWrapper<string> => ({\n    type: 'SET_SPOTIFY_API',\n    payload: accessToken,\n    reducer: produce((state: State) => {\n        try {\n            const sApi = state.spotifyWebApiObject\n            sApi.setAccessToken(accessToken)\n            state.spotifyWebApiObject = sApi\n        } catch (error) {\n            console.debug(error)\n        }\n        console.debug('SET SPOTIFY API')\n    })\n})\n\n/**\n * Updates not favourite artists dictionary\n * @param artistsToUpdate list of artists to add \n */\nexport const updateNotFavouriteArtists = (artistsToUpdate: ArtistSimplified[]): ActionWrapper<any> => ({\n    type: 'UPDATE_NOT_FAVOURITE_ARTISTS',\n    payload: artistsToUpdate,\n    reducer: produce((state: State) => {\n        const currentNotFavouriteDict = state.nonFavouriteArtistDict\n        const favouriteDict = state.graph.artistDict\n\n        for (let i = 0; i < artistsToUpdate.length; i++) {\n            const element = artistsToUpdate[i];\n            if (element.id in favouriteDict) {\n                // don't add\n            }\n            else {\n                currentNotFavouriteDict[element.id] = element\n            }\n        }\n        state.nonFavouriteArtistDict = currentNotFavouriteDict\n    })\n})\n\nconst artistsFromSongJSON = (element: SpotifyApi.TrackObjectFull, currentArtistId: string): ArtistSimplified[] => {\n    const toRet: ArtistSimplified[] = element.artists.reduce((result: ArtistSimplified[], a: SpotifyApi.ArtistObjectSimplified) => {\n        if (a.id !== currentArtistId) result.push({ id: a.id, name: a.name })\n        return result\n    }, [])\n    return toRet\n}\n\n/**\n * Sets a chosen artist and prepares his songs - liked by the user and not liked by the user.\n * @param chosenArtist `ArtistFull` object \n * @param accessToken Spotify API access token\n */\nexport const setChosenArtistDataAll = (\n    chosenArtist: ArtistFull,\n    accessToken: string\n): ThunkActionWrapper<void> => async (dispatch): Promise<void> => {\n    if (isUndefined(accessToken) || accessToken === null || accessToken === \"\") {\n        dispatch(setChosenArtistError('The token was not loaded, cannot obtain the artist data.'))\n        return\n    }\n\n    dispatch(setChosenArtist(chosenArtist))\n    dispatch(setChosenArtistLoading(true))\n    let s = new SpotifyWebApi();\n    s.setAccessToken(accessToken)\n\n    const likedSongs: SongFull[] = []\n    const notLikedSongs: SongFull[] = []\n    let artistToUpdate: ArtistSimplified[] = []\n\n    const areSongsEqual = (s1: SongFull, s2: SongFull) => {\n        return (s1.id === s2.id || s1.name === s2.name)\n    }\n\n    s.getArtistTopTracks(chosenArtist.id, 'CZ')\n        .then(topTracks => {\n            for (let i = 0; i < topTracks.tracks.length; i++) {\n                const currArtistToUpdate = artistsFromSongJSON(topTracks.tracks[i], chosenArtist.id)\n                artistToUpdate = artistToUpdate.concat(currArtistToUpdate)\n                const songToCheck = songFromJSONData(topTracks.tracks[i])\n                const indexOfLiked = chosenArtist.likedSongs.findIndex(likedSong => areSongsEqual(songToCheck, likedSong))\n\n                if (indexOfLiked === -1) {\n                    notLikedSongs.push(songToCheck)\n                }\n                else {\n                    if (songToCheck.previewLink === \"\") {\n                        songToCheck.previewLink = chosenArtist.likedSongs[indexOfLiked].previewLink\n                    }\n                    likedSongs.push(songToCheck)\n                }\n            }\n\n            for (let i = 0; i < chosenArtist.likedSongs.length; i++) {\n                const element = chosenArtist.likedSongs[i];\n                const indexOfLiked = likedSongs.findIndex(likedSong => areSongsEqual(element, likedSong))\n                if (indexOfLiked === -1) {\n                    likedSongs.push(element)\n                }\n\n            }\n\n            dispatch(updateNotFavouriteArtists(artistToUpdate))\n            dispatch(setChosenArtistData({ likedSongs: likedSongs, notLikedSongs: notLikedSongs }, chosenArtist))\n        })\n        .catch((error: string) => {\n            console.debug(error)\n            dispatch(setChosenArtistError('During the artist data fetching, the following error occured:' + error))\n        })\n        .finally(() => {\n            dispatch(setChosenArtistLoading(false))\n        })\n}\n\n/**\n * Load the data from backend\n * @param accessToken Spotify API access token\n * @param sp `SpotifyWebApiJs` object\n * @param callback callback to be called after the data is loaded (necessary to DraggableCanvas graph displaying)\n */\nexport const loadGraph = (accessToken: string, sp: SpotifyWebApi.SpotifyWebApiJs, callback: Function): ThunkActionWrapper<void> =>\n    async (dispatch): Promise<void> => {\n        dispatch(graphLoading())\n\n        fetchAllDataFromSpotify(\n            accessToken, sp,\n            (message: string) => { dispatch(setGraphLoadingMessage(message)) },\n            (progress: number) => { dispatch(setGraphLoadingProgress(progress)) },\n            (errorMessage: string) => { dispatch(setGraphLoadingErrorMessage(errorMessage)) }\n        )\n            .then(g => dispatch(setGraph(g)))\n            .then(() => callback())\n            .then(() => dispatch(graphLoadingSuccess()))\n            .catch((error) => {\n                console.debug(error)\n                dispatch(graphLoadingError())\n            })\n    }\n\nexport const graphFromFileIsLoaded = (isLoaded: boolean): ActionWrapper<boolean> => ({\n    type: 'GRAPH_FROM_FILE_IS_LOADED',\n    payload: isLoaded,\n    reducer: produce((state: State) => {\n        state.isGraphFromFileLoaded = isLoaded\n    })\n})\n\n/**\n * Action to load graph from file.\n * @param jsonToParse graph obtained from the file\n */\nexport const loadGraphFromFile = (jsonToParse: Graph): ThunkActionWrapper<void> =>\n    async (dispatch): Promise<void> => {\n        // type check\n        const result = GraphType.decode(jsonToParse)\n        if (!!!isRight(result)) {\n            // alert(\"SORRY, THE FILE IS CORRUPTED!\\n\\n\" + PathReporter.report(result))\n            alert(\"SORRY, THE FILE IS CORRUPTED!\")\n            return\n        }\n\n        for (let i = 0; i < jsonToParse.clusters.length; i++) {\n            const cluster = jsonToParse.clusters[i];\n            if (isUndefined(cluster.artistsIds) || cluster.artistsIds.length === 0) {\n                cluster.artistsIds = Object.keys(cluster.artistsPositions)\n            }\n        }\n\n        await Promise.resolve(\n            dispatch(clearChosenClusterAndArtist())\n        )\n            .then(() => dispatch(graphLoading()))\n            .then(() => dispatch(setGraph(jsonToParse)))\n            .then(() => dispatch(graphFromFileIsLoaded(true)))\n            .then(() => dispatch(graphLoadingSuccess()))\n    }\n","/* eslint-disable no-extra-label */\n\nimport { ClusterSquare, StringDict, Position } from '../store/types'\n\ninterface Rectangle {\n    left: number\n    top: number\n    width: number\n    height: number\n}\n\ninterface ScreenParams {\n    width: number\n    height: number\n    clusterWidth: number\n    clusterHeigth: number\n}\n\n/**\n * Calculates positions of the cluster from the given precomputed positions from backend.\n * \n * @param width Graph space width\n * @param height Graph space height\n * @param clusterWidth Width of a cluster\n * @param clusterHeigth Width of a cluster\n * @param clusterSquares Cluster squares as given from the backend\n * \n * @returns Dictionary of positions: [clusterId]:Position\n */\nexport const computeClusterPositions =\n    (width: number, height: number, clusterWidth: number, clusterHeigth: number, clusterSquares: ClusterSquare[]):\n        StringDict<Position> => {\n        const toRet: StringDict<Position> = {} // prepare dict for final positions\n        width -= 15 // some distance from the edge\n\n        const oneClusterComponents = []\n        const twoClusterComponents = []\n        const threeClusterComponents = []\n        const bigComponent = []\n\n        for (let i = 0; i < clusterSquares.length; i++) {\n            const square = clusterSquares[i];\n\n            const clustersInSquares = Object.keys(square).length\n            if (clustersInSquares === 1) {\n                oneClusterComponents.push(square)\n            }\n            else if (clustersInSquares === 2) {\n                twoClusterComponents.push(square)\n            }\n            else if (clustersInSquares === 3) {\n                threeClusterComponents.push(square)\n            }\n            else {\n                bigComponent.push(square)\n            }\n        }\n\n        const clusterPadding = 25\n        const screenParams: ScreenParams = { width: width, height: height, clusterWidth: clusterWidth + clusterPadding, clusterHeigth: clusterHeigth + 10 }\n        getBigComponentsPositions(bigComponent, toRet, screenParams)\n        const currentHeight = computeHeigthFromPositions(toRet, clusterHeigth)\n        getRestComponentsPositions(toRet, oneClusterComponents, twoClusterComponents, threeClusterComponents, screenParams, currentHeight)\n        return toRet\n    }\n\n/**\n * The big components (bigger than 3 clusters) are allowed to occupy the main space.\n * @param bigClusterSquares ClusterSquares as received from the backend with more than 3 clusters\n * @param finalPositions Dictionary with final positions to be changed! \n * @param screenParams Screen parameters\n */\nconst getBigComponentsPositions = (\n    bigClusterSquares: ClusterSquare[],\n    finalPositions: StringDict<Position>,\n    screenParams: ScreenParams\n) => {\n    for (let i = 0; i < bigClusterSquares.length; i++) {\n        const square = bigClusterSquares[i];\n        for (let clusterId in square) {\n            const clusterPosition = square[clusterId]\n\n            const newX = clusterPosition.x * (screenParams.width - screenParams.clusterWidth - 40)\n            const newY = clusterPosition.y * screenParams.height\n            finalPositions[clusterId] = { x: newX, y: newY }\n        }\n    }\n}\n\n/**\n * Fills free space that was not occupied by big components yet\n * \n * @param clusterInComponent Number of clusters in the components (1/2/3)\n * @param clusterComponents list of components with `clusterInComponent` clusters to be places\n * @param freeRectMatrix Binary matrix - 1 free space, 0 already filled space\n * @param possibleRectanglePositions Rectangles that are empty\n * @param notUsedClusterComponents Components that were not places yes -> will be changed\n * @param finalPositions Dictionary with final positions to be changed! \n */\nconst tryFillFreeSpace = (\n    clusterInComponent: number,\n    clusterComponents: ClusterSquare[],\n    freeRectMatrix: number[][],\n    possibleRectanglePositions: Rectangle[],\n    notUsedClusterComponents: ClusterSquare[],\n    finalPositions: StringDict<Position>,\n) => {\n    if (clusterInComponent !== 1 && clusterInComponent !== 2 && clusterInComponent !== 3 && freeRectMatrix.length <= 0) {\n    }\n\n    const freeRectMatrixRows = freeRectMatrix.length\n    const freeRectMatrixCols = freeRectMatrix[0].length\n\n    wholeLoop:\n    for (let i = 0; i < clusterComponents.length; i++) {\n        let foundSomeCoords = false\n        const clusterComponent = clusterComponents[i];\n\n        rowLoop:\n        for (let row = 0; row < freeRectMatrix.length; row++) {\n\n            // columnLoop:\n            for (let col = 0; col < freeRectMatrix[row].length; col++) {\n\n                let coordCombinations: number[][][] = []\n                if (clusterInComponent === 1) {\n                    coordCombinations = [\n                        [[row, col]]\n                    ]\n                }\n                else if (clusterInComponent === 2) {\n                    coordCombinations = [\n                        [[row, col], [row, col + 1]],\n                        [[row, col], [row + 1, col]],\n                    ]\n                }\n                else if (clusterInComponent === 3) {\n                    coordCombinations = [\n                        [[row, col], [row, col + 1], [row + 1, col + 1]],\n                        [[row, col], [row + 1, col], [row + 1, col + 1]],\n                        [[row, col], [row, col + 1], [row + 1, col]],\n                        [[row + 1, col + 1], [row, col + 1], [row + 1, col]],\n                    ]\n                }\n\n                for (let coordIndex = 0; coordIndex < coordCombinations.length; coordIndex++) {\n                    const coordArray = coordCombinations[coordIndex]\n                    const isLegit = coordArray.every(([rIndex, cIndex]) => {\n                        return rIndex < freeRectMatrixRows && cIndex < freeRectMatrixCols && freeRectMatrix[rIndex][cIndex] !== 0\n                    })\n                    const clusterIds = Object.keys(clusterComponent);\n                    if (isLegit) {\n\n                        for (let k = 0; k < clusterInComponent; k++) {\n                            const rect = possibleRectanglePositions[freeRectMatrix[coordArray[k][0]][coordArray[k][1]] - 1]\n                            finalPositions[clusterIds[k]] = { x: rect.left, y: rect.top }\n                            freeRectMatrix[coordArray[k][0]][coordArray[k][1]] = 0\n                        }\n\n                        foundSomeCoords = true\n                        break rowLoop\n                    }\n                    else { }\n                }\n            }\n        }\n\n        if (!foundSomeCoords) {\n            for (let notUsedIndex = i; notUsedIndex < clusterComponents.length; notUsedIndex++) {\n                notUsedClusterComponents.push(clusterComponents[notUsedIndex])\n            }\n            break wholeLoop\n        }\n    }\n}\n\n/**\n * Places all small components.\n * \n * @param finalPositions Dictionary with final positions to be changed! \n * @param oneClusterComponents Components with one cluster\n * @param twoClusterComponents Components with two clusters\n * @param threeClusterComponents Components with three clusters\n * @param screenParams Parameters of the screen\n * @param currentHeight Current height after big components were already places\n */\nconst getRestComponentsPositions = (\n    finalPositions: StringDict<Position>,\n    oneClusterComponents: ClusterSquare[],\n    twoClusterComponents: ClusterSquare[],\n    threeClusterComponents: ClusterSquare[],\n    screenParams: ScreenParams,\n    currentHeight: number\n) => {\n    // get the empty rectangle to fill with small pieces..\n\n    let rectangles: Rectangle[] = []\n    for (let key in finalPositions) {\n        let pos = finalPositions[key]\n        rectangles.push({ left: pos.x, top: pos.y, width: screenParams.clusterWidth, height: screenParams.clusterHeigth })\n    }\n    const { possibleRectanglePositions, freeRectMatrix } = getPossibleFreePositions(\n        screenParams.width, currentHeight, screenParams.clusterWidth + 30, screenParams.clusterHeigth + 30, rectangles);\n\n    const notUsedThreeClusterComponents: ClusterSquare[] = []\n    const notUsedTwoClusterComponents: ClusterSquare[] = []\n    const notUsedOneClusterComponents: ClusterSquare[] = []\n\n    tryFillFreeSpace(3, threeClusterComponents, freeRectMatrix, possibleRectanglePositions, notUsedThreeClusterComponents, finalPositions)\n    tryFillFreeSpace(2, twoClusterComponents, freeRectMatrix, possibleRectanglePositions, notUsedTwoClusterComponents, finalPositions)\n    tryFillFreeSpace(1, oneClusterComponents, freeRectMatrix, possibleRectanglePositions, notUsedOneClusterComponents, finalPositions)\n\n    const newRects: Rectangle[] = []\n\n    let currentY = currentHeight\n    let currentX = 0\n    \n    /* THREE CLUSTERS COMPONENTS */\n    const middleX = screenParams.clusterWidth * 0.7\n    const middleY = screenParams.clusterHeigth * 0.7\n    const circleRadius = screenParams.clusterWidth * 0.7\n    for (let i = 0; i < notUsedThreeClusterComponents.length; i++) {\n        const clusterComponent = notUsedThreeClusterComponents[i];\n        const clusterIds = Object.keys(clusterComponent);\n        const angle = Math.random()\n\n        const coords: number[][] = [\n            [\n                (circleRadius) * (Math.cos(angle * Math.PI)) + middleX + currentX,\n                (circleRadius) * (Math.sin(angle * Math.PI)) + middleY + currentY\n            ],\n            [\n                circleRadius * (Math.cos((angle + 2 / 3) * Math.PI)) + middleX + currentX,\n                circleRadius * (Math.sin((angle + 2 / 3) * Math.PI)) + middleY + currentY\n            ],\n            [\n                circleRadius * (Math.cos((angle + 4 / 3) * Math.PI)) + middleX + currentX,\n                circleRadius * (Math.sin((angle + 4 / 3) * Math.PI)) + middleY + currentY\n            ]\n        ]\n\n        for (let j = 0; j < 3; j++) {\n            finalPositions[clusterIds[j]] = { x: coords[j][0], y: coords[j][1] }\n            newRects.push({ left: coords[j][0], top: coords[j][1], width: screenParams.clusterWidth, height: screenParams.clusterHeigth })\n        }\n\n        const squareChange = circleRadius * 1.7 + screenParams.clusterWidth\n        currentX += squareChange\n        if (currentX + squareChange > screenParams.width) {\n            currentX = 0\n            currentY += squareChange\n        }\n    }\n\n    /* TWO CLUSTERS COMPONENTS */\n    for (let i = 0; i < notUsedTwoClusterComponents.length; i++) {\n        const clusterComponent = notUsedTwoClusterComponents[i];\n        const clusterIds = Object.keys(clusterComponent);\n        const coords: number[][] = [\n            [currentX, currentY],\n            [currentX + circleRadius * 2, currentY],\n        ]\n\n        for (let j = 0; j < 2; j++) {\n            finalPositions[clusterIds[j]] = { x: coords[j][0], y: coords[j][1] }\n            newRects.push({ left: coords[j][0], top: coords[j][1], width: screenParams.clusterWidth, height: screenParams.clusterHeigth })\n        }\n\n        const squareChange = circleRadius * 2 + screenParams.clusterWidth\n        currentX += squareChange\n        if (currentX > screenParams.width - screenParams.clusterWidth) {\n            currentX = 0\n            currentY += screenParams.clusterHeigth + 20\n        }\n    }\n\n    /* ONE CLUSTER COMPONENTS */\n    currentY = currentHeight\n    for (let i = 0; i < notUsedOneClusterComponents.length; i++) {\n        const clusterComponent = notUsedOneClusterComponents[i];\n        const clusterId = Object.keys(clusterComponent)[0];\n        const clusterRect: Rectangle = { top: currentY, left: currentX, width: screenParams.clusterWidth, height: screenParams.clusterHeigth }\n\n        while (hasCollisions(clusterRect, newRects)) {\n            clusterRect.left += screenParams.clusterWidth\n\n            if (clusterRect.left + screenParams.clusterWidth > screenParams.width) {\n                clusterRect.left = 0\n                clusterRect.top += screenParams.clusterHeigth + 20\n            }\n        }\n        finalPositions[clusterId] = { x: clusterRect.left, y: clusterRect.top }\n        currentX = clusterRect.left + screenParams.clusterWidth + 20\n        currentY = clusterRect.top\n        if (currentX + screenParams.clusterWidth > screenParams.width) {\n            currentX = 0\n            currentY += screenParams.clusterHeigth\n        }\n    }\n}\n\n/**\n * Calculates maximal height from the positions.\n * @param positions Positions to be taken into account\n * @param clusterHeigth height of the cluster in pixels\n */\nexport const computeHeigthFromPositions = (\n    positions: StringDict<Position>, clusterHeigth: number\n): number => {\n    let maxY = 0\n    for (let key in positions) {\n        let pos = positions[key]\n        maxY = pos.y > maxY ? pos.y : maxY\n    }\n    return maxY + clusterHeigth\n}\n\n\n/* \n------------------------------------\nThe following methods calculate free positions in the graph space \nafter the big clusters were placed \n------------------------------------\n*/\n\nconst _colliding = (start1: number, end1: number, start2: number, end2: number) => {\n    return start1 < end2 && start2 < end1;\n}\n\nconst areColliding = (rect1: Rectangle, rect2: Rectangle) => {\n    return _colliding(rect1.left, rect1.left + rect1.width, rect2.left, rect2.left + rect2.width)\n        && _colliding(rect1.top, rect1.top + rect1.height, rect2.top, rect2.top + rect2.height);\n}\n\nconst hasCollisions = (rect: Rectangle, rects: Rectangle[]) => {\n    return rects.reduce((res, r) => res || areColliding(r, rect), false);\n}\n\nconst getPossibleFreePositions = (\n    width: number, height: number, clusterWidth: number, clusterHeight: number, rects: Rectangle[]\n): { possibleRectanglePositions: Rectangle[], freeRectMatrix: number[][] } => {\n    const freeRectMatrix: number[][] = []\n    let numberToWidth = Math.floor(width / clusterWidth)\n    let numberToheight = Math.floor(height / clusterHeight)\n\n    numberToWidth = numberToWidth === 0 ? 1 : numberToWidth\n    numberToheight = numberToheight === 0 ? 1 : numberToheight\n\n    const possibleRectanglePositions = []\n    let noRectangles = 0\n    for (let i = 0; i < numberToheight; i++) {\n        freeRectMatrix[i] = []\n        for (let j = 0; j < numberToWidth; j++) {\n            const rect: Rectangle = { top: i * clusterHeight, left: j * clusterWidth, width: clusterWidth, height: clusterHeight }\n            if (hasCollisions(rect, rects)) {\n                freeRectMatrix[i][j] = 0\n            }\n            else {\n                noRectangles += 1\n                freeRectMatrix[i][j] = noRectangles\n                possibleRectanglePositions.push(rect)\n            }\n        }\n    }\n\n    return { possibleRectanglePositions: possibleRectanglePositions, freeRectMatrix: freeRectMatrix }\n}\n","\n/**\n * Receives positions of nodes. Recomputes the coordinates to be working well with \n * svg element in cluster and artist edges.\n * \n * @param x1 X coordinate of first node\n * @param y1 Y coordinate of first node\n * @param x2 X coordinate of second node\n * @param y2 Y coordinate of second node\n * @param thickness thickness of the edge\n */\nexport const computeEdgeCoordinates = (x1: number, y1: number, x2: number, y2: number, thickness: number): \n{ x1fin: number, y1fin: number, x2fin: number, y2fin: number, top: number, left: number, hei: number, wid: number } => {\n\n    let top: number, left: number, wid: number, hei: number\n\n    if (x1 > x2) {\n        left = x2\n        wid = x1 - x2\n    }\n    else {\n        left = x1\n        wid = x2 - x1\n    }\n\n    if (y1 > y2) {\n        top = y2\n        hei = y1 - y2\n    }\n    else {\n        top = y1\n        hei = y2 - y1\n    }\n\n    let x1fin = 0 + thickness\n    let y1fin = hei\n    let x2fin = wid\n    let y2fin = 0 + thickness\n    if ((y1 > y2 && x1 > x2) ||\n        (y1 < y2 && x1 < x2)) {\n        y1fin = 0 + thickness\n        y2fin = hei\n    }\n\n    return { x1fin, y1fin, x2fin, y2fin, top, left, hei, wid }\n}\n","import React from 'react'\nimport { computeEdgeCoordinates } from '../methods/edge-calculation'\n\ninterface ArtistEdgeProps {\n    /** X coordinate of the first artist */\n    x1: number\n    /** Y coordinate of the first artist */\n    y1: number\n    /** X coordinate of the second artist */\n    x2: number\n    /** Y coordinate of the second artist*/\n    y2: number\n    /** Weight of the edge */\n    weigth: number\n    /** Artist element width */\n    artistWidth: number\n    /** Weight of the strongest edge in the Inside cluster graph */\n    maximumEdgeWeigth: number\n}\n\n/** ArtistEdge - edge between artists in the Inside cluster graph */\nexport default class ArtistEdge extends React.Component<ArtistEdgeProps, {}> {\n    render() {\n        const thickness = this.props.weigth * 2\n        const { x1fin, y1fin, x2fin, y2fin, top, left, hei, wid } = computeEdgeCoordinates(\n            this.props.x1, this.props.y1, this.props.x2, this.props.y2, thickness)\n\n        const st: React.CSSProperties = {\n            top: top + 30,\n            left: left + this.props.artistWidth / 2\n        }\n\n        const curvature = 20\n        const edgeColor = `rgb(${2}, ${250}, ${240}, ${this.props.weigth / this.props.maximumEdgeWeigth})`\n\n        return (\n            <svg style={st} className=\"position-absolute\" width={wid + thickness + curvature} height={hei + thickness + curvature}>\n                <path\n                    d={`M ${x1fin},${y1fin} \n                        C ${x1fin + curvature},${y1fin + curvature} ${x2fin + curvature},${y2fin + curvature} ${x2fin},${y2fin}`}\n                    strokeWidth={thickness}\n                    fill=\"none\"\n                    stroke={edgeColor}\n                />\n            </svg>\n        )\n    }\n}\n","\n/** The most commonly used colors in SpotifyGraph */\nconst COLORS = {\n    lightAzureBlue: `rgb(132, 237, 243)`,\n    darkAzureBlue: `rgb(2, 109, 104)`,\n    pink: `rgb(255, 51, 153)`,\n    green: `rgb(0, 204, 0)`,\n    grey: `rgb(191, 191, 191)`,\n    orange: `rgb(242,225,31)`\n}\n\nexport default COLORS;\n","import React from 'react'\nimport Draggable, { DraggableEvent } from 'react-draggable'\nimport CSS from 'csstype'\nimport { connect } from 'react-redux'\n\nimport { State } from '../store/types'\nimport { setChosenArtistDataAll } from '../store/actions'\nimport { ArtistFull } from '../store/types'\nimport COLORS from '../methods/colors'\n\nimport './cluster-node.css'\nimport './artist-node.css'\n\ninterface ArtistNodeProps {\n    /** Artist to be displayed in the node */\n    artist: ArtistFull\n    /** Initial X coordinate */\n    positionX: number\n    /** Initial Y coordinate */\n    positionY: number\n    /** Minimal score for the artist to be shown */\n    minimumScore: number\n    /** ArtistFull object of the chosen artist */\n    chosenArtist?: ArtistFull\n    /** Artist dictionary */\n    artistDict: {[id: string]: ArtistFull}\n    /** Spotify API access token */\n    accessToken?: string\n    /** Callback for position change - needed to inform edges about node position change */\n    positionChangedCallback: Function\n    /** Function to set chosen artist in the State */\n    setChosenArtistDataAllFunc: typeof setChosenArtistDataAll\n}\n\ninterface ArtistNodeState {\n    currentPositionX: number\n    currentPositionY: number\n    dragging: boolean\n}\n\n/**\n * Artist node in the Inside cluster graph \n */\nclass ArtistNode extends React.Component<ArtistNodeProps, ArtistNodeState> {\n    constructor(props: ArtistNodeProps) {\n        super(props);\n        this.state = {\n            currentPositionX: props.positionX,\n            currentPositionY: props.positionY,\n            dragging: false,\n        }\n        this.onDrag = this.onDrag.bind(this)\n        this.onStop = this.onStop.bind(this)\n    }\n\n    onDrag(e: DraggableEvent, ui: any) {\n        e.stopPropagation(); e.preventDefault();\n        this.setState({ dragging: true })\n        const newCurrX = this.state.currentPositionX + ui.deltaX\n        const newCurrY = this.state.currentPositionY + ui.deltaY\n        this.setState({ currentPositionX: newCurrX, currentPositionY: newCurrY })\n        this.props.positionChangedCallback(newCurrX, newCurrY, this.props.artist.id)\n    }\n\n    onStop(e: DraggableEvent) {\n        e.stopPropagation(); e.preventDefault();\n        const dragging = this.state.dragging;\n        this.setState({ dragging: false })\n        if (!dragging) {\n            this.handleClick();\n        }\n    }\n\n    handleClick() {\n        if (this.props.accessToken) {\n            if (this.props.chosenArtist && this.props.chosenArtist.id === this.props.artist.id) {\n                return\n            }\n            else {\n                this.props.setChosenArtistDataAllFunc(this.props.artist, this.props.accessToken);\n            }\n        }\n    }\n\n    render() {\n        let color = COLORS.lightAzureBlue\n        if (this.props.chosenArtist) {\n            if (this.props.chosenArtist.id === this.props.artist.id) {\n                color = COLORS.pink\n            }\n            if (!(this.props.chosenArtist.id in this.props.artistDict)) {\n                if (this.props.chosenArtist.relatedArtistsIds.indexOf(this.props.artist.id) !== -1) {\n                    color = COLORS.orange\n                }\n            }\n            \n        }\n\n        const nodeWidth = 60\n        const nodeHeight = 60\n\n        const artistImageDivStyle: CSS.Properties = {\n            backgroundImage: `url(${this.props.artist.image})`,\n            backgroundSize: `${nodeHeight}px ${nodeWidth}px`,\n            width: `${nodeWidth}px`,\n            height: `${nodeHeight}px`,\n            borderRadius: \"10px\",\n            alignSelf: \"center\"\n        }\n\n        if (this.props.artist.score < this.props.minimumScore) {\n            return <div></div>\n        }\n\n        return (\n            <Draggable\n                key={this.props.artist.id}\n                bounds=\"parent\"\n                defaultPosition={{ x: this.props.positionX, y: this.props.positionY }}\n                onDrag={this.onDrag}\n                onStop={this.onStop}\n            >\n                <div className=\"artist-node-outer-wrapper\">\n                    <div style={{ ...artistImageDivStyle, backgroundColor: COLORS.lightAzureBlue }}>\n                        <div style={artistImageDivStyle} />\n                    </div>\n                    <div className=\"artist-node-artist-name-div\" style={{ backgroundColor: color }}>\n                        {this.props.artist.name}\n                    </div>\n                </div>\n            </Draggable>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        accessToken: state.accessToken,\n        chosenArtist: state.chosenArtist,\n        artistDict: state.graph.artistDict\n    }),\n    (dispatch: any) => ({\n        setChosenArtistDataAllFunc: (chosenArtist: ArtistFull, accessToken: string) => dispatch(setChosenArtistDataAll(chosenArtist, accessToken))\n    })\n)(ArtistNode)\n","import React, { ChangeEvent } from 'react'\nimport { connect } from 'react-redux'\nimport Draggable from 'react-draggable'\nimport { TiArrowMove } from 'react-icons/ti'\nimport { BsQuestion } from 'react-icons/bs'\n\nimport { State, ArtistFull, StringDict } from '../store/types'\nimport { InsideClusterGraph } from './chosen-cluster'\nimport ArtistEdge from './artist-edge'\nimport ArtistNode from './artist-node'\n\nimport './chosen-cluster-graph.css'\n\ninterface ChosenClusterGraphProps {\n    /** Inside cluster graph object containing nodes and edges */\n    graphElements: InsideClusterGraph\n\n    /** Dictionary: [artistId]: artistFullObject */\n    idArtistDict: StringDict<ArtistFull>\n}\n\ninterface SliderLimits {\n    minimum: number\n    maximum: number\n}\n\ninterface ChosenClusterGraphState {\n    /** Width of the div with inside cluster graph */\n    width: number\n    /** Height of the div with inside cluster graph */\n    height: number\n    /** JSX node elements */\n    nodes: JSX.Element[]\n    /** Position of artists in the graph */\n    artistsPositions: { [id: string]: { x: number, y: number } }\n\n    /** current limits of the artist slider */\n    artistsSliderLimits: SliderLimits\n    /** current limits of the edges slider */\n    edgesSliderLimits: SliderLimits\n    /** current value of the artist slider */\n    artistSliderValue: number\n    /** current value of the edges slider */\n    edgesSliderValue: number\n\n    /** is the description shown right now? */\n    descriptionHover: boolean\n\n    /** minimal edge weight for the edge to be shown */\n    minimumEdgeWeight: number\n    /** maximal number of edges to be visualized by default */\n    maximumEdges: number\n}\n\nclass ChosenClusterGraph extends React.Component<ChosenClusterGraphProps, ChosenClusterGraphState> {\n    boxRef: any\n    wrapperRef: any\n\n    constructor(props: ChosenClusterGraphProps) {\n        super(props);\n        const maximumEdges = 400\n        const { artistsSliderLimits, edgesSliderLimits, currSliderValue } = this.getSliderLimits(maximumEdges)\n        this.state = {\n            width: 0, height: 0,\n            nodes: [], artistsPositions: {},\n            artistSliderValue: artistsSliderLimits.minimum,\n            edgesSliderValue: currSliderValue,\n            artistsSliderLimits: artistsSliderLimits,\n            edgesSliderLimits: edgesSliderLimits,\n            descriptionHover: false,\n            minimumEdgeWeight: 0.5,\n            maximumEdges: maximumEdges\n        }\n        this.wrapperRef = React.createRef();\n        this.boxRef = React.createRef();\n\n        this.positionChangedHandler = this.positionChangedHandler.bind(this)\n        this.changeArtistSliderValue = this.changeArtistSliderValue.bind(this)\n        this.changeEdgeSliderValue = this.changeEdgeSliderValue.bind(this)\n    }    \n\n    /**\n     * If a new Inside cluster graph must appear -> create a new graph\n     * \n     * If a slider value is changed -> nodes are created again with new threshold\n     */\n    componentDidUpdate(prevprops: ChosenClusterGraphProps, prevstate: ChosenClusterGraphState) {\n        if (prevprops.graphElements !== this.props.graphElements) {\n            this.prepareAfterGraphDataUpdate()\n        }\n        else if (prevstate.artistSliderValue !== this.state.artistSliderValue) {\n            this.prepareAfterSliderUpdate()\n        }\n    }\n\n    /**\n     * After a component did mount -> create a new graph\n     */\n    componentDidMount() {\n        this.prepareAfterGraphDataUpdate()\n    }\n\n    /**\n     * Create a new graph.\n     */\n    prepareAfterGraphDataUpdate() {\n        const { artistsSliderLimits, edgesSliderLimits, currSliderValue } = this.getSliderLimits(this.state.maximumEdges)\n        this.setState({\n            artistsSliderLimits: artistsSliderLimits,\n            edgesSliderLimits: edgesSliderLimits,\n            artistSliderValue: artistsSliderLimits.minimum,\n            edgesSliderValue: currSliderValue\n        })\n        let width = this.boxRef.current.clientWidth;\n        let height = this.boxRef.current.clientHeight;\n        this.setState({ width: width, height: height })\n        const createdNodes: { nodes: JSX.Element[], positions: {} } = this.createNodes(width, height);\n        this.setState({ nodes: createdNodes.nodes, artistsPositions: createdNodes.positions })\n    }\n\n    /**\n     * Prepare nodes with current positions and new slider value. Sets state - new nodes\n     */\n    prepareAfterSliderUpdate() {\n        const nodes = []\n        for (let i = 0; i < this.props.graphElements.nodes.length; i++) {\n            const elem = this.props.graphElements.nodes[i]\n            nodes.push(\n                <ArtistNode\n                    key={elem.artist.id}\n                    positionChangedCallback={this.positionChangedHandler}\n                    positionX={this.state.artistsPositions[elem.artist.id].x}\n                    positionY={this.state.artistsPositions[elem.artist.id].y}\n                    artist={elem.artist}\n                    minimumScore={this.state.artistSliderValue}\n                />\n            )\n        }\n        this.setState({ nodes: nodes })\n    }\n\n    /**\n     * Newly created Inside cluster graph -> new nodes.\n     * \n     * Creates nodes from the initial positions in props.graphElements\n     * \n     * @param wid Inside cluster graph width\n     * @param hei Inside cluster graph height\n     */\n    createNodes(wid: number, hei: number): { nodes: JSX.Element[], positions: {} } {\n        const nodeWidth = 100\n        const nodeHeight = 100\n        const canvasPadding = 15\n\n        const nodes: JSX.Element[] = []\n        let newArtistsPositions: { [id: string]: { x: number, y: number } } = {}\n        for (let i = 0; i < this.props.graphElements.nodes.length; i++) {\n            const elem = this.props.graphElements.nodes[i]\n            const compX = elem.position.x * (wid - nodeWidth - 2 * canvasPadding) + canvasPadding\n            const compY = elem.position.y * (hei - nodeHeight - 2 * canvasPadding) + canvasPadding\n            newArtistsPositions[elem.artist.id] = { x: compX, y: compY }\n\n            nodes.push(\n                <ArtistNode\n                    key={elem.artist.id}\n                    positionChangedCallback={this.positionChangedHandler}\n                    positionX={compX}\n                    positionY={compY}\n                    artist={elem.artist}\n                    minimumScore={this.state.artistSliderValue}\n                />\n            )\n        }\n        return { nodes, positions: newArtistsPositions }\n    }\n\n    /**\n     * Calculates artist and edge slider extrema\n     * \n     * @param maximumEdges maximal number of defaultly visible edges\n     */\n    getSliderLimits(maximumEdges: number): {\n        artistsSliderLimits: SliderLimits,\n        edgesSliderLimits: SliderLimits,\n        currSliderValue: number\n    } {\n        let artistsSliderLimits: SliderLimits = { minimum: 1000, maximum: -1000 }\n        let edgesSliderLimits: SliderLimits = { minimum: 1000, maximum: -1000 }\n\n        // get slider values\n        for (let i = 0; i < this.props.graphElements.nodes.length; i++) {\n            const node = this.props.graphElements.nodes[i]\n            const artistScore = node.artist.score\n            artistsSliderLimits.maximum = artistScore > artistsSliderLimits.maximum ? artistScore : artistsSliderLimits.maximum\n            artistsSliderLimits.minimum = artistScore < artistsSliderLimits.minimum ? artistScore : artistsSliderLimits.minimum\n        }\n\n        const edgesValues: number[] = this.props.graphElements.edges.map(el => el.weigth).sort((a, b) => a - b)\n        edgesSliderLimits.minimum = edgesValues[0]\n        edgesSliderLimits.maximum = edgesValues[edgesValues.length - 1]\n\n        artistsSliderLimits.maximum = Math.ceil(artistsSliderLimits.maximum)\n        artistsSliderLimits.minimum = Math.ceil(artistsSliderLimits.minimum) - 1\n        edgesSliderLimits.maximum = Math.ceil(edgesSliderLimits.maximum)\n        edgesSliderLimits.minimum = Math.ceil(edgesSliderLimits.minimum) - 1\n\n        const l = edgesValues.length\n        const currSliderValue = l > maximumEdges ? edgesValues[l - maximumEdges] + 0.1 : edgesSliderLimits.minimum\n\n        return {\n            artistsSliderLimits: artistsSliderLimits,\n            edgesSliderLimits: edgesSliderLimits,\n            currSliderValue: currSliderValue\n        }\n    }\n\n    /**\n     * Changes state with the new position value of node.\n     * @param x new X coordinate\n     * @param y new Y coordinate\n     * @param artist_id ID of the node that will be changed\n     */\n    positionChangedHandler(x: number, y: number, artist_id: string) {\n        if (this.state.artistsPositions == null) {\n            return []\n        }\n        const pos = this.state.artistsPositions\n        pos[artist_id] = { x: x, y: y }\n        this.setState({ artistsPositions: pos });\n    }\n\n    /**\n     * Returns edges created from node positions.\n     */\n    createEdges(): JSX.Element[] {\n        const edges = []\n        if (this.state.artistsPositions == null) {\n            return []\n        }\n\n        try {\n            for (let i = 0; i < this.props.graphElements.edges.length; i++) {\n                const edge = this.props.graphElements.edges[i]\n                const node1id = edge.id1\n                const node2id = edge.id2\n                const edgeWeigth = edge.weigth\n                const clusterEdgeKey = node1id + node2id\n\n                const node1 = this.props.idArtistDict[node1id]\n                const node2 = this.props.idArtistDict[node2id]\n\n                if (node1 !== node2 && edgeWeigth > this.state.edgesSliderValue &&\n                    edgeWeigth > this.state.minimumEdgeWeight &&\n                    node1.score >= this.state.artistSliderValue &&\n                    node2.score >= this.state.artistSliderValue\n                ) {\n                    edges.push(\n                        <ArtistEdge\n                            key={clusterEdgeKey}\n                            x1={this.state.artistsPositions[node1id].x}\n                            y1={this.state.artistsPositions[node1id].y}\n                            x2={this.state.artistsPositions[node2id].x}\n                            y2={this.state.artistsPositions[node2id].y}\n                            weigth={edge.weigth}\n                            artistWidth={70}\n                            maximumEdgeWeigth={this.state.edgesSliderLimits.maximum}\n                        />\n                    )\n                }\n            }\n        }\n        catch (err) {\n            edges.push(<div></div>)\n        }\n\n        return edges\n    }\n\n    changeArtistSliderValue(e: ChangeEvent<HTMLInputElement>) {\n        this.setState({ artistSliderValue: e.currentTarget.valueAsNumber })\n    }\n\n    createArtistSlider(): JSX.Element {\n        const minimum = this.state.artistsSliderLimits.minimum\n        const maximum = this.state.artistsSliderLimits.maximum\n        return <div className=\"inner-slider-wrapper\">\n            <input\n                type=\"range\"\n                min={minimum}\n                max={maximum}\n                step={(maximum - minimum) / 10}\n                value={this.state.artistSliderValue}\n                onChange={this.changeArtistSliderValue}\n                className=\"slider-input\"\n            />\n        </div>\n    }\n\n    changeEdgeSliderValue(e: ChangeEvent<HTMLInputElement>) {\n        this.setState({ edgesSliderValue: e.currentTarget.valueAsNumber })\n    }\n\n    createEdgeSlider(): JSX.Element {\n        const minimum = Math.max(this.state.edgesSliderLimits.minimum, this.state.minimumEdgeWeight)\n        const maximum = this.state.edgesSliderLimits.maximum\n        return <div className=\"inner-slider-wrapper\">\n            <input\n                type=\"range\"\n                min={minimum}\n                max={maximum}\n                step={(maximum - minimum) / 10}\n                value={this.state.edgesSliderValue}\n                onChange={this.changeEdgeSliderValue}\n                className=\"slider-input\"\n            />\n        </div>\n    }\n\n    changeHover() {\n        this.setState({ descriptionHover: !this.state.descriptionHover })\n    }\n\n    getDraggableSlider() {\n        const showDescriptionStyle = this.state.descriptionHover ? {} : { display: 'none' }\n        return (\n            <Draggable handle=\"strong\" bounds=\"parent\">\n                <div className=\"draggable-slider-div\">\n                    <div>\n                        <div className=\"outer-slider-wrapper\">\n                            {this.createEdgeSlider()}\n                            edges\n                        </div>\n                        <div className=\"outer-slider-wrapper\">\n                            {this.createArtistSlider()}\n                            artists\n                        </div>\n                    </div>\n                    <BsQuestion onMouseEnter={() => this.changeHover()} onMouseLeave={() => this.changeHover()} size={30} />\n                    <strong><TiArrowMove size={30} /></strong>\n                    <div className=\"slider-description\" style={showDescriptionStyle}>\n                        <p>Drag the sliders to control how many edges and artists will be shown.</p>\n                        <p>The artists will be hidden in the order based on their importance to you - less important first, more important remainig.</p>\n                        <p>The importance takes into account these factors: how many their songs you like, if you follow them and popularity on Spotify.</p>\n                        <p>The score of an edge between two artists is calculated from the number of common genres and Spotify \"related artists\" information.</p>\n                    </div>\n                </div>\n            </Draggable>\n        )\n    }\n\n    render() {\n        return (\n            <div className=\"noselect chosen-cluster-wrapper\" ref={this.wrapperRef}>\n                <div className=\"insideClusterBox\" ref={this.boxRef} style={{ width: this.state.width }}>\n                    {this.getDraggableSlider()}\n                    {this.state.width !== 0 && this.state.nodes.length !== 0 && this.createEdges()}\n                    {this.state.width !== 0 && this.state.nodes}\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        idArtistDict: state.graph.artistDict\n    }),\n    {}\n)(ChosenClusterGraph)\n","\nimport React from 'react'\nimport { connect } from 'react-redux'\nimport { isUndefined } from 'util'\nimport { MdPlayCircleOutline, MdPauseCircleOutline } from 'react-icons/md'\nimport { IoMdMusicalNotes, IoMdHeart } from 'react-icons/io'\nimport { RiQuestionLine} from 'react-icons/ri'\nimport SpotifyWebApi from 'spotify-web-api-js'\n\nimport { ArtistFull, State, ChosenArtistData, SongFull } from '../store/types'\nimport { setSongToPlay, setPaused } from '../store/actions'\nimport COLORS from '../methods/colors'\n\nimport './chosen-artist-bar.css'\nimport './styles.css'\n\ninterface ChosenArtistBarProps {\n    /** Chosen artist - full object */\n    chosenArtist?: ArtistFull,\n    /** Chosen artist loading - true if loading */\n    chosenArtistLoading: boolean,\n    /** Chosen artist error - if some error occurs, contains error message */\n    chosenArtistError?: string,\n    /** Chosen artist data object */\n    chosenArtistData?: ChosenArtistData,\n    /** Function to play a song */\n    setSongToPlay: (song: SongFull) => void,    \n    /** Spotify Web API object */\n    spotifyApiObject: SpotifyWebApi.SpotifyWebApiJs,\n    /** Song that is currently in the player */\n    songToPlay: SongFull\n    /** Is song paused? */\n    paused: boolean\n    /** Change the state of player*/\n    setPause: (paused: boolean) => void\n}\n\ninterface ChosenArtistBarState {\n    chosenSongId: string\n    likedSongs:SongFull[]\n    notLikedSongs:SongFull[]\n}\n\n/**\n * Right bar with Chosen artist information (songs, image)\n */\nclass ChosenArtistBar extends React.Component<ChosenArtistBarProps, ChosenArtistBarState> {\n\n    constructor(props: any) {\n        super(props)\n        const {liked, notLiked} = this.prepareSongs()\n        this.state = {chosenSongId: '', likedSongs:liked, notLikedSongs: notLiked}\n    }\n\n    setChosenSong(songId: string) {\n        if (songId === this.state.chosenSongId) {\n            this.setState({chosenSongId: \"\"})\n        }\n        else {\n            this.setState({chosenSongId: songId})\n        }\n    }\n\n    componentDidUpdate(prevProps: ChosenArtistBarProps, prevState: ChosenArtistBarState) {\n        if(prevProps.chosenArtistData !== this.props.chosenArtistData && this.props.chosenArtistData) {\n            this.setState({\n                chosenSongId: '',\n                likedSongs:this.props.chosenArtistData.likedSongs,\n                notLikedSongs: this.props.chosenArtistData.notLikedSongs\n            })\n        }\n    }\n\n    prepareSongs(): {liked: SongFull[], notLiked: SongFull[]} {\n        if(!!!this.props.chosenArtistData || isUndefined(this.props.chosenArtist)) {\n            return {liked:[],notLiked:[]}\n        }\n\n        const likedSongs:SongFull[] = []\n        const notLikedSongs:SongFull[] = []\n\n        for (let i = 0; i < this.props.chosenArtistData.likedSongs.length; i++) {\n            const element = this.props.chosenArtistData.likedSongs[i];\n            if (this.props.chosenArtist.likedSongs && !!!likedSongs.includes(element)) {\n                likedSongs.push(element);\n            }\n            else if (!notLikedSongs.includes(element)){\n                notLikedSongs.push(element);\n            }\n        }\n        console.debug('liked:', likedSongs)\n        console.debug('liked by artist', this.props.chosenArtist.likedSongs)\n        console.debug('not liked:', notLikedSongs)\n        return {liked: likedSongs, notLiked: notLikedSongs}\n    }\n\n    getSongDiv(song: SongFull, liked: boolean): JSX.Element {\n        const style = this.state.chosenSongId === song.id ? {maxHeight: 80} : {maxHeight: 0}\n\n        let playerIcon = <MdPlayCircleOutline size={40} onClick={(e) => {\n            e.stopPropagation(); \n            this.props.setSongToPlay(song);\n        }} />\n\n        let chosenSongColorIndicator = COLORS.lightAzureBlue;\n        if (this.props.songToPlay && this.props.songToPlay.id === song.id) {\n            chosenSongColorIndicator = COLORS.pink;\n            if (this.props.paused) {\n                playerIcon = <MdPlayCircleOutline size={40} onClick={(e) => {e.stopPropagation(); this.props.setPause(false)}} />\n            }\n            else {\n                playerIcon = <MdPauseCircleOutline size={40} onClick={(e) => {e.stopPropagation(); this.props.setPause(true)}} />\n            }\n        }\n\n        let likedSongColorIndicator = COLORS.lightAzureBlue\n        if (liked) {\n            likedSongColorIndicator = COLORS.green\n        }\n\n        if (song.previewLink === '' || song.previewLink === null || isUndefined(song.previewLink)) {\n            playerIcon = <RiQuestionLine size={40} onClick={(e) => {e.stopPropagation(); alert('No preview found on Spotify')}} />\n            chosenSongColorIndicator = COLORS.grey\n        }\n\n        return (\n            <div key={song.id} className=\"flex-column song-div\" style={{backgroundColor: chosenSongColorIndicator}}>\n                <div className=\"song-preview\" style={{backgroundColor: likedSongColorIndicator}} onClick={() => this.setChosenSong(song.id)}>\n                    <div className=\"pointer\"\n                        style={{marginRight:\"5px\", display:\"inline-flex\", flexDirection:\"column\", justifyContent:\"center\", alignContent:\"center\"}}\n                    >\n                        {playerIcon}\n                    </div>\n                    <div className=\"song-wrapper\">\n                        {song.name}\n                    </div>\n                </div>\n                <div className=\"song-description\" style={style}>\n                    <div className=\"full-song-link-div\" onClick={() => {window.open(song.externalUrl)}}>\n                        <IoMdMusicalNotes/>\n                        Full song\n                    </div>\n                    { !!!liked && <div className=\"full-song-link-div\" onClick={() => {\n                        this.props.spotifyApiObject.addToMySavedTracks([song.id])\n                        .then(() => {\n                            console.debug('TRACK SAVED')\n                            let likedSongsOld = this.state.likedSongs\n                            likedSongsOld = likedSongsOld.concat(song)\n                            let notLikedSongsOld = this.state.notLikedSongs.filter(s => s.id !== song.id)\n\n                            this.setState({likedSongs: likedSongsOld, notLikedSongs: notLikedSongsOld})\n                        })\n                        .catch((error: any) => {\n                            console.debug('THIS ERROR DURING TRACK SAVING OCCURED:', error)\n                        })\n                    }}>\n                        <IoMdHeart/>\n                        Save to liked songs\n                    </div>\n                    }\n                </div>\n            </div>\n        )\n    }\n\n    getSongsDivs(songs: SongFull[], liked: boolean): JSX.Element[] {\n        if (!!!songs) return []\n\n        const toReturn: JSX.Element[] = []\n        for (let i = 0; i < songs.length; i++) {\n            toReturn.push(\n                this.getSongDiv(songs[i], liked)\n            )\n        }\n        return toReturn\n\n    }\n\n    render() {\n        if (this.props.chosenArtistError) {\n            return (\n                <div className=\"chosen-artist-bar\">\n                    <h2><i>{this.props.chosenArtistError}</i></h2>\n                </div>\n            )\n        }\n        else if (isUndefined(this.props.chosenArtist) || isUndefined(this.props.chosenArtistData)) {\n            return (\n                <div className=\"chosen-artist-bar\">\n                    <h2>CLICK SOME ARTIST</h2>\n                </div>\n            )\n        }\n        else if (this.props.chosenArtistLoading) {\n            return (\n                <div className=\"chosen-artist-bar\">\n                    <h2>LOADING...</h2>\n                </div>\n            )\n        }\n        else {\n            return (\n                <div className=\"chosen-artist-bar\">\n                    <div className=\"chosen-artist-bar-top\">\n                        <h1 style={{margin:0}}>\n                            {this.props.chosenArtist.name}\n                        </h1>\n                        <div style={{\n                            backgroundImage:`url(${this.props.chosenArtist.image})`,\n                            width: 70, height: 70, borderRadius: `${20}%`,\n                            backgroundSize: `70px 70px`,\n                            display: \"inline-grid\"\n                        }}></div>\n                        {\n                            this.props.chosenArtist.isFollowed &&\n                            <h2 style={{ margin:`5px 0px 0px 0px` }}>You are following this artist.</h2>\n                        }\n                    </div>\n                    <div className=\"chosen-artist-bar-scroll\">\n                        {this.getSongsDivs(this.state.likedSongs, true)}\n                        {this.getSongsDivs(this.state.notLikedSongs, false)}\n                    </div>\n                </div>\n            )\n        }\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        songToPlay: state.songToPlay,\n        chosenArtist: state.chosenArtist,\n        chosenArtistLoading: state.chosenArtistLoading,\n        chosenArtistError: state.chosenArtistError,\n        chosenArtistData: state.chosenArtistData,\n        spotifyApiObject: state.spotifyWebApiObject,\n        paused: state.paused\n    }),\n    (dispatch: Function) => ({\n        setPause: (paused:boolean) => dispatch(setPaused(paused)),\n        setSongToPlay: (song: SongFull) => dispatch(setSongToPlay(song))\n    })\n)(ChosenArtistBar)\n","import React from 'react'\nimport { connect } from 'react-redux'\nimport { BsQuestion } from 'react-icons/bs'\nimport { State, ArtistSimplified } from '../store/types'\nimport { setChosenArtistDataAll, updateNotFavouriteArtists } from '../store/actions'\nimport { ArtistFull } from '../store/types'\nimport COLORS from '../methods/colors'\nimport { getAllArtistsFull } from '../methods/spotify-methods'\n\nimport CSS from 'csstype'\nimport './cluster-node.css'\nimport './artist-node.css'\nimport './recommendation-panel.css'\nimport SpotifyWebApi from 'spotify-web-api-js'\nimport { isUndefined } from 'util'\n\ninterface RecommendationPanelProps {\n    clusterArtistsIds: string[],\n    artistDict: {[x: string]: ArtistFull},\n    sp: SpotifyWebApi.SpotifyWebApiJs,\n    setChosenArtistDataAll: typeof setChosenArtistDataAll,\n    updateNotFavouriteArtists: typeof updateNotFavouriteArtists,\n    accessToken?: string,\n    chosenArtist?: ArtistFull\n}\n\ninterface RecommendationPanelState {\n    artistsToRecommend: ArtistFull[]\n    questionMarkHover: boolean\n}\n\ninterface Counter {\n    [id: string]: {count: number, related: string[]}\n}\n\ninterface CounterListObject {\n    id: string\n    count: number\n    related: string[]\n}\n\n/**\n * \n */\nclass RecommendationPanel extends React.Component<RecommendationPanelProps, RecommendationPanelState> {\n    constructor(props: RecommendationPanelProps) {\n        super(props);\n        this.state = {\n            questionMarkHover: false,\n            artistsToRecommend: []\n        }\n        this.getArtistsToRecommend()\n    }\n\n    getArtistsToRecommend() {\n        const counter = this.getCounter(this.props.clusterArtistsIds.map(id => this.props.artistDict[id]))\n        console.debug('COUNTER', counter)        \n        const topIds = this.getTopIds(counter)\n\n        if (topIds.length === 0) return <div></div>\n\n        const fetchArtistsPromise = getAllArtistsFull(this.props.sp, topIds)\n        Promise.resolve(fetchArtistsPromise).then((result) => {\n            const finalArtists: ArtistFull[] = []\n            \n            for (let i = 0; i < result.length; i++) {\n                const aFull = result[i];\n                const artistImage = aFull.images && aFull.images.length > 0 ? aFull.images[aFull.images.length - 1].url : ''\n                finalArtists.push({\n                    genres: aFull.genres,\n                    id: aFull.id,\n                    name: aFull.name,\n                    relatedArtistsIds: counter[aFull.id].related,\n                    image: artistImage,\n                    isFollowed: false,\n                    likedSongs: [],\n                    score: 1\n                })\n            }\n\n            this.setState({artistsToRecommend: finalArtists})\n        })\n    }\n\n    getCounter(artists: ArtistFull[]) {\n        const counter: Counter = {}\n        for (let i = 0; i < artists.length; i++) {\n            const a = artists[i];\n            for (let j = 0; j < a.relatedArtistsIds.length; j++) {\n                const relID = a.relatedArtistsIds[j];\n                if (!(relID in this.props.artistDict)) {\n                    if (relID in counter) {\n                        const current = counter[relID]\n                        counter[relID] = {count: current.count + 1, related: current.related.concat([a.id])}\n                    } else {\n                        counter[relID] = {count: 1, related: [a.id]}\n                    }\n                }\n            }\n        }\n        return counter\n    }\n\n    getTopIds(counter: Counter): string[] {\n        const maximumRecommended = 15\n        const minimumRelated = 2\n\n        const counterKeys = Object.keys(counter)\n        const counterValues = Object.values(counter)\n        const toSort: CounterListObject[] = []\n        for (let i = 0; i < counterKeys.length; i++) {\n            const key = counterKeys[i]\n            const val = counterValues[i]\n            toSort.push({id: key, count: val.count, related: val.related})\n        }\n        toSort.sort((a,b) => b.count - a.count)\n\n        const artistsToRecommend = []\n        for (let i = 0; i < maximumRecommended; i++) {\n            if (i >= toSort.length) break\n            if (toSort[i].count < minimumRelated) break\n\n            artistsToRecommend.push(toSort[i])\n        }\n        return artistsToRecommend.map(o => o.id)\n    }\n\n    componentDidMount() {\n\n    }\n\n    componentDidUpdate() {\n\n    }\n\n    createRecommendArtistDiv(artistFull: ArtistFull) {\n        let color = COLORS.darkAzureBlue\n        if (this.props.chosenArtist && this.props.chosenArtist.id === artistFull.id) {\n            color = COLORS.pink\n        }\n        \n        const nodeWidth = 60\n        const nodeHeight = 60\n        const padding = 2\n\n        const wrapperStyle: CSS.Properties = {\n            backgroundColor: color,\n            display:\"flex\", \n            padding:`${padding}px`,\n            height:`${nodeHeight+2*padding}px`,\n            borderRadius: \"10px\",\n            margin: \"0px 1px 0px 1px\"\n        }\n\n        const artistImageDivStyle: CSS.Properties = {\n            backgroundImage: `url(${artistFull.image})`,\n            backgroundSize: `${nodeHeight}px ${nodeWidth}px`,\n            width: `${nodeWidth}px`,\n            height: `${nodeHeight}px`,\n            borderRadius: \"10px\",\n            alignSelf: \"center\",\n            margin: \"2px\"\n        }\n\n        const token = isUndefined(this.props.accessToken) ? '' : this.props.accessToken\n        return (\n            <div style={wrapperStyle}\n                title={artistFull.name}\n                onClick={() => {\n                    this.props.updateNotFavouriteArtists([artistFull])\n                    this.props.setChosenArtistDataAll(artistFull, token)\n\n                }}\n            >\n                <div style={{ ...artistImageDivStyle, borderColor: COLORS.lightAzureBlue }}>\n                    {/* <div style={artistImageDivStyle} /> */}\n                </div>\n            </div>\n        )\n    }\n\n    changeHover() {\n        this.setState({questionMarkHover: !this.state.questionMarkHover})\n    }\n\n    render() {\n        if (this.state.artistsToRecommend.length === 0) {\n            return (\n                <div className=\"recommendation-panel\">\n                    <div style={{flex: \"1 1 auto\", textAlign:\"center\"}}>\n                        <p style={{margin:\"0px\"}}>No artists to recommend</p>\n                        <p>Either there are not enough artists in this cluster, or they are not really related.</p>\n                    </div>\n                </div>\n            )\n        }\n\n        const divs = this.state.artistsToRecommend.map(a => this.createRecommendArtistDiv(a))\n        const showHover = this.state.questionMarkHover ? {} : {display:'none'}\n        return (\n            <div>\n                <div className=\"you-might-like-description\" style={{...showHover}}>\n                    <p>Based on the artists in the current cluster, you could like the following artists.</p>\n                    <p>After some of the artists is clicked, their related artists are highlighted yellow in the graph.</p>\n                </div>\n                <div className=\"you-might-like\">\n                    <b>You might also like:</b>\n                    <BsQuestion \n                        onMouseEnter={() => this.changeHover()} \n                        onMouseLeave={() => this.changeHover()} \n                        size={25} />\n                </div>\n                <div className=\"recommendation-panel\">\n                    {divs}\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        artistDict: state.graph.artistDict,\n        sp: state.spotifyWebApiObject,\n        accessToken: state.accessToken,\n        chosenArtist: state.chosenArtist\n    }),\n    (dispatch: any) => ({\n        setChosenArtistDataAll: (chosenArtist: ArtistFull, accessToken: string) => dispatch(setChosenArtistDataAll(chosenArtist, accessToken)),\n        updateNotFavouriteArtists: (artistsToUpdate: ArtistSimplified[]) => dispatch(updateNotFavouriteArtists(artistsToUpdate))\n    })\n)(RecommendationPanel)\n","import * as React from 'react'\nimport CSS from 'csstype'\nimport './styles.css'\nimport { connect } from 'react-redux'\nimport {TiArrowBack} from 'react-icons/ti'\nimport { State, Cluster, ClusterEdge, ArtistEdge,ArtistFull, StringDict } from '../store/types'\nimport { closeChosenClusterGraph, setChosenCluster, closeChosenArtist } from '../store/actions'\nimport ChosenClusterGraph from './chosen-cluster-graph'\nimport ChosenArtistBar from './chosen-artist-bar'\nimport RecommendationPanel from './recommendation-panel'\n\ninterface ChosenClusterProps {\n    closeChosenClusterGraph: Function,\n    closeChosenArtist: Function,\n    setChosenCluster: Function,\n    chosenCluster: Cluster,\n    clusters: Cluster[],\n    clusterEdges: ClusterEdge[],\n    artistEdges: ArtistEdge[],\n    artistDict: StringDict<ArtistFull>\n}\n\ninterface ChosenClusterState {\n    elements: InsideClusterGraph\n}\n\nexport interface InsideClusterArtistNode {\n    artist: ArtistFull\n    position: {x:number, y:number}\n}\n\nexport interface InsideClusterArtistEdge {\n    id: string\n    id1: string\n    id2: string\n    weigth: number\n}\n\nexport interface InsideClusterGraph {\n    nodes: InsideClusterArtistNode[]\n    edges: InsideClusterArtistEdge[]\n}\n\nclass ChosenCluster extends React.Component<ChosenClusterProps, ChosenClusterState> {\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            elements:this.getChosenClusterGraphElements(this.props.chosenCluster)\n        }\n    }\n\n    getChosenClusterGraphElements(chosenCluster: Cluster): InsideClusterGraph {\n        const nodes: InsideClusterArtistNode[] = [];\n        const edges: InsideClusterArtistEdge[] = [];\n\n        for (let i = 0; i < chosenCluster.artistsIds.length; i++) {\n            const currArtistId = chosenCluster.artistsIds[i];\n            const pos = chosenCluster.artistsPositions[currArtistId]\n            nodes.push({artist:this.props.artistDict[currArtistId], position: {x:pos.x, y:pos.y}})\n        }\n\n        for (let i = 0; i < this.props.artistEdges.length; i++) {\n            const id1 = this.props.artistEdges[i].id1;\n            const id2 = this.props.artistEdges[i].id2;\n            if (chosenCluster.artistsIds.includes(id1) && chosenCluster.artistsIds.includes(id2)) {\n                edges.push({id: id1+id2, id1: id1, id2: id2, weigth: this.props.artistEdges[i].weight})\n            }\n        }\n\n        return {nodes, edges}\n    }\n\n    getSimilarClusters(): JSX.Element[] {\n        const id = this.props.chosenCluster.id\n        const clusterEdgesWithChosenCluster: ClusterEdge[] = []\n\n        for (let i = 0; i < this.props.clusterEdges.length; i++) {\n            const clusterEdge = this.props.clusterEdges[i]\n            if (clusterEdge.id2 !== clusterEdge.id1 &&\n                (clusterEdge.id1 === id || clusterEdge.id2 === id)) {\n                clusterEdgesWithChosenCluster.push(clusterEdge)\n            }\n        }\n        clusterEdgesWithChosenCluster.sort((a, b) => a.weight > b.weight ? -1 : 1)\n\n        const similarClusters: JSX.Element[] = []\n        const minimalClusterSimilarity = 2\n\n        const imgWid = 60\n        const imgHei = 60\n        let artistDivStyle: CSS.Properties = {\n            width: `${imgWid}px`,\n            height: `${imgHei}px`,\n            backgroundSize: `${imgHei}px ${imgWid}px`,\n        }\n\n        for (let i = 0; i < clusterEdgesWithChosenCluster.length; i++) {\n            const edge = clusterEdgesWithChosenCluster[i];\n            if (edge.weight > minimalClusterSimilarity) {\n                const secondId = id === edge.id1 ? edge.id2 : edge.id1\n                const similarCluster = this.props.clusters[this.props.clusters.map(e => e.id).indexOf(secondId)]\n                const similarClusterArtistsElements: JSX.Element[] = []\n\n                for (let j = 0; j < Math.min(similarCluster.artistsIds.length, 3); j++) {\n                    const artistId = similarCluster.artistsIds[j];\n                    const currArtist = this.props.artistDict[artistId]\n                    const artistDivStyleNew = {\n                        ...artistDivStyle,\n                        backgroundImage:`url(${currArtist.image})`\n                    }\n                    similarClusterArtistsElements.push(\n                        <div className=\"artistWrapper\">\n                            <div title={currArtist.name} style={artistDivStyleNew} className=\"artistDiv\"></div>\n                        </div>\n                    )\n                }\n\n                similarClusters.push(\n                    <div className=\"similar-cluster-div padding-margin pointer\" onClick={\n                            () => {\n                                this.props.closeChosenArtist()\n                                this.props.setChosenCluster(similarCluster)\n                                this.setState({\n                                    elements:this.getChosenClusterGraphElements(similarCluster)\n                                })\n                            }\n                        }>\n                        <p>Similar to: {similarCluster.genres[0]}</p>\n                        <div className=\"artistsRow\">\n                            {similarClusterArtistsElements}\n                        </div>\n                    </div>\n                )\n            }\n        }\n        return similarClusters\n    }\n\n    onClick = () => {\n        this.props.closeChosenClusterGraph()\n        this.props.closeChosenArtist()\n    }\n\n    render() {\n        const similarClusters = this.getSimilarClusters()\n\n        return (\n            <div className=\"chosen-cluster-div\">\n                <div className=\"chosen-cluster-column\">\n                    <div className=\"similar-cluster-row\">\n                        <div className=\"go-back-div padding-margin pointer\" onClick={this.onClick}>\n                            <TiArrowBack size={50}/>\n                            <h3 className=\"h3-no-padding\">Go back to the graph</h3>\n                        </div>\n                        {similarClusters}\n                    </div>\n                    <div className=\"chosen-cluster-graph-div\">\n                        <ChosenClusterGraph graphElements={this.state.elements}/>\n                    </div>\n\n                    <RecommendationPanel clusterArtistsIds={this.props.chosenCluster.artistsIds}/>\n                </div>\n\n                <ChosenArtistBar/>\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = (state: State) => {\n    return {\n        artistEdges: state.graph.artistEdges,\n        clusters: state.graph.clusters,\n        clusterEdges: state.graph.clusterEdges,\n        artistDict: state.graph.artistDict\n    }\n}\n\nexport default connect(\n    mapStateToProps,\n    {\n        closeChosenClusterGraph,\n        closeChosenArtist,\n        setChosenCluster\n    }\n  )(ChosenCluster)\n","import React from 'react'\nimport { connect } from 'react-redux'\nimport Draggable, { DraggableEvent } from 'react-draggable'\nimport ReactCountryFlag from 'react-country-flag'\nimport CSS from 'csstype';\n\nimport { State } from '../store/types'\nimport { setChosenCluster, } from '../store/actions'\nimport { Cluster, StringDict, ArtistFull } from '../store/types'\nimport './cluster-node.css'\n\nvar countries = require(\"i18n-iso-countries\");\ncountries.registerLocale(require(\"i18n-iso-countries/langs/en.json\"));\n\ninterface ClusterNodeProps {\n    /** Cluster to be shown as node */\n    cluster: Cluster\n    /** Initial X coordinate */\n    positionX: number\n    /** Initial Y coordinate */\n    positionY: number\n    /** Callback - let Main graph know that position of the node with artist_id was changed */\n    positionChanged: (x: number, y: number, artist_id: string) => void\n    /** Set chosen cluster in the State */\n    setChosenCluster: typeof setChosenCluster\n    \n    /** Constant to adapt description font size on zoom */\n    fontSizeConst: number\n    /** Width of the cluster in the default zoom. */\n    clusterWidth: number\n    /** Artist dictionarty - [artistId]:artistFullObject */\n    artistDict: StringDict<ArtistFull>\n}\n\ninterface ClusterNodeState {\n    /** Current X coordinate */\n    positionX: number\n    /** Current Y coordinate */\n    positionY: number\n    /** Is the node being dragged */\n    dragging: boolean\n    /** The default font size of the description */\n    fontSizeDefault: number\n}\n\nclass ClusterNode extends React.Component<ClusterNodeProps, ClusterNodeState> {\n    constructor(props: ClusterNodeProps) {\n        super(props);\n        this.state = {\n            positionX: props.positionX,\n            positionY: props.positionY,\n            dragging: false,\n            fontSizeDefault: 12\n        }\n        this.onDrag = this.onDrag.bind(this)\n        this.onStop = this.onStop.bind(this)\n    }\n\n    componentDidUpdate(prevProps: ClusterNodeProps, prevState: ClusterNodeState) {\n        if (prevProps.positionX !== this.props.positionX) {\n            this.setState({ positionX: this.props.positionX })\n        }\n    }\n\n    /** On node drag -> change position and call callback to let Main graph edges know */\n    onDrag(e: DraggableEvent, ui: any) {\n        e.stopPropagation(); e.preventDefault();\n\n        const oldX = this.state.positionX\n        const oldY = this.state.positionY\n\n        const newX = oldX + ui.deltaX\n        const newY = oldY + ui.deltaY\n\n        this.setState({ dragging: true, positionX: newX, positionY: newY })\n        this.props.positionChanged(newX, newY, this.props.cluster.id)\n    }\n\n    onStop(e: DraggableEvent) {\n        e.stopPropagation(); e.preventDefault();\n        const dragging = this.state.dragging;\n        this.setState({ dragging: false })\n        if (!dragging) {\n            this.handleClick(e);\n        }\n    }\n\n    handleClick(e: any) {\n        this.props.setChosenCluster(this.props.cluster)\n    }\n\n    createArtistWrapper(title: string, style: {}, key: number): JSX.Element {\n        return (\n            <div key={key} className=\"artistWrapper\">\n                <div className=\"colourWrapper\">\n                    <div title={title} style={style} className=\"artistDiv\"></div>\n                </div>\n            </div>\n        )\n    }\n\n    createEmptyWrapper(key: number): JSX.Element {\n        return <div key={key} className=\"artistWrapper\"><div></div></div>\n    }\n    \n    /** Prepares the node div.\n     * Makes rows of artists\n     */\n    clusterDiv(): JSX.Element {\n        const imgSize = this.props.clusterWidth / 4.6\n        let artistDivStyle: CSS.Properties = {\n            width: `${imgSize}px`,\n            height: `${imgSize}px`,\n            backgroundSize: `${imgSize}px ${imgSize}px`,\n        }\n\n        const rows: JSX.Element[] = [];\n        const numberOfArtists = this.props.cluster.artistsIds.length\n\n        let currKey = 0\n        let l: JSX.Element[] = []\n        for (let i = 0; i < Math.min(numberOfArtists, 4); i++) {\n            const currArtist = this.props.artistDict[this.props.cluster.artistsIds[i]]\n            const artistDivStyleNew = {\n                ...artistDivStyle,\n                backgroundImage: `url(${currArtist.image})`\n            }\n            l.push(this.createArtistWrapper(currArtist.name, artistDivStyleNew, currKey++))\n        }\n        rows.push(<div key={1} className=\"artistsRow\">{l}</div>)\n\n        l = []\n        if (numberOfArtists > 4) {\n            l.push(this.createEmptyWrapper(currKey++))\n            l.push(this.createEmptyWrapper(currKey++))\n\n            for (let i = 4; i < Math.min(6, numberOfArtists); i++) {\n                const currArtist = this.props.artistDict[this.props.cluster.artistsIds[i]]\n                const artistDivStyleNew = {\n                    ...artistDivStyle,\n                    backgroundImage: `url(${currArtist.image})`\n                }\n                l.push(this.createArtistWrapper(currArtist.name, artistDivStyleNew, currKey++))\n            }\n\n            if (numberOfArtists > 6) {\n                const artistDivStyleNew = {\n                    ...artistDivStyle,\n                    backgroundImage: `url(${process.env.PUBLIC_URL + '/three-dots.png'})`\n                }\n                l.push(this.createArtistWrapper(\"AND OTHERS\", artistDivStyleNew, currKey++))\n            }\n            l.push(this.createEmptyWrapper(currKey++))\n            l.push(this.createEmptyWrapper(currKey++))\n            rows.push(<div key={2} className=\"artistsRow\">{l}</div>)\n        }\n\n        let headerString = \"\"\n        const numberOfGenres = this.props.cluster.genres.length\n        if (numberOfGenres === 0) {\n            headerString = \"...unknown genre...\"\n        }\n        else {\n            for (let i = 0; i < Math.min(numberOfGenres, this.props.fontSizeConst + 1); i++) {\n                if (i === 0) {\n                    headerString += this.props.cluster.genres[i]\n                }\n                else {\n                    headerString += ', ' + this.props.cluster.genres[i]\n                }\n            }\n        }\n\n        let wrapperStyle: CSS.Properties = {\n            width: `${this.props.clusterWidth}px`,\n        }\n        return (<div className=\"nodeWrapper\" style={wrapperStyle}>\n            {\n                this.props.cluster.country &&\n                <div style={{\n                    position: \"absolute\",\n                    margin: 0,\n                    left: 0,\n                    opacity: 0.4,\n                    zIndex: -1,\n                    alignItems: 'center',\n                }}>\n                    <ReactCountryFlag\n                        countryCode={countries.alpha3ToAlpha2(this.props.cluster.country)}\n                        svg\n                        style={{\n                            width: this.props.clusterWidth + 30,\n                            height: '260px'\n                        }}\n                    />\n                </div>\n            }\n\n            <div className=\"nodeHeader\">\n                <div className=\"header noselect\" style={{ fontSize: this.state.fontSizeDefault / this.props.fontSizeConst + this.props.fontSizeConst }}>\n                    {headerString}\n                </div>\n            </div>\n            {rows}\n\n        </div>)\n    }\n\n    render() {\n        const clusterDiv = this.clusterDiv()\n        return (\n            <Draggable\n                onDrag={this.onDrag}\n                onStop={this.onStop}\n                onStart={(e: DraggableEvent) => { e.stopPropagation(); e.preventDefault(); }}\n                bounds=\"parent\"\n                defaultPosition={{ x: this.props.positionX, y: this.props.positionY }}\n                position={{ x: this.state.positionX, y: this.state.positionY }}\n            >\n                {clusterDiv}\n            </Draggable>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        artistDict: state.graph.artistDict\n    }),\n    {\n        setChosenCluster,\n    }\n)(ClusterNode)\n","import React from 'react'\nimport {computeEdgeCoordinates} from '../methods/edge-calculation'\n\ninterface ClusterEdgeProps {\n    /** X coordinate of the first cluster */\n    x1: number\n    /** Y coordinate of the first cluster */\n    y1: number\n    /** X coordinate of the second cluster */\n    x2: number\n    /** Y coordinate of the second cluster */\n    y2: number\n    /** Weight of the edge */\n    weigth: number\n    /** Size of the cluster to calculate the starting coordinates of edge */\n    clusterWidth: number\n}\n\n/** ClusterEdge - edge between clusters in the Main graph */\nexport default class ClusterEdge extends React.Component<ClusterEdgeProps, {}> {\n\n    render() {\n        const thickness = this.props.weigth\n        const {x1fin, y1fin, x2fin, y2fin, top, left, hei, wid} = computeEdgeCoordinates(\n            this.props.x1, this.props.y1, this.props.x2, this.props.y2, thickness)\n\n        const st: React.CSSProperties ={\n            top: top + 30,\n            left: left + this.props.clusterWidth / 2\n        }\n\n        const curvature = 20\n\n        return(\n            <svg style={st} className=\"position-absolute\" width={wid+thickness+curvature} height={hei+thickness+curvature}>\n                <path\n                    d={`M ${x1fin},${y1fin}\n                        C ${x1fin+curvature},${y1fin+curvature} ${x2fin+curvature},${y2fin+curvature} ${x2fin},${y2fin}`}\n                    strokeWidth={thickness}\n                    fill=\"none\"\n                    stroke=\"black\"\n                />\n            </svg>\n        )\n    }\n}\n","/* eslint-disable @typescript-eslint/no-useless-constructor */\n\nimport React from 'react'\n\ninterface ProgressBarProps {\n    progress: number\n}\n\nexport default class ProgressBar extends React.Component<ProgressBarProps, {}> {\n    constructor(props: ProgressBarProps) {\n        super(props);\n    }\n\n    render() {\n        return (\n            <div className=\"progressbar\">\n                <div className=\"progress\" style={{ width: `${this.props.progress * 100}%` }} />\n            </div>\n        )\n    }\n}\n","/* eslint-disable @typescript-eslint/no-useless-constructor */\n\nimport React from 'react'\nimport SpotifyWebApi from 'spotify-web-api-js'\nimport { connect } from 'react-redux'\nimport { TransformWrapper, TransformComponent } from \"react-zoom-pan-pinch\";\nimport { isUndefined } from 'util';\n\nimport { Graph, Cluster, State, StringDict, Position } from '../store/types'\nimport { setGraph, loadGraph, graphFromFileIsLoaded } from '../store/actions'\nimport { computeHeigthFromPositions, computeClusterPositions } from '../methods/graph-layout'\nimport ChosenCluster from './chosen-cluster'\nimport ClusterNode from './cluster-node'\nimport ClusterEdge from './cluster-edge'\nimport ProgressBar from './progress-bar'\n\nimport './draggable-canvas.css'\n\ninterface DraggableCanvasProps {\n    /** Thunk action for loading graph from the backend */\n    loadGraph: typeof loadGraph\n    /** The graph object */\n    graph: Graph\n    /** Was the graph loaded */\n    graphLoaded: boolean\n    /** Is the graph loading */\n    graphLoading: boolean\n    /** Message during the loading */\n    graphLoadingMessage: string,\n    /** Progress of related artists */\n    graphLoadingRelatedArtistsProgress: number,\n    /** Did error occur */\n    isGraphLoadingError: boolean\n    /** Message if error occured */\n    graphLoadingErrorMessage: string,\n    /** The chosen cluster */\n    chosenCluster: Cluster\n    /** Spotify API access token */\n    accessToken: string\n    /** SpotifyWebApiJs object */\n    sp: SpotifyWebApi.SpotifyWebApiJs\n    /** Set if a graph from file is loaded */\n    graphFromFileIsLoaded: Function\n    /** Is graph loaded from file */\n    isGraphFromFileLoaded: boolean\n}\n\ninterface DraggableCanvasState {\n    /** Dimensions of draggable canvas */\n    dimensions?: { w: number, h: number }\n    /** Current positions of clusters */\n    clusterPositions?: StringDict<Position>\n    /** Width of one cluster */\n    clusterWidth: number\n    /** Approximate height of one cluster (it can differ if cluster contains less artists) */\n    clusterHeight: number\n    /** Current zoom scale */\n    currentScale: number\n\n    /** Draggable canvas width when did mount */\n    originalRefWidth: number\n    /** Draggable canvas height when did mount */\n    originalRefHeight: number\n}\n\n/**\n * Contains all the work with the Main graph.\n */\nclass DraggableCanvas extends React.Component<DraggableCanvasProps, DraggableCanvasState> {\n    boxRef: any\n    wrapperRef: any\n\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            clusterWidth: 150,\n            clusterHeight: 150,\n            currentScale: 1,\n            originalRefHeight: 0,\n            originalRefWidth: 0\n        }\n\n        this.wrapperRef = React.createRef();\n        this.boxRef = React.createRef();\n\n        this.positionChangedHandler = this.positionChangedHandler.bind(this)\n    }\n\n    positionChangedHandler(x: number, y: number, artist_id: string) {\n        if (this.state.clusterPositions == null) {\n            return []\n        }\n        const pos = this.state.clusterPositions\n        pos[artist_id] = { x: x, y: y }\n        this.setState({ clusterPositions: pos });\n    }\n\n    graphLoadedCallback(width: number, height: number) {\n        const clusterWidth = this.state.clusterWidth\n        const clusterHeigth = this.state.clusterHeight\n\n        let newHeight = height\n        if (this.props.graph.clusters.length < 15) { newHeight -= (clusterHeigth + 20) }\n        else if (this.props.graph.clusters.length > 30) { newHeight += clusterHeigth }\n        const positions = computeClusterPositions(width, newHeight, clusterWidth, clusterHeigth, this.props.graph.clusterSquares)\n        const newHeigth = computeHeigthFromPositions(positions, clusterHeigth);\n\n        const currDimensions = this.state.dimensions ? this.state.dimensions : { w: 500, h: 1000 }\n        currDimensions.h = newHeigth\n        this.setState({ clusterPositions: positions })\n    }\n\n    /** On width change -> recompute nodes positions */\n    onResizeRecomputePositions() {\n        if (isUndefined(this.state.dimensions)) return\n        if (isUndefined(this.state.clusterPositions)) return\n\n        const origWidth = this.state.dimensions.w\n        const origHei = this.state.dimensions.h\n        const newWidth = this.wrapperRef.current.clientWidth\n\n        if (origWidth === newWidth) return\n\n        const currentPositions = this.state.clusterPositions\n        const ratio = Math.floor((newWidth / origWidth) * 1024) / 1024\n        for (let key in currentPositions) {\n            currentPositions[key].x = ratio * currentPositions[key].x\n        }\n\n        this.setState({\n            dimensions: { w: newWidth, h: origHei },\n            clusterPositions: currentPositions\n        })\n    }\n\n    componentDidMount() {\n        window.addEventListener('resize', () => { this.onResizeRecomputePositions() });\n        let width = this.wrapperRef.current.clientWidth;\n        let height = this.wrapperRef.current.clientHeight;\n        this.setState(\n            {\n                dimensions: { w: width, h: height },\n                originalRefWidth: width,\n                originalRefHeight: height\n            },\n            () => this.props.loadGraph(this.props.accessToken, this.props.sp, () => this.graphLoadedCallback(width, height))\n        )\n    }\n\n    componentDidUpdate(prevProps: DraggableCanvasProps, prevState: DraggableCanvasState) {\n        if (this.props.isGraphFromFileLoaded) {\n            let w = 500\n            let h = 500\n            if (!isUndefined(this.state.dimensions)) {\n                w = this.state.dimensions.w\n                h = this.state.dimensions.h\n            }\n            // w = this.state.originalRefWidth \n            h = this.state.originalRefHeight\n            this.graphLoadedCallback(w, h)\n            this.props.graphFromFileIsLoaded(false)\n        }\n    }\n\n    /** Creates node elements */\n    createNodes(): JSX.Element[] {\n        if (this.state.clusterPositions === null || isUndefined(this.state.clusterPositions)) {\n            return []\n        }\n\n        const nodes = []\n        for (let i = 0; i < this.props.graph.clusters.length; i++) {\n            const element = this.props.graph.clusters[i];\n            nodes.push(\n                <ClusterNode\n                    key={element.id}\n                    fontSizeConst={this.state.currentScale}\n                    cluster={element}\n                    positionX={this.state.clusterPositions[element.id].x}\n                    positionY={this.state.clusterPositions[element.id].y}\n                    positionChanged={this.positionChangedHandler}\n                    clusterWidth={this.state.clusterWidth}\n                />\n            )\n        }\n        return nodes\n    }\n\n    /** Creates edge elements */\n    createEdges(): JSX.Element[] {\n        const edges = []\n        if (this.state.clusterPositions == null) {\n            return []\n        }\n\n        for (let i = 0; i < this.props.graph.clusterEdges.length; i++) {\n            const source = this.props.graph.clusterEdges[i].id1\n            const target = this.props.graph.clusterEdges[i].id2\n            const clusterEdgeKey = source + target\n            if (source !== target) {\n                const edgeWeigth = Math.log2(this.props.graph.clusterEdges[i].weight) * 3\n                edges.push(\n                    <ClusterEdge\n                        key={clusterEdgeKey}\n                        x1={this.state.clusterPositions[source].x}\n                        y1={this.state.clusterPositions[source].y}\n                        x2={this.state.clusterPositions[target].x}\n                        y2={this.state.clusterPositions[target].y}\n                        weigth={edgeWeigth}\n                        clusterWidth={this.state.clusterWidth}\n                    />\n                )\n            }\n        }\n\n        return edges\n    }\n\n    createGraphLoadingDiv() {\n        return (\n            <div className=\"page-wrapper\">\n                <div className=\"generic-description\">{this.props.graphLoadingMessage}</div>\n                <ProgressBar progress={this.props.graphLoadingRelatedArtistsProgress} />\n            </div>\n        )\n    }\n\n    createSpotifyErrorDiv() {\n        let message = 'Error while loading!\\n\\n'\n        if (this.props.graphLoadingErrorMessage) {\n            message += this.props.graphLoadingErrorMessage\n        }\n\n        return (\n            <div className=\"page-wrapper\">\n                <div className=\"generic-description\">{message}</div>\n            </div>\n        )\n    }\n\n    render() {\n        if (this.props.graphLoading) {\n            return this.createGraphLoadingDiv()\n        }\n\n        if (this.props.isGraphLoadingError) {\n            return this.createSpotifyErrorDiv()\n        }\n\n        const clusterIsChosen = this.props.chosenCluster !== undefined\n        const display = clusterIsChosen ? \"none\" : \"\"\n        const w = this.state.dimensions ? this.state.dimensions.w : 500\n        const h = this.state.dimensions ? this.state.dimensions.h : 500\n\n        return (\n            <div className=\"wrapper\" ref={this.wrapperRef}>\n                <TransformWrapper\n                    defaultScale={1}\n                    defaultPositionX={1}\n                    defaultPositionY={1}\n                    options={{\n                        maxScale: 4,\n                        limitToWrapper: true,\n                    }}\n                    onWheelStop={(e: any) => { this.setState({ currentScale: e.scale }) }}\n                >\n                    {({\n                        zoomIn,\n                        zoomOut,\n                        setTransform,\n                        ...rest\n                    }: any) => (\n                            <React.Fragment>\n                                {\n                                    clusterIsChosen &&\n                                    <ChosenCluster key={this.props.chosenCluster.id} chosenCluster={this.props.chosenCluster} />\n                                }\n                                <TransformComponent>\n                                    <div className=\"box\" ref={this.boxRef}\n                                        style={{ width: w, height: h, display: display }}\n                                    >\n                                        {\n                                            this.state.dimensions &&\n                                            this.createEdges()\n                                        }\n                                        {\n                                            this.state.dimensions &&\n                                            this.createNodes()\n                                        }\n                                    </div>\n                                </TransformComponent>\n                            </React.Fragment>\n                        )}\n                </TransformWrapper>\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = (state: State) => {\n    return {\n        graphLoaded: state.graphLoaded,\n        graphLoading: state.graphLoading,\n        isGraphLoadingError: state.isGraphLoadingError,\n        graphLoadingMessage: state.graphLoadingMessage,\n        graphLoadingErrorMessage: state.graphLoadingErrorMessage,\n        graphLoadingRelatedArtistsProgress: state.graphLoadingRelatedArtistsProgress,\n        graph: state.graph,\n        chosenCluster: state.chosenCluster,\n\n        accessToken: state.accessToken,\n        sp: state.spotifyWebApiObject,\n\n        isGraphFromFileLoaded: state.isGraphFromFileLoaded\n    }\n}\n\nconst mapDispatchToProps = (dispatch: any) => {\n    return {\n        setGraph: setGraph,\n        graphFromFileIsLoaded: (isLoaded: boolean) => dispatch(graphFromFileIsLoaded(isLoaded)),\n        loadGraph: (accessToken: string, sp: SpotifyWebApi.SpotifyWebApiJs, callback: Function) => dispatch(loadGraph(accessToken, sp, callback))\n    }\n}\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(DraggableCanvas)\n","import React from 'react'\nimport { connect } from 'react-redux'\nimport { isUndefined } from 'util'\n\nimport { State, SongFull, StringDict, ArtistSimplified, ArtistFull } from '../store/types'\nimport { setPaused } from '../store/actions'\n\nimport './draggable-canvas.css'\nimport './styles.css'\n\ninterface PlayerProps {\n    /** Access token to check */\n    accessToken?: string\n    /** Song that will be played */\n    songToPlay?: SongFull\n    /** Is paused? */\n    paused: boolean\n    /** Function to pause the player */\n    setPaused: Function\n    /** Dict of artists that can appear in the not-liked songs. Necessary to show artists' names. */\n    nonFavouriteArtistDict: StringDict<ArtistSimplified>\n    /** Dict of artists in the user's graph */\n    favouriteArtistDict: StringDict<ArtistFull>\n}\n\n/** Audio player that plays the song given in the state.songToPlay */\nclass Player extends React.Component<PlayerProps, {}> {\n    playerRef: any\n    constructor(props: any) {\n        super(props);\n        this.playerRef = React.createRef();\n    }\n\n    componentDidUpdate() {\n        if (this.playerRef.current !== null) {\n            if (this.props.paused) {\n                this.playerRef.current.pause()\n            }\n            else {\n                this.playerRef.current.play()\n            }\n        }\n    }\n        \n    render() {\n        if (isUndefined(this.props.accessToken)) {\n            return (\n                <div></div>\n            )\n        }\n        else if (isUndefined(this.props.songToPlay)) {\n            return (\n                <div className=\"empty-player\">\n                    <div className=\"generic-description-small-margin\">Choose some artist and some song and listen to a preview</div>\n                </div>\n            )\n        }\n        else {\n            let mp3Link = ''\n            let artistsDescriptionNames = []\n            for (let i = 0; i < this.props.songToPlay.artistsIds.length; i++) {\n                const aID = this.props.songToPlay.artistsIds[i];\n                if (aID in this.props.favouriteArtistDict) {\n                    artistsDescriptionNames.push(this.props.favouriteArtistDict[aID].name)\n                }\n                else if (aID in this.props.nonFavouriteArtistDict) {\n                    artistsDescriptionNames.push(this.props.nonFavouriteArtistDict[aID].name)\n                }\n                else {\n                    artistsDescriptionNames.push(aID)\n                }\n            }\n            const artistsDescription = artistsDescriptionNames.join(', ')\n            mp3Link = this.props.songToPlay.previewLink == null ? '' : this.props.songToPlay.previewLink\n\n            return (\n                <div className=\"player\">\n                    <div className=\"flex1\">\n                        <p className=\"playingSongName\"><b>{this.props.songToPlay.name}</b></p>\n                        <p className=\"playingSongArtists\">{artistsDescription}</p>\n                    </div>\n                    <audio onPlay={() => this.props.setPaused(false)}\n                        onPause={() => this.props.setPaused(true)}\n                        ref={this.playerRef}\n                        autoPlay controls src={mp3Link} className=\"playerControls\"\n                    >\n                        Your browser does not support the\n                        <code>audio</code> element.\n                    </audio>\n                </div>\n            )\n        }\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        paused: state.paused,\n        accessToken: state.accessToken,\n        songToPlay: state.songToPlay,\n        favouriteArtistDict: state.graph.artistDict,\n        nonFavouriteArtistDict: state.nonFavouriteArtistDict\n    }),\n    {\n        setPaused\n    }\n)(Player)\n","import * as React from 'react'\n\nimport DraggableCanvas from './draggable-canvas'\nimport Player from './player'\n\nimport './page-content.css'\n\n/** Wrapper to DraggableCanvas and Player */\nclass PageContent extends React.Component<{}, {}> {\n    render() {\n        return (\n            <div className=\"mainDiv\">\n                <div className=\"mainDivContent\">\n                    <DraggableCanvas/>\n                </div>\n                <Player/>\n            </div>\n        )\n    }\n}\n\nexport default PageContent\n","import * as React from 'react'\nimport { connect } from 'react-redux'\nimport { isUndefined } from 'util'\n\nimport { State, StringDict, ArtistFull, Cluster, Graph } from '../store/types'\nimport { loadGraphFromFile } from '../store/actions'\n\nimport './side-bar.css'\nimport './styles.css'\n\ninterface SideBarProps {\n    /** Chosen cluster if any, otherwise undefined */\n    chosenCluster?: Cluster\n    /** Graph object */\n    graph: Graph\n    /** ArtistDict: [artistId]: ArtistFull */\n    artistDict: StringDict<ArtistFull>\n    /** Function to load parse the graph from the file */\n    loadGraphFromFile: Function\n    /** Was graph loaded */\n    graphLoaded: boolean\n\n    graphLoadingError: boolean\n}\n\ninterface SideBarState { }\n\nclass SideBar extends React.Component<SideBarProps, SideBarState> {\n    constructor(props: SideBarProps) {\n        super(props);\n        this.dowloadGraph = this.dowloadGraph.bind(this)\n        this.uploadGraph = this.uploadGraph.bind(this)\n    }\n\n    /** Downloads graph to json file */\n    dowloadGraph() {\n        if (!this.props.graph) return\n\n        const element = document.createElement('a');\n        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(JSON.stringify(this.props.graph, null, 4)));\n        element.setAttribute('download', 'mySpotifyGraph.json');\n        element.style.display = 'none';\n        document.body.appendChild(element);\n        element.click();\n        document.body.removeChild(element);\n    }\n\n    /** Loads a graph from a given file */\n    uploadGraph(selectorFiles: FileList) {\n        const corruptedFileAlert = 'Sorry, this file seems to be not in the correct format.\\n Error:'\n        console.log(selectorFiles)\n        const file = selectorFiles[0]\n        const reader = new FileReader()\n        const loadGraphFromFileFunc = (g: Graph) => (this.props.loadGraphFromFile(g))\n\n        reader.onload = function (event) {\n            if (event.target !== null && event.target.result !== null) {\n                try {\n                    const resultString = event.target.result.toString()\n                    const resultJSON = isUndefined(resultString) ? {} : JSON.parse(resultString)\n                    const g: Graph = resultJSON\n                    loadGraphFromFileFunc(g)\n                } catch (error) {\n                    alert(corruptedFileAlert + error)\n                    console.debug('error while graph loading from file:', error)\n                }\n            }\n            else {\n                alert(corruptedFileAlert)\n            }\n        };\n\n        reader.readAsText(file);\n    }\n\n    /** Enlists names of artists of the chosen cluster */\n    createChosenClusterArtists(): JSX.Element {\n        if (isUndefined(this.props.chosenCluster)) return <div></div>\n\n        return (\n            <ul>{this.props.chosenCluster.artistsIds.map(id =>\n                <li className=\"shift-left\">\n                    {this.props.artistDict[id].name}\n                </li>)}\n            </ul>\n        )\n    }\n\n    /** Enlists genres of artists of the chosen cluster */\n    createChosenClusterGenres(): JSX.Element {\n        let properties: JSX.Element[] = []\n        if (this.props.chosenCluster !== undefined) {\n            properties = this.props.chosenCluster.genres.map(a => <li className=\"shift-left\">{a}</li>)\n        }\n        return <ul>{properties}</ul>\n    }\n\n    render() {\n        return (\n            <div className=\"sideBar\">\n                <div className=\"sideBarHeader\">\n                    <img width={40} height={40} className=\"spotify-image\" alt=\"\" src=\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Ik0xOS4wOTggMTAuNjM4Yy0zLjg2OC0yLjI5Ny0xMC4yNDgtMi41MDgtMTMuOTQxLTEuMzg3LS41OTMuMTgtMS4yMi0uMTU1LTEuMzk5LS43NDgtLjE4LS41OTMuMTU0LTEuMjIuNzQ4LTEuNCA0LjIzOS0xLjI4NyAxMS4yODUtMS4wMzggMTUuNzM4IDEuNjA1LjUzMy4zMTcuNzA4IDEuMDA1LjM5MiAxLjUzOC0uMzE2LjUzMy0xLjAwNS43MDktMS41MzguMzkyem0tLjEyNiAzLjQwM2MtLjI3Mi40NC0uODQ3LjU3OC0xLjI4Ny4zMDgtMy4yMjUtMS45ODItOC4xNDItMi41NTctMTEuOTU4LTEuMzk5LS40OTQuMTUtMS4wMTctLjEyOS0xLjE2Ny0uNjIzLS4xNDktLjQ5NS4xMy0xLjAxNi42MjQtMS4xNjcgNC4zNTgtMS4zMjIgOS43NzYtLjY4MiAxMy40OCAxLjU5NS40NC4yNy41NzguODQ3LjMwOCAxLjI4NnptLTEuNDY5IDMuMjY3Yy0uMjE1LjM1NC0uNjc2LjQ2NS0xLjAyOC4yNDktMi44MTgtMS43MjItNi4zNjUtMi4xMTEtMTAuNTQyLTEuMTU3LS40MDIuMDkyLS44MDMtLjE2LS44OTUtLjU2Mi0uMDkyLS40MDMuMTU5LS44MDQuNTYyLS44OTYgNC41NzEtMS4wNDUgOC40OTItLjU5NSAxMS42NTUgMS4zMzguMzUzLjIxNS40NjQuNjc2LjI0OCAxLjAyOHptLTUuNTAzLTE3LjMwOGMtNi42MjcgMC0xMiA1LjM3My0xMiAxMiAwIDYuNjI4IDUuMzczIDEyIDEyIDEyIDYuNjI4IDAgMTItNS4zNzIgMTItMTIgMC02LjYyNy01LjM3Mi0xMi0xMi0xMnoiLz48L3N2Zz4=\"></img>\n                    <h1>Spotify graph</h1>\n                </div>\n                <div>Graph of your musical taste ♬♫</div>\n\n                {\n                    this.props.graphLoaded &&\n                    <div className=\"download-button pointer\" onClick={this.dowloadGraph}>\n                        Download graph to JSON\n                    </div>\n                }\n                {\n                    (this.props.graphLoaded || this.props.graphLoadingError )&&\n                    <input className=\"download-button\" type=\"file\" accept=\".json\" onChange={(e) => {\n                        if (e.target.files !== null) this.uploadGraph(e.target.files)\n                    }} />\n                }\n\n                <div className=\"sideBarContent\">\n                    {\n                        this.props.chosenCluster &&\n                        <div className=\"box-with-margin\">\n                            <h2>mostly these genres</h2>\n                            {this.createChosenClusterGenres()}\n                        </div>\n                    }\n                    {\n                        this.props.chosenCluster &&\n                        <div className=\"box-with-margin\">\n                            <h2 className=\"text-align-center\">group of artists</h2>\n                            {this.createChosenClusterArtists()}\n                        </div>\n                    }\n\n                    {!!!this.props.chosenCluster && this.props.graph &&\n                        <div className=\"box-with-margin\">\n                            <p>We took the artists from your <b>liked</b> songs and the artists that <b>you follow</b>.</p>\n                            <p>We found <b>{Object.values(this.props.graph.artistDict).length} artist</b> that you like.</p>\n                            <p>We divided them into clusters you're seing right now. The clusters are based on <b>genres</b> and <b>preferences</b> of other users of Spotify</p>\n                            <p>Click the cluster and explore how the artists are connected.</p>\n                        </div>\n                    }\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        chosenCluster: state.chosenCluster,\n        graph: state.graph,\n        sp: state.spotifyWebApiObject,\n        artistDict: state.graph.artistDict,\n        graphLoaded: state.graphLoaded,\n        graphLoadingError: state.isGraphLoadingError\n    }),\n    {\n        loadGraphFromFile\n    }\n)(SideBar)\n","import React from 'react'\nimport { Redirect } from \"react-router-dom\";\nimport { connect } from 'react-redux'\nimport { withRouter } from \"react-router-dom\";\nimport { RouteComponentProps } from \"react-router\";\n\nimport PageContent from './page-content'\nimport SideBar from './side-bar'\nimport { State } from '../store/types'\nimport { setAccessToken } from '../store/actions'\n\nimport '../App.css'\n\ninterface MyGraphPageProps extends RouteComponentProps<any> {\n    setAccessToken: typeof setAccessToken\n}\n\ninterface MyGraphPageState {\n    loggingLoading: boolean\n    loggingFailed: boolean\n}\n\n/** The base page. Wrapper to SideBar and PageContent */\nclass MyGraphPage extends React.Component<MyGraphPageProps, MyGraphPageState> {\n    constructor(props: MyGraphPageProps) {\n        super(props);\n        this.state = {\n            loggingLoading: true,\n            loggingFailed: false\n        }\n        /* eslint-disable react/no-direct-mutation-state */\n        this.afterSpotifyLogin()\n    }\n\n    afterSpotifyLogin() {\n        const urlParams = window.location.search\n        var query = urlParams.substr(1);\n        var result: any = {};\n        query.split(\"&\").forEach(function (part: string) {\n            var item = part.split(\"=\");\n            result[item[0]] = decodeURIComponent(item[1]);\n        })\n        if (!('code' in result) || result['code'] === '' || result['code'] === null) {\n            this.state = { loggingFailed: true, loggingLoading: false }\n            return\n        }\n\n        const currentPathName = this.props.history.location.pathname\n        this.props.history.push({\n            pathname: currentPathName,\n            search: ''\n        })\n\n        const linkToBackendWithoutCode = process.env.NODE_ENV === \"production\" ? process.env.REACT_APP_PROD_BACKEND_URL_LOGGED_IN : process.env.REACT_APP_DEV_BACKEND_URL_LOGGED_IN\n        const linkToBackend = linkToBackendWithoutCode + result['code']\n        let accessToken: string = ''\n        fetch(linkToBackend)\n            .then((response) => {\n                if (response.status !== 200) {\n                    throw response.status\n                }\n                const tryAccessToken = response.headers.get('access-token')\n                if (tryAccessToken !== null) {\n                    accessToken = tryAccessToken\n                    this.props.setAccessToken(accessToken)\n                }\n\n                this.setState({ loggingLoading: false })\n            })\n            .catch((error) => {\n                console.debug(error)\n                this.setState({ loggingFailed: true, loggingLoading: false })\n                alert('Sorry, we did not manage to log you in Spotify.')\n            })\n    }\n\n    render() {\n        if (this.state.loggingLoading) {\n            return (\n                <div className=\"App\">\n                    <div className=\"page-wrapper\">\n                        <div className=\"loader\" />\n                        <div className=\"generic-description\">Logging into Spotify</div>\n                    </div>\n                </div>\n            )\n        }\n\n        if (this.state.loggingFailed) {\n            return <Redirect to=\"/login\" />\n        }\n\n        return (\n            <div className=\"App\">\n                <SideBar />\n                <PageContent />\n            </div>\n        )\n    }\n}\n\nexport default withRouter<MyGraphPageProps, any>(\n    connect(\n        (state: State) => ({}),\n        (dispatch: any) => ({\n            setAccessToken: (accessToken: string) => dispatch(setAccessToken(accessToken)),\n        })\n    )(MyGraphPage)\n)\n","import React from 'react'\nimport { Provider } from 'react-redux'\nimport { createStoreInstance } from './store/reducers'\nimport { BrowserRouter, Switch, Route } from \"react-router-dom\";\nimport WelcomePage from './components/welcome-page'\nimport './App.css'\nimport LoginPage from './components/login-page'\nimport MyGraphPage from './components/my-graph-page';\n\nexport const storeInstance = createStoreInstance()\n\nconst App: React.FC = () => {\n    return (\n        <Provider store={storeInstance}>\n            <BrowserRouter basename={process.env.PUBLIC_URL}>\n                <Switch>\n                    <Route path=\"/login\" component={LoginPage} />\n                    <Route path=\"/mygraph\" component={MyGraphPage} />\n                    <Route path=\"/\" component={WelcomePage} />\n                </Switch>\n            </BrowserRouter>\n        </Provider>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n// import * as serviceWorker from './serviceWorker';\n\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}