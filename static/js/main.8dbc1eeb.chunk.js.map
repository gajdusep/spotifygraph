{"version":3,"sources":["store/reducers.tsx","components/welcome-page.tsx","components/login-page.tsx","methods/graph-parsing-methods.tsx","methods/spotify-methods.tsx","store/types.tsx","store/actions.tsx","methods/graph-layout.tsx","methods/edge-calculation.tsx","components/artist-edge.tsx","methods/colors.tsx","components/artist-node.tsx","components/chosen-cluster-graph.tsx","components/chosen-artist-bar.tsx","components/chosen-cluster.tsx","components/cluster-node.tsx","components/cluster-edge.tsx","components/progress-bar.tsx","components/draggable-canvas.tsx","components/player.tsx","components/page-content.tsx","components/side-bar.tsx","components/my-graph-page.tsx","App.tsx","index.tsx"],"names":["middleWare","loggerMiddleware","createLogger","predicate","getState","action","process","collapsed","push","thunk","getInitialState","isGraphLoadingError","graphLoaded","graphLoading","chosenArtistLoading","userLoggedIn","graph","clusters","clusterEdges","artistEdges","clusterSquares","artistDict","spotifyWebApiObject","SpotifyWebApi","graphLoadingRelatedArtistsProgress","graphLoadingMessage","paused","isGraphFromFileLoaded","nonFavouriteArtistDict","rootReducer","state","reducer","WelcomePage","props","className","onClick","history","React","Component","withRouter","connect","loggedIn","LoginPage","p","params","client_id","response_type","redirect_uri","scope","join","Object","entries","map","kv","encodeURIComponent","window","location","assign","this","spotifyLoginLink","loginWithSpotify","parseClusters","artistsDict","clusterJsons","i","length","key","id","clusterArtists","clusterArtistsPositions","artistsPositions","artistsSpotifyId","artistPosition","x","y","sort","a","b","score","currCluster","genres","artistsIds","aFull","country","processClusterPositions","positions","square","clusterSquare","values","asyncTimeout","ms","Promise","resolve","setTimeout","getCookie","name","document","cookie","xsrfCookies","split","c","trim","filter","startsWith","decodeURIComponent","songFromJSONData","element","preview_url","console","debug","previewLink","artists","externalUrl","external_urls","spotify","getFollowedArtistsIds","sp","limit","result","maxRetries","after","success","retries","options","getFollowedArtists","response","getResponseHeader","parseInt","headers","isUndefined","items","artObj","cursors","getAllRelatedArtists","artistsToExploreIds","alreadyLoadedRelatedArtists","progressBarCallback","artistsToExploreLen","aID","getArtistRelatedArtists","obtainedRelArtists","objectFull","getLikedSongs","offset","next","getMySavedTracks","trackObj","track","getArtistsIdsFromLikedSongs","likedSongs","likedSongsArtistsIdsNonDistinct","objectTrackFull","reduce","acc","currVal","concat","artistObjectSimplified","Set","getAllArtistsFull","allArtistsIds","getArtists","slice","createArtistDictWithFullInformation","artistsFull","relatedArtistsFinal","followedArtistsIdsSet","dictToReturn","artist","artistImage","images","url","isFollowed","has","popularity","followedScore","image","relatedArtistsIds","song","j","songArtist","simplArtist","art","dictArtistFullToReduced","artistsDictFull","artistsDictReduced","artFull","fetchAllDataFromSpotify","accessToken","setGraphLoadingMessageFunction","setGraphLoadingProgress","setGraphLoadingError","setAccessToken","likedSongsArtistsIds","followedArtistsIds","relatedArtistsStorageName","storageRelatedArtistsValue","localStorage","getItem","JSON","parse","setItem","stringify","csfrtoken","calculateGraphLink","jsonReponse","fetch","method","body","fetchReponse","ok","json","Error","status","statusText","text","artistEdgesJSONs","edge","id1","id2","weight","clusterEdgesJsons","g","PositionType","t","SongFullType","ArtistFullType","ArtistEdgeType","ClusterType","type","optional","ClusterEdgeType","GraphType","setChosenArtist","payload","produce","chosenArtist","setChosenCluster","cluster","chosenCluster","setGraph","setGraphLoadingMessage","message","setGraphLoadingErrorMessage","errorMessage","graphLoadingErrorMessage","progress","graphLoadingSuccess","setChosenArtistError","error","chosenArtistError","setChosenArtistLoading","loading","setChosenArtistData","artistData","chosenArtistData","setPaused","graphFromFileIsLoaded","isLoaded","getBigComponentsPositions","bigClusterSquares","finalPositions","screenParams","clusterId","clusterPosition","newX","width","clusterWidth","newY","height","tryFillFreeSpace","clusterInComponent","clusterComponents","freeRectMatrix","possibleRectanglePositions","notUsedClusterComponents","freeRectMatrixRows","freeRectMatrixCols","wholeLoop","foundSomeCoords","clusterComponent","rowLoop","row","col","coordCombinations","coordIndex","coordArray","isLegit","every","rIndex","cIndex","clusterIds","keys","k","rect","left","top","notUsedIndex","getRestComponentsPositions","oneClusterComponents","twoClusterComponents","threeClusterComponents","currentHeight","rectangles","pos","clusterHeigth","getPossibleFreePositions","notUsedThreeClusterComponents","notUsedTwoClusterComponents","notUsedOneClusterComponents","newRects","currentY","currentX","middleX","middleY","circleRadius","angle","Math","random","coords","cos","PI","sin","squareChange","clusterRect","hasCollisions","computeHeigthFromPositions","maxY","_colliding","start1","end1","start2","end2","rects","res","r","rect2","rect1","clusterHeight","numberToWidth","floor","numberToheight","noRectangles","computeEdgeCoordinates","x1","y1","x2","y2","thickness","wid","hei","y1fin","y2fin","x1fin","x2fin","ArtistEdge","weigth","st","artistWidth","edgeColor","maximumEdgeWeigth","style","d","strokeWidth","fill","stroke","COLORS","lightAzureBlue","darkAzureBlue","pink","green","grey","ArtistNode","currentPositionX","positionX","currentPositionY","positionY","dragging","onDrag","bind","onStop","e","ui","stopPropagation","preventDefault","setState","newCurrX","deltaX","newCurrY","deltaY","positionChangedCallback","handleClick","setChosenArtistDataAllFunc","color","artistImageDivStyle","backgroundImage","backgroundSize","borderRadius","alignSelf","minimumScore","bounds","defaultPosition","backgroundColor","dispatch","s","notLikedSongs","artistToUpdate","areSongsEqual","s1","s2","getArtistTopTracks","then","topTracks","currentArtistId","currArtistToUpdate","tracks","songToCheck","indexOfLiked","findIndex","likedSong","artistsToUpdate","currentNotFavouriteDict","favouriteDict","catch","finally","setChosenArtistDataAll","ChosenClusterGraph","boxRef","wrapperRef","getSliderLimits","artistsSliderLimits","edgesSliderLimits","currSliderValue","nodes","artistSliderValue","minimum","edgesSliderValue","descriptionHover","minimumEdgeWeight","maximumEdges","createRef","positionChangedHandler","changeArtistSliderValue","changeEdgeSliderValue","prevprops","prevstate","graphElements","prepareAfterGraphDataUpdate","prepareAfterSliderUpdate","current","clientWidth","clientHeight","createdNodes","createNodes","elem","newArtistsPositions","compX","position","compY","maximum","artistScore","edgesValues","edges","el","ceil","l","artist_id","node1id","node2id","edgeWeigth","clusterEdgeKey","node1","idArtistDict","node2","err","currentTarget","valueAsNumber","min","max","step","value","onChange","showDescriptionStyle","display","handle","createEdgeSlider","createArtistSlider","onMouseEnter","changeHover","onMouseLeave","size","ref","getDraggableSlider","createEdges","ChosenArtistBar","prepareSongs","liked","notLiked","chosenSongId","songId","prevProps","prevState","includes","maxHeight","playerIcon","setSongToPlay","chosenSongColorIndicator","songToPlay","setPause","likedSongColorIndicator","alert","setChosenSong","marginRight","flexDirection","justifyContent","alignContent","open","spotifyApiObject","addToMySavedTracks","likedSongsOld","notLikedSongsOld","songs","toReturn","getSongDiv","margin","getSongsDivs","ChosenCluster","closeChosenClusterGraph","closeChosenArtist","elements","getChosenClusterGraphElements","currArtistId","clusterEdgesWithChosenCluster","clusterEdge","similarClusters","artistDivStyle","secondId","similarCluster","indexOf","similarClusterArtistsElements","artistId","currArtist","artistDivStyleNew","title","getSimilarClusters","undefined","countries","require","registerLocale","ClusterNode","fontSizeDefault","oldX","oldY","positionChanged","imgSize","rows","numberOfArtists","currKey","createArtistWrapper","createEmptyWrapper","headerString","numberOfGenres","fontSizeConst","wrapperStyle","opacity","zIndex","alignItems","countryCode","alpha3ToAlpha2","svg","fontSize","clusterDiv","onStart","ClusterEdge","ProgressBar","DraggableCanvas","currentScale","originalRefHeight","originalRefWidth","clusterPositions","newHeight","toRet","bigComponent","clustersInSquares","computeClusterPositions","newHeigth","dimensions","w","h","origWidth","origHei","newWidth","currentPositions","ratio","addEventListener","onResizeRecomputePositions","loadGraph","graphLoadedCallback","source","target","log2","createGraphLoadingDiv","createSpotifyErrorDiv","clusterIsChosen","defaultScale","defaultPositionX","defaultPositionY","maxScale","limitToWrapper","onWheelStop","scale","zoomIn","zoomOut","setTransform","Fragment","callback","Player","playerRef","pause","play","mp3Link","artistsDescriptionNames","favouriteArtistDict","artistsDescription","onPlay","onPause","autoPlay","controls","src","PageContent","SideBar","dowloadGraph","uploadGraph","createElement","setAttribute","appendChild","click","removeChild","selectorFiles","corruptedFileAlert","log","file","reader","FileReader","onload","event","resultString","toString","loadGraphFromFile","loadGraphFromFileFunc","readAsText","properties","alt","graphLoadingError","accept","files","createChosenClusterGenres","createChosenClusterArtists","jsonToParse","decode","isRight","MyGraphPage","loggingLoading","loggingFailed","afterSpotifyLogin","query","search","substr","forEach","part","item","currentPathName","pathname","linkToBackend","tryAccessToken","get","to","storeInstance","createStore","compose","applyMiddleware","App","store","basename","path","component","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.8dbc1eeb.chunk.js","sourcesContent":["import { createStore, applyMiddleware, compose } from 'redux';\nimport { State, ActionWrapper } from './types';\nimport thunk from 'redux-thunk';\nimport { createLogger } from 'redux-logger';\nimport SpotifyWebApi from 'spotify-web-api-js'\n\nconst middleWare: any = [];\nconst loggerMiddleware = createLogger({\n    predicate: (getState: Function, action: ActionWrapper) => process.env.NODE_ENV === 'development' && action.type !== 'SET_GRAPH_LOADING_MESSAGE',\n    collapsed: (getState, action) => true\n});\nmiddleWare.push(thunk)\nmiddleWare.push(loggerMiddleware)\n\n\nconst getInitialState = (): State => {\n    return ({\n        isGraphLoadingError: false,\n        graphLoaded: false,\n        graphLoading: false,\n        chosenArtistLoading: false,\n        userLoggedIn: false,\n        graph: ({ clusters: [], clusterEdges: [], artistEdges: [], clusterSquares: [], artistDict: {} }),\n        spotifyWebApiObject: new SpotifyWebApi(),\n        graphLoadingRelatedArtistsProgress: 0,\n        graphLoadingMessage: \"\",\n        paused: false,\n        isGraphFromFileLoaded: false,\n        nonFavouriteArtistDict: {}\n    })\n}\n\nconst rootReducer = (\n    state: State = getInitialState(),\n    action: ActionWrapper<any>\n) => {\n    if (!action.reducer) return state\n    else return action.reducer(state)\n}\n\nconst createStoreInstance = () => createStore(\n    rootReducer,\n    getInitialState(),\n    compose(\n        applyMiddleware(...middleWare)\n    ))\n\nexport { createStoreInstance }\n","/* eslint-disable @typescript-eslint/no-useless-constructor */\n\nimport React from 'react'\nimport { connect } from 'react-redux'\nimport { withRouter } from 'react-router-dom'\nimport { RouteComponentProps } from 'react-router'\n\nimport { State } from '../store/types'\n\nimport './welcome-page.css'\nimport '../App.css'\n\ninterface WelcomePageProps extends RouteComponentProps<any> {\n    loggedIn: boolean\n}\n\nclass WelcomePage extends React.Component<WelcomePageProps, {}> {\n    constructor(props: WelcomePageProps) {\n        super(props);\n    }\n\n    render() {\n        return (\n            <div className=\"App\">\n                <div className=\"page-wrapper\">\n                    <div className=\"page-description-div\">\n                        <h1>Spotify graph</h1>\n                        <p>A project that will show you your musical taste.</p>\n                        <p>We will fetch data from your spotify account, divide them into groups and visualize these groups in form of a graph.</p>\n                    </div>\n                    <button className=\"very-big-button\" onClick={() => { this.props.history.push('/login') }}>Continue to get your graph</button>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default withRouter<WelcomePageProps, any>(\n    connect(\n        (state: State) => ({\n            loggedIn: state.userLoggedIn\n        }),\n        {}\n    )(WelcomePage))\n","/* eslint-disable @typescript-eslint/no-useless-constructor */\n\nimport React from 'react'\n\nimport './welcome-page.css'\nimport '../App.css'\n\ninterface LoginPageProps { }\n\ninterface LoginPageState {}\n\n/** Login page that redirects to Spotify login page. */\nexport default class LoginPage extends React.Component<LoginPageProps, LoginPageState> {\n    constructor(props: LoginPageProps) {\n        super(props);\n    }\n\n    /** Creates Spotify login link with all necessary parameters */\n    spotifyLoginLink() {\n        const client_id = 'dfb05fa5c36b41d48407ad5e3773d39b'\n        const scope = [\n            'streaming',\n            'user-read-email',\n            'user-read-private',\n            'user-read-playback-state',\n            'user-modify-playback-state',\n            'user-library-read',\n            'user-library-modify',\n            'user-follow-read',\n            'playlist-modify-private',\n            'playlist-read-private',\n        ]\n        const state = 'rndstringsomehash'\n        const redirect_uri = process.env.NODE_ENV === \"production\" ?\n            process.env.REACT_APP_PROD_SPOTIFY_REDIRECT_URL : process.env.REACT_APP_DEV_SPOTIFY_REDIRECT_URL\n        const params = {\n            client_id:client_id,\n            response_type:'code',\n            redirect_uri:redirect_uri,\n            scope:scope.join(' '),\n            state:state,\n        }\n\n        const encodeGetParams = (p:Object): string =>\n            Object.entries(p).map(kv => kv.map(encodeURIComponent).join(\"=\")).join(\"&\");\n\n        const link = 'https://accounts.spotify.com/authorize?' + encodeGetParams(params)\n        return link\n    }\n\n    loginWithSpotify() {\n        window.location.assign(this.spotifyLoginLink())\n    }\n\n    render() {\n        return (\n            <div className=\"App\">\n                <div className=\"page-wrapper\">\n                    <div className=\"generic-description\">\n                        <div>Please login with your spotify account</div>\n                    </div>\n                    <button className=\"very-big-button\" onClick={() => this.loginWithSpotify()}>Log in with your Spotify account</button>\n                </div>\n            </div>\n        )\n    }\n}\n","import { ArtistFull, Cluster, ArtistEdge, ClusterEdge, ClusterSquare, StringDict, Position, NumberDict } from '../store/types'\n\n/* ALL THE FOLLOWING METHODS ARE PARSING THE JSONS\n   THAT WERE RECEIVED FROM THE BACKEND\n*/ \n \ninterface clusterJson {\n    id: string\n    genres: string[]\n    country: string\n    artistsPositions: NumberDict<Position>\n}\n\n/** Parses clusters */\nexport const parseClusters = (artistsDict: StringDict<ArtistFull>, clusterJsons: clusterJson[]): Cluster[] => {\n    let clusters: Cluster[] = []\n    for (let i = 0; i < clusterJsons.length; i++) {\n        const key = clusterJsons[i].id\n\n        // prepare the cluster artists:\n        const clusterArtists: ArtistFull[] = []\n        const clusterArtistsPositions: StringDict<Position> = {}\n\n        for (const [artistsSpotifyId, artistPosition] of Object.entries(clusterJsons[i].artistsPositions)) {\n            clusterArtists.push(artistsDict[artistsSpotifyId])\n            clusterArtistsPositions[artistsSpotifyId] = { x: artistPosition.x, y: artistPosition.y }\n        }\n\n        clusterArtists.sort((a, b) => { return b.score - a.score })\n\n        const currCluster: Cluster = ({\n            id: key,\n            genres: clusterJsons[i].genres,\n            artistsIds: clusterArtists.map(aFull => aFull.id),\n            artistsPositions: clusterArtistsPositions,\n            country: clusterJsons[i].country\n        })\n        clusters.push(currCluster)\n    }\n    return clusters\n}\n\ninterface ClusterSquareJSON {\n    [id: string]: { x: number, y: number }\n}\n\n/** Parses cluster positions */\nexport const processClusterPositions = (positions: ClusterSquareJSON[]): ClusterSquare[] => {\n    let clusterSquares: ClusterSquare[] = []\n    for (let i = 0; i < positions.length; i++) {\n\n        const square = positions[i]\n        const clusterSquare: ClusterSquare = {};\n        if (Object.values(square).length > 0) {\n            for (let id in square) {\n                let x = square[id].x\n                let y = square[id].y\n                clusterSquare[id] = { x: x, y: y }\n            }\n            clusterSquares.push(clusterSquare)\n        }\n    }\n\n    return clusterSquares\n}\n\ninterface ClusterEdgeJSON {\n    id1: string,\n    id2: string,\n    weight: number\n}\n\n/** Parses cluster edges */\nexport const parseClusterEdges = (clusterEdgesJsons: ClusterEdgeJSON[]): ClusterEdge[] => {\n    return clusterEdgesJsons.map(element => ({ id1: element.id1, id2: element.id2, weight: element.weight })\n    )\n}\n\ninterface ArtistEdgeJSON {\n    id1: string,\n    id2: string,\n    weight: number\n}\n\n/** Parses artist edges */\nexport const parseArtistEdges = (artistEdgesJSONs: ArtistEdgeJSON[]): ArtistEdge[] => {\n    let artistEdges: ArtistEdge[] = artistEdgesJSONs.map((edge) => ({ id1: edge.id1, id2: edge.id2, weight: edge.weight }))\n    return artistEdges\n}\n","import SpotifyWebApi from 'spotify-web-api-js'\nimport { ArtistFull, ArtistReduced, StringDict, Graph, SongFull } from '../store/types';\nimport { processClusterPositions, parseClusters, parseClusterEdges, parseArtistEdges } from './graph-parsing-methods'\nimport { isUndefined } from 'util';\n\n// requests retry interval\nconst RETRY_INTERVAL = 4000\n\n// parameters for score computing\nconst isFollowedConst = 5\nconst likedSongConst = 1\nconst spotifyPopularityConst = 0.1\n\nconst asyncTimeout = (ms: number) => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nconst getCookie = (name: string): string => {\n    if (!document.cookie) {\n        return ''\n    }\n\n    const xsrfCookies = document.cookie.split(';')\n        .map(c => c.trim())\n        .filter(c => c.startsWith(name + '='));\n\n    if (xsrfCookies.length === 0) {\n        return ''\n    }\n    return decodeURIComponent(xsrfCookies[0].split('=')[1]);\n}\n\n/** Translates SpotifyAPI TrackObjectFull to SongFUll */\nexport const songFromJSONData = (element: SpotifyApi.TrackObjectFull): SongFull => {\n    if (element.preview_url === null) {\n        console.debug(element.id, ':', element.name, element)\n    }\n\n    return {\n        name: element.name,\n        id: element.id,\n        previewLink: element.preview_url,\n        artistsIds: element.artists.map(a => a.id),\n        externalUrl: element.external_urls.spotify\n    }\n}\n\n/**\n * Fetches all artists followed by the logged-in user\n * @param sp SpotifyWebApiJs object\n * @returns IDs of followed artists\n */\nconst getFollowedArtistsIds = async (sp: SpotifyWebApi.SpotifyWebApiJs\n): Promise<string[]> => {\n    let limit = 50\n    let result: string[] = []\n\n    let response\n    const maxRetries = 3\n    let after = null\n    do {\n        let success = true\n        let retries = 0\n        do {\n            try {\n                const options: {} = after ? { limit: limit, after: after } : { limit: limit }\n                response = await sp.getFollowedArtists(options)\n            } catch (err) {\n                await asyncTimeout(err.getResponseHeader['retry-after'] ? parseInt(err.headers['retry-after'] + 1) * 1000 : RETRY_INTERVAL);\n                success = false\n                retries += 1\n            }\n        } while (success === false && retries < maxRetries)\n\n        // the request was not successfull even after retries\n        if (isUndefined(response)) {\n            after = null\n        }\n        else {\n            result.push(...response.artists.items.map((artObj: SpotifyApi.ArtistObjectFull) => artObj.id))\n            after = response.artists.cursors.after\n        }\n    } while (after)\n\n    return result\n}\n\n/**\n  * Fetches related artists of the given artists\n  * @param sp SpotifyWebApiJs object\n  * @param artistsToExploreIds list of artist IDs - we will get related artists information from them\n  * @param alreadyLoadedRelatedArtists already saved related artists from the localStorage\n  * @param progressBarCallback callback to be called to let progress bar know about the progress\n  * @returns list of lists of IDs, the order of related artists is the same as in the artistsToExploreIds list\n  */\nconst getAllRelatedArtists = async (\n    sp: SpotifyWebApi.SpotifyWebApiJs,\n    artistsToExploreIds: string[],\n    alreadyLoadedRelatedArtists: StringDict<string[]>,\n    progressBarCallback: Function\n): Promise<string[][]> => {\n    const result: string[][] = []\n    const maxRetries = 3\n    const artistsToExploreLen = artistsToExploreIds.length\n\n    for (let i = 0; i < artistsToExploreLen; i++) {\n        const aID = artistsToExploreIds[i]\n        progressBarCallback(i / artistsToExploreLen)\n\n        if (aID in alreadyLoadedRelatedArtists) {\n            result.push(alreadyLoadedRelatedArtists[aID])\n        } else {\n            let response\n            let success = true\n            let retries = 0\n            do {\n                try {\n                    response = await sp.getArtistRelatedArtists(aID)\n                } catch (err) {\n                    await asyncTimeout(err.getResponseHeader['retry-after'] ? parseInt(err.headers['retry-after'] + 1) * 1000 : RETRY_INTERVAL);\n                    success = false\n                    retries += 1\n                }\n            } while (success === false && retries < maxRetries)\n\n            if (isUndefined(response)) {\n                result.push([])\n            }\n            else {\n                const obtainedRelArtists = response.artists.map((objectFull) => objectFull.id)\n                alreadyLoadedRelatedArtists[aID] = obtainedRelArtists\n                result.push(obtainedRelArtists)\n            }\n        }\n    }\n    return result\n}\n\n/**\n * Gets all liked songs of the logged-in user\n * @param sp SpotifyWebApiJs object\n * @returns Promise of list of TrackObjectFull\n */\nconst getLikedSongs = async (sp: SpotifyWebApi.SpotifyWebApiJs\n): Promise<SpotifyApi.TrackObjectFull[]> => {\n    let offset = 0\n    let limit = 50\n    let result: SpotifyApi.TrackObjectFull[] = []\n\n    let response\n    const maxRetries = 3\n    let next = null\n    do {\n        let success = true\n        let retries = 0\n        do {\n            try {\n                response = await sp.getMySavedTracks({ limit: 50, offset: offset })\n            } catch (err) {\n                await asyncTimeout(err.getResponseHeader['retry-after'] ? parseInt(err.headers['retry-after'] + 1) * 1000 : RETRY_INTERVAL);\n                success = false\n                retries += 1\n            }\n        } while (success === false && retries < maxRetries)\n\n        // the request was not successfull even after retries\n        if (isUndefined(response)) {\n            next = null\n        }\n        else {\n            offset += limit\n            result.push(...response.items.map((trackObj: SpotifyApi.SavedTrackObject) => trackObj.track))\n            next = response.next\n        }\n    } while (next)\n\n    return result\n}\n\n/**\n * Separates artist IDs from the track objects\n * @param likedSongs list of TrackObjectFull\n * @returns list of IDs of artists in the likedSongs\n */\nconst getArtistsIdsFromLikedSongs = (likedSongs: SpotifyApi.TrackObjectFull[]) => {\n    const likedSongsArtistsIdsNonDistinct =\n        likedSongs.map((objectTrackFull) => objectTrackFull.artists)\n            .reduce((acc, currVal) => acc.concat(currVal), [])\n            .map((artistObjectSimplified) => artistObjectSimplified.id)\n    return [...new Set(likedSongsArtistsIdsNonDistinct)]\n}\n\n/**\n * Fetches the full information about the artists given in parameter\n * @param sp SpotifyWebApiJs object\n * @param allArtistsIds list of IDs of artists to be obtained\n * @returns list of ArtistObjectFull\n */\nconst getAllArtistsFull = async (sp: SpotifyWebApi.SpotifyWebApiJs, allArtistsIds: string[])\n    : Promise<SpotifyApi.ArtistObjectFull[]> => {\n    const result: SpotifyApi.ArtistObjectFull[] = []\n    const maxRetries = 3\n    let offset = 0\n    let limit = 50\n\n    do {\n        let response\n        let success = true\n        let retries = 0\n        do {\n            try {\n                response = await sp.getArtists(allArtistsIds.slice(offset, offset + limit))\n            } catch (err) {\n                await asyncTimeout(err.getResponseHeader['retry-after'] ? parseInt(err.headers['retry-after'] + 1) * 1000 : RETRY_INTERVAL);\n                success = false\n                retries += 1\n            }\n        } while (success === false && retries < maxRetries)\n\n        if (isUndefined(response)) {\n            // TODO what here?\n        } else {\n            result.push(...response.artists)\n            offset += limit\n        }\n\n    } while (offset < allArtistsIds.length)\n\n    return result\n}\n\n/**\n * Creates Artist Dictionary: [artistId]:ArtistFull\n * @param artistsFull ArtistObjectFull objects\n * @param relatedArtistsFinal related artists corresponding to the artistsFull list\n * @param followedArtistsIdsSet IDs of artists that are followed by the logged-in user\n * @param likedSongs songs liked by the logged-in user\n */\nconst createArtistDictWithFullInformation = (\n    artistsFull: SpotifyApi.ArtistObjectFull[],\n    relatedArtistsFinal: string[][],\n    followedArtistsIdsSet: Set<string>,\n    likedSongs: SpotifyApi.TrackObjectFull[]\n): StringDict<ArtistFull> => {\n    if (artistsFull.length !== relatedArtistsFinal.length) {\n        console.debug('ERROR: NOT EVERY ARTIST HAS RELATED ARTISTS')\n        return {}\n    }\n\n    // add every artists to the dictionary\n    const dictToReturn: StringDict<ArtistFull> = {}\n    for (let i = 0; i < artistsFull.length; i++) {\n        const artist = artistsFull[i];\n        const artistImage = artist.images && artist.images.length > 0 ? artist.images[artist.images.length - 1].url : ''\n        const isFollowed = followedArtistsIdsSet.has(artist.id)\n\n        const popularity = artist.popularity\n        const followedScore = isFollowed ? isFollowedConst : 0\n\n        dictToReturn[artist.id] = {\n            genres: artist.genres,\n            id: artist.id,\n            image: artistImage,\n            isFollowed: isFollowed,\n            likedSongs: [],\n            name: artist.name,\n            relatedArtistsIds: relatedArtistsFinal[i],\n            score: popularity * spotifyPopularityConst + followedScore\n        }\n    }\n\n    // add liked songs information to the artists\n    for (let i = 0; i < likedSongs.length; i++) {\n        const song = likedSongs[i];\n        for (let j = 0; j < song.artists.length; j++) {\n            const songArtist = song.artists[j]\n            if (songArtist.id in dictToReturn) {\n                dictToReturn[songArtist.id].likedSongs.push({\n                    artistsIds: song.artists.map(simplArtist => simplArtist.id),\n                    externalUrl: song.external_urls.spotify,\n                    name: song.name,\n                    id: song.id,\n                    previewLink: song.preview_url\n                })\n            }\n        }\n    }\n\n    // recomputed artists' score\n    for (let key in dictToReturn) {\n        const art = dictToReturn[key]\n        dictToReturn[key].score += art.likedSongs.length * likedSongConst\n    }\n\n    return dictToReturn\n}\n\nconst dictArtistFullToReduced =\n    (artistsDictFull: StringDict<ArtistFull>): StringDict<ArtistReduced> => {\n        const artistsDictReduced: StringDict<ArtistReduced> = {}\n        for (let key in artistsDictFull) {\n            const artFull = artistsDictFull[key]\n            artistsDictReduced[key] = {\n                id: artFull.id,\n                relatedArtistsIds: artFull.relatedArtistsIds,\n                genres: artFull.genres\n            }\n        }\n        return artistsDictReduced\n    }\n\nconst emptyGraph = (): Graph => {\n    return { clusters: [], clusterEdges: [], artistEdges: [], clusterSquares: [], artistDict: {} }\n}\n\n/**\n * Fetches all the necessary graph data.\n * @param accessToken Spotify access token\n * @param sp SpotifyWebApiJs object\n * @param setGraphLoadingMessageFunction callback informing about the loading\n * @param setGraphLoadingProgress callback informing about the progress\n * @param setGraphLoadingError callback informing about errors\n */\nexport const fetchAllDataFromSpotify = async (\n    accessToken: string,\n    sp: SpotifyWebApi.SpotifyWebApiJs,\n    setGraphLoadingMessageFunction: Function,\n    setGraphLoadingProgress: Function,\n    setGraphLoadingError: Function\n): Promise<Graph> => {\n    /*\n    1) REQ - liked songs\n    2) artists from liked songs\n    3) REQ - followed artists\n    4) concat from_liked and followed_artists\n    5) REQ - get all artists full objects\n    6) REQ - get related artists of concatenated\n    7) make a dict, {artistsId: artist} - where artist is full artist object (or our Artist type)\n    8) add additional info to the artists:\n        a)OK for every liked song - add to dict the songs\n        b)OK is artist followed?\n        c) calculate artist score\n        d)OK related artists ids (for future work)\n    */\n\n    if (!!!accessToken) return emptyGraph()\n\n    sp.setAccessToken(accessToken)\n\n    // 1) get liked songs\n    const likedSongs = await getLikedSongs(sp)\n\n    setGraphLoadingMessageFunction(\"Getting your liked songs from Spotify...\")\n    console.debug('liked songs: ', likedSongs)\n\n    // 2) artists from liked songs\n    const likedSongsArtistsIds = getArtistsIdsFromLikedSongs(likedSongs)\n    console.debug('liked songs artists ids: ', likedSongsArtistsIds)\n\n    // 3) followed artists\n    setGraphLoadingMessageFunction(\"Getting the artists you follow from Spotify...\")\n    const followedArtistsIds = await getFollowedArtistsIds(sp)\n    console.debug('followed artists ids: ', followedArtistsIds)\n\n    // 4) concat from_liked and followed_artists\n    const allArtistsIds = [...new Set(likedSongsArtistsIds.concat(followedArtistsIds))]\n    // const allArtistsIds = [...new Set(followedArtistsIds)] // debug option for less ids...\n    console.debug('all artists ids: ', allArtistsIds)\n\n    // TODO: else: inform user that he doesn't have anything we want\n    if (allArtistsIds.length < 1) {\n        setGraphLoadingError(\"Your graph is empty, we have nothing to show to you\")\n        return emptyGraph()\n    }\n\n    // 5) get all artists full objects\n    setGraphLoadingMessageFunction(\"Getting information about all the artists you are interested it...\")\n    const artistsFull = await Promise.resolve(getAllArtistsFull(sp, allArtistsIds))\n    console.debug('artists full: ', artistsFull);\n\n    // 6) get related artists of concatenated\n    const relatedArtistsStorageName = \"relatedArtists\"\n    // localStorage.setItem(relatedArtistsStorageName, JSON.stringify({})) // ONLY FOR DEBUGGING\n    const storageRelatedArtistsValue = localStorage.getItem(relatedArtistsStorageName)\n\n    let alreadyLoadedRelatedArtists = {}\n    if (storageRelatedArtistsValue === null) {\n\n    }\n    else {\n        try {\n            alreadyLoadedRelatedArtists = JSON.parse(storageRelatedArtistsValue)\n        } catch {\n            alreadyLoadedRelatedArtists = {}\n        }\n\n        if (alreadyLoadedRelatedArtists === null) {\n            alreadyLoadedRelatedArtists = {}\n        }\n    }\n\n\n    setGraphLoadingMessageFunction(\"Getting information about the related artists of all of your favourite artists... \\n This might take a while :(\")\n    // const relatedArtistsFinal = await Promise.resolve(getRelatedArtists(sp, allArtistsIds, 0, alreadyLoadedRelatedArtists, setGraphLoadingProgress))\n    const relatedArtistsFinal = await getAllRelatedArtists(sp, allArtistsIds, alreadyLoadedRelatedArtists, setGraphLoadingProgress)\n    localStorage.setItem(relatedArtistsStorageName, JSON.stringify(alreadyLoadedRelatedArtists))\n    console.debug('related artists final', relatedArtistsFinal)\n\n    // 7,8) make a dict, add aditional info\n    const artistDict = createArtistDictWithFullInformation(\n        artistsFull,\n        relatedArtistsFinal,\n        new Set(followedArtistsIds),\n        likedSongs\n    )\n    console.debug('artist dict', artistDict)\n\n    const csfrtoken = getCookie('csrftoken')\n\n    setGraphLoadingMessageFunction(\"We have all the data we need, now computing the graph!\")\n\n    let calculateGraphLink = process.env.NODE_ENV === \"production\" ? process.env.REACT_APP_PROD_BACKEND_URL_CALCULATE_GRAPH : process.env.REACT_APP_DEV_BACKEND_URL_CALCULATE_GRAPH\n    if (isUndefined(calculateGraphLink)) return emptyGraph()\n\n    let jsonReponse: any = {}\n    try {\n        const fetchReponse = await fetch(calculateGraphLink, {\n            method: 'POST',\n            body: JSON.stringify(dictArtistFullToReduced(artistDict)),\n            headers: {\n                'Content-Type': 'application/json',\n                'X-CSRFToken': csfrtoken,\n                // 'X-Api-Key': accessToken\n            }\n        })\n        if (fetchReponse.ok) {\n            jsonReponse = await fetchReponse.json()\n        } else {\n            throw new Error(fetchReponse.status + '.  ' + fetchReponse.statusText + '.  ' + await fetchReponse.text())\n        }\n    } catch (requestError) {\n        setGraphLoadingError(requestError)\n        throw requestError\n    }\n    \n    console.debug(jsonReponse)\n\n    const artistEdges = parseArtistEdges(jsonReponse.artistEdges)\n\n    const clusters = parseClusters(artistDict, jsonReponse.clusters)\n\n    const clusterEdges = parseClusterEdges(jsonReponse.clusterEdges)\n\n    const clusterSquares = processClusterPositions(jsonReponse.clusterSquares)\n\n    const g = new Promise<Graph>(resolve => resolve({\n        artistEdges: artistEdges,\n        clusters: clusters,\n        clusterEdges: clusterEdges,\n        clusterSquares: clusterSquares,\n        artistDict: artistDict,\n    }\n    ))\n\n    console.debug('graph from spotify fetch:', await g)\n    return g\n}\n","import { ThunkAction } from 'redux-thunk'\nimport SpotifyWebApi from 'spotify-web-api-js'\nimport * as t from 'io-ts'\n\nfunction optional<RT extends t.Any>(\n    type: RT,\n    name: string = `${type.name} | undefined`\n): t.UnionType<\n    [RT, t.UndefinedType],\n    t.TypeOf<RT> | undefined,\n    t.OutputOf<RT> | undefined,\n    t.InputOf<RT> | undefined\n> {\n    return t.union<[RT, t.UndefinedType]>([type, t.undefined], name);\n}\n\nexport type StringDict<T> = {\n    [id: string]: T\n}\n\nexport type NumberDict<T> = {\n    [id: number]: T\n}\n\n\nexport const PositionType = t.type({\n    x: t.number,\n    y: t.number\n})\nexport type Position = t.TypeOf<typeof PositionType>\n\nexport const SongFullType = t.type({\n    artistsIds: t.array(t.string),\n    externalUrl: t.string,\n    id: t.string,\n    name: t.string,\n    previewLink: t.union([t.string, t.null])\n})\nexport type SongFull = t.TypeOf<typeof SongFullType>\n\nexport const SongReducedType = t.type({\n    id: t.string,\n    name: t.string\n})\nexport type SongReduced = t.TypeOf<typeof SongReducedType>\n\nexport const ArtistFullType = t.type({\n    genres: t.array(t.string),\n    id: t.string,\n    image: t.string,\n    isFollowed: t.boolean,\n    likedSongs: t.array(SongFullType),\n    name: t.string,\n    relatedArtistsIds: t.array(t.string),\n    score: t.number,\n})\nexport type ArtistFull = t.TypeOf<typeof ArtistFullType>\n\nexport const ArtistReducedType = t.type({\n    genres: t.array(t.string),\n    id: t.string,\n    relatedArtistsIds: t.array(t.string)\n})\nexport type ArtistReduced = t.TypeOf<typeof ArtistReducedType>\n\nexport const ArtistSimplifiedType = t.type({\n    id: t.string,\n    name: t.string\n})\nexport type ArtistSimplified = t.TypeOf<typeof ArtistSimplifiedType>\n\nexport const ArtistEdgeType = t.type({\n    id1: t.string,\n    id2: t.string,\n    weight: t.number\n})\nexport type ArtistEdge = t.TypeOf<typeof ArtistEdgeType>\n\nexport const ClusterType = t.type({\n    id: t.string,\n    genres: t.array(t.string),\n    artistsIds: t.array(t.string),\n    artistsPositions: t.dictionary(t.string, PositionType),\n    country: optional(t.string)\n})\nexport type Cluster = t.TypeOf<typeof ClusterType>\n\nexport const ClusterEdgeType = t.type({\n    id1: t.string,\n    id2: t.string,\n    weight: t.number,\n})\nexport type ClusterEdge = t.TypeOf<typeof ClusterEdgeType>\n\nexport type ClusterSquare = {\n    [clusterId: string]: Position\n}\n\nexport const GraphType = t.type({\n    clusters: t.array(ClusterType),\n    clusterEdges: t.array(ClusterEdgeType),\n    artistDict: t.dictionary(t.string, ArtistFullType),\n    artistEdges: t.array(ArtistEdgeType),\n    clusterSquares: t.array(t.dictionary(t.string, PositionType))\n})\nexport type Graph = t.TypeOf<typeof GraphType>\n\nexport interface ChosenArtistData {\n    notLikedSongs: SongFull[]\n    likedSongs: SongFull[]\n}\n\nexport interface State {\n    chosenCluster?: Cluster\n\n    chosenArtist?: ArtistFull\n    chosenArtistData?: ChosenArtistData\n    chosenArtistError?: string\n    chosenArtistLoading: boolean\n\n    graph: Graph\n\n    // access variables\n    userLoggedIn: boolean\n    accessToken?: string\n\n    // the song being played\n    songToPlay?: SongFull\n    nonFavouriteArtistDict: StringDict<ArtistSimplified>\n\n    // the state indicating the graph loading process\n    graphLoaded: boolean\n    graphLoading: boolean\n    \n    isGraphLoadingError: boolean\n    graphLoadingErrorMessage?: string\n\n    graphLoadingMessage: string\n    graphLoadingRelatedArtistsProgress: number\n\n    isGraphFromFileLoaded: boolean\n\n    // prepared spotify web api for requests:\n    spotifyWebApiObject: SpotifyWebApi.SpotifyWebApiJs\n\n    // player state\n    paused: boolean\n}\n\nexport interface ActionWrapper<Payload = undefined> {\n    type: string\n    payload?: Payload\n    reducer: (state: State) => State\n}\n\nexport type ThunkActionWrapper<T> = ThunkAction<Promise<T>, State, {}, ActionWrapper<any>>\n","import { produce } from 'immer'\nimport { ActionWrapper, ThunkActionWrapper, State, ArtistFull, Cluster, Graph, SongFull, ChosenArtistData, ArtistSimplified } from './types'\nimport SpotifyWebApi from 'spotify-web-api-js'\nimport { isUndefined } from 'util'\nimport { fetchAllDataFromSpotify, songFromJSONData } from '../methods/spotify-methods'\nimport { isRight } from 'fp-ts/lib/Either'\nimport { GraphType } from '../store/types'\n// import { PathReporter } from 'io-ts/lib/PathReporter'\n\nexport const setAccessToken = (accessToken: string): ActionWrapper<string> => ({\n    type: 'SET_ACCESS_TOKEN',\n    payload: accessToken,\n    reducer: produce((state: State) => {\n        state.accessToken = accessToken\n        state.userLoggedIn = true\n    })\n})\n\nexport const setUserLoggedIn = (): ActionWrapper<void> => ({\n    type: 'LOG_IN',\n    reducer: produce((state: State) => {\n        state.userLoggedIn = true\n    })\n})\n\nexport const logOut = (): ActionWrapper<void> => ({\n    type: 'LOG_OUT',\n    reducer: produce((state: State) => {\n        state.accessToken = undefined\n        state.userLoggedIn = false\n    })\n})\n\nexport const setChosenArtist = (artist: ArtistFull): ActionWrapper<ArtistFull> => ({\n    type: 'SET_CHOSEN_ARTIST',\n    payload: artist,\n    reducer: produce((state: State) => {\n        state.chosenArtist = artist\n    })\n})\n\nexport const setChosenCluster = (cluster: Cluster): ActionWrapper<Cluster> => ({\n    type: 'SET_CHOSEN_CLUSTER',\n    payload: cluster,\n    reducer: produce((state: State) => {\n        state.chosenCluster = cluster\n    })\n})\n\nexport const clearChosenClusterAndArtist = (): ActionWrapper<void> => ({\n    type: 'CLEAR_CHOSEN_CLUSTER_ARTIST',\n    reducer: produce((state: State) => {\n        state.chosenCluster = undefined\n        state.chosenArtist = undefined\n    })\n})\n\nexport const closeChosenClusterGraph = (): ActionWrapper<void> => ({\n    type: 'CLOSE_CHOSEN_CLUSTER_GRAPH',\n    reducer: produce((state: State) => {\n        state.chosenCluster = undefined\n    })\n})\n\nexport const closeChosenArtist = (): ActionWrapper<void> => ({\n    type: 'CLOSE_CHOSEN_ARTIST',\n    reducer: produce((state: State) => {\n        state.chosenArtist = undefined\n    })\n})\n\nexport const setGraph = (graph: Graph): ActionWrapper<Graph> => ({\n    type: 'SET_GRAPH',\n    payload: graph,\n    reducer: produce((state: State) => {\n        state.graph = graph\n    })\n})\n\nexport const setGraphArtists = (artists: ArtistFull[]): ActionWrapper<ArtistFull[]> => ({\n    type: 'SET_GRAPH_ARTISTS',\n    payload: artists,\n    reducer: produce((state: State) => {\n        state.graphLoading = false\n        state.graphLoaded = true\n    })\n})\n\nexport const graphLoading = (): ActionWrapper<void> => ({\n    type: 'GRAPH_LOADING',\n    reducer: produce((state: State) => {\n        state.graphLoading = true\n    })\n})\n\nexport const setGraphLoadingMessage = (message: string): ActionWrapper<string> => ({\n    type: 'SET_GRAPH_LOADING_MESSAGE',\n    reducer: produce((state: State) => {\n        state.graphLoadingMessage = message\n    })\n})\n\nexport const setGraphLoadingErrorMessage = (errorMessage: string): ActionWrapper<string> => ({\n    type: 'SET_GRAPH_LOADING_ERROR_MESSAGE',\n    reducer: produce((state: State) => {\n        state.graphLoadingErrorMessage = errorMessage\n    })\n})\n\nexport const setGraphLoadingProgress = (progress: number): ActionWrapper<number> => ({\n    type: 'SET_GRAPH_LOADING_MESSAGE',\n    reducer: produce((state: State) => {\n        state.graphLoadingRelatedArtistsProgress = progress\n    })\n})\n\nexport const graphLoadingError = (): ActionWrapper<void> => ({\n    type: 'GRAPH_LOADING_ERROR',\n    reducer: produce((state: State) => {\n        state.graphLoading = false\n        state.isGraphLoadingError = true\n    })\n})\n\nexport const graphLoadingSuccess = (): ActionWrapper<void> => ({\n    type: 'GRAPH_LOADING_SUCCESS',\n    reducer: produce((state: State) => {\n        state.graphLoading = false\n        state.graphLoaded = true\n        state.isGraphLoadingError = false\n    })\n})\n\nexport const setChosenArtistError = (error: string): ActionWrapper<string> => ({\n    type: 'SET_CHOSEN_ARTIST_ERROR',\n    payload: error,\n    reducer: produce((state: State) => {\n        state.chosenArtistError = error\n    })\n})\n\nexport const setChosenArtistLoading = (loading: boolean): ActionWrapper<boolean> => ({\n    type: 'SET_CHOSEN_ARTIST_LOADING',\n    payload: loading,\n    reducer: produce((state: State) => {\n        state.chosenArtistLoading = loading\n    })\n})\n\nexport const setChosenArtistData = (artistData: ChosenArtistData, chosenArtist: ArtistFull): ActionWrapper<ChosenArtistData> => ({\n    type: 'SET_CHOSEN_ARTIST_DATA',\n    payload: artistData,\n    reducer: produce((state: State) => {\n        state.chosenArtistData = artistData\n        state.chosenArtist = chosenArtist\n    })\n})\n\nexport const setSongToPlay = (song: SongFull): ActionWrapper<SongFull> => ({\n    type: 'SET_SONG_TO_PLAY',\n    payload: song,\n    reducer: produce((state: State) => {\n        if (!!!state.songToPlay || state.songToPlay.id !== song.id) {\n            state.songToPlay = song\n            state.paused = false\n        }\n    })\n})\n\nexport const setPaused = (paused: boolean): ActionWrapper<boolean> => ({\n    type: 'SET_PAUSED',\n    payload: paused,\n    reducer: produce((state: State) => {\n        state.paused = paused\n    })\n})\n\nexport const setSpotifyApi = (accessToken: string): ActionWrapper<string> => ({\n    type: 'SET_SPOTIFY_API',\n    payload: accessToken,\n    reducer: produce((state: State) => {\n        try {\n            const sApi = state.spotifyWebApiObject\n            sApi.setAccessToken(accessToken)\n            state.spotifyWebApiObject = sApi\n        } catch (error) {\n            console.debug(error)\n        }\n        console.debug('SET SPOTIFY API')\n    })\n})\n\n/**\n * Updates not favourite artists dictionary\n * @param artistsToUpdate list of artists to add \n */\nconst updateNotFavouriteArtists = (artistsToUpdate: ArtistSimplified[]): ActionWrapper<any> => ({\n    type: 'UPDATE_NOT_FAVOURITE_ARTISTS',\n    payload: artistsToUpdate,\n    reducer: produce((state: State) => {\n        const currentNotFavouriteDict = state.nonFavouriteArtistDict\n        const favouriteDict = state.graph.artistDict\n\n        for (let i = 0; i < artistsToUpdate.length; i++) {\n            const element = artistsToUpdate[i];\n            if (element.id in favouriteDict) {\n                // don't add\n            }\n            else {\n                currentNotFavouriteDict[element.id] = element\n            }\n        }\n        state.nonFavouriteArtistDict = currentNotFavouriteDict\n    })\n})\n\nconst artistsFromSongJSON = (element: SpotifyApi.TrackObjectFull, currentArtistId: string): ArtistSimplified[] => {\n    const toRet: ArtistSimplified[] = element.artists.reduce((result: ArtistSimplified[], a: SpotifyApi.ArtistObjectSimplified) => {\n        if (a.id !== currentArtistId) result.push({ id: a.id, name: a.name })\n        return result\n    }, [])\n    return toRet\n}\n\n/**\n * Sets a chosen artist and prepares his songs - liked by the user and not liked by the user.\n * @param chosenArtist `ArtistFull` object \n * @param accessToken Spotify API access token\n */\nexport const setChosenArtistDataAll = (\n    chosenArtist: ArtistFull,\n    accessToken: string\n): ThunkActionWrapper<void> => async (dispatch): Promise<void> => {\n    if (isUndefined(accessToken) || accessToken === null || accessToken === \"\") {\n        dispatch(setChosenArtistError('The token was not loaded, cannot obtain the artist data.'))\n        return\n    }\n\n    dispatch(setChosenArtist(chosenArtist))\n    dispatch(setChosenArtistLoading(true))\n    let s = new SpotifyWebApi();\n    s.setAccessToken(accessToken)\n\n    const likedSongs: SongFull[] = []\n    const notLikedSongs: SongFull[] = []\n    let artistToUpdate: ArtistSimplified[] = []\n\n    const areSongsEqual = (s1: SongFull, s2: SongFull) => {\n        return (s1.id === s2.id || s1.name === s2.name)\n    }\n\n    s.getArtistTopTracks(chosenArtist.id, 'CZ')\n        .then(topTracks => {\n            for (let i = 0; i < topTracks.tracks.length; i++) {\n                const currArtistToUpdate = artistsFromSongJSON(topTracks.tracks[i], chosenArtist.id)\n                artistToUpdate = artistToUpdate.concat(currArtistToUpdate)\n                const songToCheck = songFromJSONData(topTracks.tracks[i])\n                const indexOfLiked = chosenArtist.likedSongs.findIndex(likedSong => areSongsEqual(songToCheck, likedSong))\n\n                if (indexOfLiked === -1) {\n                    notLikedSongs.push(songToCheck)\n                }\n                else {\n                    if (songToCheck.previewLink === \"\") {\n                        songToCheck.previewLink = chosenArtist.likedSongs[indexOfLiked].previewLink\n                    }\n                    likedSongs.push(songToCheck)\n                }\n            }\n\n            for (let i = 0; i < chosenArtist.likedSongs.length; i++) {\n                const element = chosenArtist.likedSongs[i];\n                const indexOfLiked = likedSongs.findIndex(likedSong => areSongsEqual(element, likedSong))\n                if (indexOfLiked === -1) {\n                    likedSongs.push(element)\n                }\n\n            }\n\n            dispatch(updateNotFavouriteArtists(artistToUpdate))\n            dispatch(setChosenArtistData({ likedSongs: likedSongs, notLikedSongs: notLikedSongs }, chosenArtist))\n        })\n        .catch((error: string) => {\n            console.debug(error)\n            dispatch(setChosenArtistError('During the artist data fetching, the following error occured:' + error))\n        })\n        .finally(() => {\n            dispatch(setChosenArtistLoading(false))\n        })\n}\n\n/**\n * Load the data from backend\n * @param accessToken Spotify API access token\n * @param sp `SpotifyWebApiJs` object\n * @param callback callback to be called after the data is loaded (necessary to DraggableCanvas graph displaying)\n */\nexport const loadGraph = (accessToken: string, sp: SpotifyWebApi.SpotifyWebApiJs, callback: Function): ThunkActionWrapper<void> =>\n    async (dispatch): Promise<void> => {\n        dispatch(graphLoading())\n\n        fetchAllDataFromSpotify(\n            accessToken, sp,\n            (message: string) => { dispatch(setGraphLoadingMessage(message)) },\n            (progress: number) => { dispatch(setGraphLoadingProgress(progress)) },\n            (errorMessage: string) => { dispatch(setGraphLoadingErrorMessage(errorMessage)) }\n        )\n            .then(g => dispatch(setGraph(g)))\n            .then(() => callback())\n            .then(() => dispatch(graphLoadingSuccess()))\n            .catch((error) => {\n                console.debug(error)\n                dispatch(graphLoadingError())\n            })\n    }\n\nexport const graphFromFileIsLoaded = (isLoaded: boolean): ActionWrapper<boolean> => ({\n    type: 'GRAPH_FROM_FILE_IS_LOADED',\n    payload: isLoaded,\n    reducer: produce((state: State) => {\n        state.isGraphFromFileLoaded = isLoaded\n    })\n})\n\n/**\n * Action to load graph from file.\n * @param jsonToParse graph obtained from the file\n */\nexport const loadGraphFromFile = (jsonToParse: Graph): ThunkActionWrapper<void> =>\n    async (dispatch): Promise<void> => {\n        // type check\n        const result = GraphType.decode(jsonToParse)\n        if (!!!isRight(result)) {\n            // alert(\"SORRY, THE FILE IS CORRUPTED!\\n\\n\" + PathReporter.report(result))\n            alert(\"SORRY, THE FILE IS CORRUPTED!\")\n            return\n        }\n\n        for (let i = 0; i < jsonToParse.clusters.length; i++) {\n            const cluster = jsonToParse.clusters[i];\n            if (isUndefined(cluster.artistsIds) || cluster.artistsIds.length === 0) {\n                cluster.artistsIds = Object.keys(cluster.artistsPositions)\n            }\n        }\n\n        await Promise.resolve(\n            dispatch(clearChosenClusterAndArtist())\n        )\n            .then(() => dispatch(graphLoading()))\n            .then(() => dispatch(setGraph(jsonToParse)))\n            .then(() => dispatch(graphFromFileIsLoaded(true)))\n            .then(() => dispatch(graphLoadingSuccess()))\n    }\n","/* eslint-disable no-extra-label */\n\nimport { ClusterSquare, StringDict, Position } from '../store/types'\n\ninterface Rectangle {\n    left: number\n    top: number\n    width: number\n    height: number\n}\n\ninterface ScreenParams {\n    width: number\n    height: number\n    clusterWidth: number\n    clusterHeigth: number\n}\n\n/**\n * Calculates positions of the cluster from the given precomputed positions from backend.\n * \n * @param width Graph space width\n * @param height Graph space height\n * @param clusterWidth Width of a cluster\n * @param clusterHeigth Width of a cluster\n * @param clusterSquares Cluster squares as given from the backend\n * \n * @returns Dictionary of positions: [clusterId]:Position\n */\nexport const computeClusterPositions =\n    (width: number, height: number, clusterWidth: number, clusterHeigth: number, clusterSquares: ClusterSquare[]):\n        StringDict<Position> => {\n        const toRet: StringDict<Position> = {} // prepare dict for final positions\n        width -= 15 // some distance from the edge\n\n        const oneClusterComponents = []\n        const twoClusterComponents = []\n        const threeClusterComponents = []\n        const bigComponent = []\n\n        for (let i = 0; i < clusterSquares.length; i++) {\n            const square = clusterSquares[i];\n\n            const clustersInSquares = Object.keys(square).length\n            if (clustersInSquares === 1) {\n                oneClusterComponents.push(square)\n            }\n            else if (clustersInSquares === 2) {\n                twoClusterComponents.push(square)\n            }\n            else if (clustersInSquares === 3) {\n                threeClusterComponents.push(square)\n            }\n            else {\n                bigComponent.push(square)\n            }\n        }\n\n        const clusterPadding = 25\n        const screenParams: ScreenParams = { width: width, height: height, clusterWidth: clusterWidth + clusterPadding, clusterHeigth: clusterHeigth + 10 }\n        getBigComponentsPositions(bigComponent, toRet, screenParams)\n        const currentHeight = computeHeigthFromPositions(toRet, clusterHeigth)\n        getRestComponentsPositions(toRet, oneClusterComponents, twoClusterComponents, threeClusterComponents, screenParams, currentHeight)\n        return toRet\n    }\n\n/**\n * The big components (bigger than 3 clusters) are allowed to occupy the main space.\n * @param bigClusterSquares ClusterSquares as received from the backend with more than 3 clusters\n * @param finalPositions Dictionary with final positions to be changed! \n * @param screenParams Screen parameters\n */\nconst getBigComponentsPositions = (\n    bigClusterSquares: ClusterSquare[],\n    finalPositions: StringDict<Position>,\n    screenParams: ScreenParams\n) => {\n    for (let i = 0; i < bigClusterSquares.length; i++) {\n        const square = bigClusterSquares[i];\n        for (let clusterId in square) {\n            const clusterPosition = square[clusterId]\n\n            const newX = clusterPosition.x * (screenParams.width - screenParams.clusterWidth - 40)\n            const newY = clusterPosition.y * screenParams.height\n            finalPositions[clusterId] = { x: newX, y: newY }\n        }\n    }\n}\n\n/**\n * Fills free space that was not occupied by big components yet\n * \n * @param clusterInComponent Number of clusters in the components (1/2/3)\n * @param clusterComponents list of components with `clusterInComponent` clusters to be places\n * @param freeRectMatrix Binary matrix - 1 free space, 0 already filled space\n * @param possibleRectanglePositions Rectangles that are empty\n * @param notUsedClusterComponents Components that were not places yes -> will be changed\n * @param finalPositions Dictionary with final positions to be changed! \n */\nconst tryFillFreeSpace = (\n    clusterInComponent: number,\n    clusterComponents: ClusterSquare[],\n    freeRectMatrix: number[][],\n    possibleRectanglePositions: Rectangle[],\n    notUsedClusterComponents: ClusterSquare[],\n    finalPositions: StringDict<Position>,\n) => {\n    if (clusterInComponent !== 1 && clusterInComponent !== 2 && clusterInComponent !== 3 && freeRectMatrix.length <= 0) {\n    }\n\n    const freeRectMatrixRows = freeRectMatrix.length\n    const freeRectMatrixCols = freeRectMatrix[0].length\n\n    wholeLoop:\n    for (let i = 0; i < clusterComponents.length; i++) {\n        let foundSomeCoords = false\n        const clusterComponent = clusterComponents[i];\n\n        rowLoop:\n        for (let row = 0; row < freeRectMatrix.length; row++) {\n\n            // columnLoop:\n            for (let col = 0; col < freeRectMatrix[row].length; col++) {\n\n                let coordCombinations: number[][][] = []\n                if (clusterInComponent === 1) {\n                    coordCombinations = [\n                        [[row, col]]\n                    ]\n                }\n                else if (clusterInComponent === 2) {\n                    coordCombinations = [\n                        [[row, col], [row, col + 1]],\n                        [[row, col], [row + 1, col]],\n                    ]\n                }\n                else if (clusterInComponent === 3) {\n                    coordCombinations = [\n                        [[row, col], [row, col + 1], [row + 1, col + 1]],\n                        [[row, col], [row + 1, col], [row + 1, col + 1]],\n                        [[row, col], [row, col + 1], [row + 1, col]],\n                        [[row + 1, col + 1], [row, col + 1], [row + 1, col]],\n                    ]\n                }\n\n                for (let coordIndex = 0; coordIndex < coordCombinations.length; coordIndex++) {\n                    const coordArray = coordCombinations[coordIndex]\n                    const isLegit = coordArray.every(([rIndex, cIndex]) => {\n                        return rIndex < freeRectMatrixRows && cIndex < freeRectMatrixCols && freeRectMatrix[rIndex][cIndex] !== 0\n                    })\n                    const clusterIds = Object.keys(clusterComponent);\n                    if (isLegit) {\n\n                        for (let k = 0; k < clusterInComponent; k++) {\n                            const rect = possibleRectanglePositions[freeRectMatrix[coordArray[k][0]][coordArray[k][1]] - 1]\n                            finalPositions[clusterIds[k]] = { x: rect.left, y: rect.top }\n                            freeRectMatrix[coordArray[k][0]][coordArray[k][1]] = 0\n                        }\n\n                        foundSomeCoords = true\n                        break rowLoop\n                    }\n                    else { }\n                }\n            }\n        }\n\n        if (!foundSomeCoords) {\n            for (let notUsedIndex = i; notUsedIndex < clusterComponents.length; notUsedIndex++) {\n                notUsedClusterComponents.push(clusterComponents[notUsedIndex])\n            }\n            break wholeLoop\n        }\n    }\n}\n\n/**\n * Places all small components.\n * \n * @param finalPositions Dictionary with final positions to be changed! \n * @param oneClusterComponents Components with one cluster\n * @param twoClusterComponents Components with two clusters\n * @param threeClusterComponents Components with three clusters\n * @param screenParams Parameters of the screen\n * @param currentHeight Current height after big components were already places\n */\nconst getRestComponentsPositions = (\n    finalPositions: StringDict<Position>,\n    oneClusterComponents: ClusterSquare[],\n    twoClusterComponents: ClusterSquare[],\n    threeClusterComponents: ClusterSquare[],\n    screenParams: ScreenParams,\n    currentHeight: number\n) => {\n    // get the empty rectangle to fill with small pieces..\n\n    let rectangles: Rectangle[] = []\n    for (let key in finalPositions) {\n        let pos = finalPositions[key]\n        rectangles.push({ left: pos.x, top: pos.y, width: screenParams.clusterWidth, height: screenParams.clusterHeigth })\n    }\n    const { possibleRectanglePositions, freeRectMatrix } = getPossibleFreePositions(\n        screenParams.width, currentHeight, screenParams.clusterWidth + 30, screenParams.clusterHeigth + 30, rectangles);\n\n    const notUsedThreeClusterComponents: ClusterSquare[] = []\n    const notUsedTwoClusterComponents: ClusterSquare[] = []\n    const notUsedOneClusterComponents: ClusterSquare[] = []\n\n    tryFillFreeSpace(3, threeClusterComponents, freeRectMatrix, possibleRectanglePositions, notUsedThreeClusterComponents, finalPositions)\n    tryFillFreeSpace(2, twoClusterComponents, freeRectMatrix, possibleRectanglePositions, notUsedTwoClusterComponents, finalPositions)\n    tryFillFreeSpace(1, oneClusterComponents, freeRectMatrix, possibleRectanglePositions, notUsedOneClusterComponents, finalPositions)\n\n    const newRects: Rectangle[] = []\n\n    let currentY = currentHeight\n    let currentX = 0\n    \n    /* THREE CLUSTERS COMPONENTS */\n    const middleX = screenParams.clusterWidth * 0.7\n    const middleY = screenParams.clusterHeigth * 0.7\n    const circleRadius = screenParams.clusterWidth * 0.7\n    for (let i = 0; i < notUsedThreeClusterComponents.length; i++) {\n        const clusterComponent = notUsedThreeClusterComponents[i];\n        const clusterIds = Object.keys(clusterComponent);\n        const angle = Math.random()\n\n        const coords: number[][] = [\n            [\n                (circleRadius) * (Math.cos(angle * Math.PI)) + middleX + currentX,\n                (circleRadius) * (Math.sin(angle * Math.PI)) + middleY + currentY\n            ],\n            [\n                circleRadius * (Math.cos((angle + 2 / 3) * Math.PI)) + middleX + currentX,\n                circleRadius * (Math.sin((angle + 2 / 3) * Math.PI)) + middleY + currentY\n            ],\n            [\n                circleRadius * (Math.cos((angle + 4 / 3) * Math.PI)) + middleX + currentX,\n                circleRadius * (Math.sin((angle + 4 / 3) * Math.PI)) + middleY + currentY\n            ]\n        ]\n\n        for (let j = 0; j < 3; j++) {\n            finalPositions[clusterIds[j]] = { x: coords[j][0], y: coords[j][1] }\n            newRects.push({ left: coords[j][0], top: coords[j][1], width: screenParams.clusterWidth, height: screenParams.clusterHeigth })\n        }\n\n        const squareChange = circleRadius * 1.7 + screenParams.clusterWidth\n        currentX += squareChange\n        if (currentX + squareChange > screenParams.width) {\n            currentX = 0\n            currentY += squareChange\n        }\n    }\n\n    /* TWO CLUSTERS COMPONENTS */\n    for (let i = 0; i < notUsedTwoClusterComponents.length; i++) {\n        const clusterComponent = notUsedTwoClusterComponents[i];\n        const clusterIds = Object.keys(clusterComponent);\n        const coords: number[][] = [\n            [currentX, currentY],\n            [currentX + circleRadius * 2, currentY],\n        ]\n\n        for (let j = 0; j < 2; j++) {\n            finalPositions[clusterIds[j]] = { x: coords[j][0], y: coords[j][1] }\n            newRects.push({ left: coords[j][0], top: coords[j][1], width: screenParams.clusterWidth, height: screenParams.clusterHeigth })\n        }\n\n        const squareChange = circleRadius * 2 + screenParams.clusterWidth\n        currentX += squareChange\n        if (currentX > screenParams.width - screenParams.clusterWidth) {\n            currentX = 0\n            currentY += screenParams.clusterHeigth + 20\n        }\n    }\n\n    /* ONE CLUSTER COMPONENTS */\n    currentY = currentHeight\n    for (let i = 0; i < notUsedOneClusterComponents.length; i++) {\n        const clusterComponent = notUsedOneClusterComponents[i];\n        const clusterId = Object.keys(clusterComponent)[0];\n        const clusterRect: Rectangle = { top: currentY, left: currentX, width: screenParams.clusterWidth, height: screenParams.clusterHeigth }\n\n        while (hasCollisions(clusterRect, newRects)) {\n            clusterRect.left += screenParams.clusterWidth\n\n            if (clusterRect.left + screenParams.clusterWidth > screenParams.width) {\n                clusterRect.left = 0\n                clusterRect.top += screenParams.clusterHeigth + 20\n            }\n        }\n        finalPositions[clusterId] = { x: clusterRect.left, y: clusterRect.top }\n        currentX = clusterRect.left + screenParams.clusterWidth + 20\n        currentY = clusterRect.top\n        if (currentX + screenParams.clusterWidth > screenParams.width) {\n            currentX = 0\n            currentY += screenParams.clusterHeigth\n        }\n    }\n}\n\n/**\n * Calculates maximal height from the positions.\n * @param positions Positions to be taken into account\n * @param clusterHeigth height of the cluster in pixels\n */\nexport const computeHeigthFromPositions = (\n    positions: StringDict<Position>, clusterHeigth: number\n): number => {\n    let maxY = 0\n    for (let key in positions) {\n        let pos = positions[key]\n        maxY = pos.y > maxY ? pos.y : maxY\n    }\n    return maxY + clusterHeigth\n}\n\n\n/* \n------------------------------------\nThe following methods calculate free positions in the graph space \nafter the big clusters were placed \n------------------------------------\n*/\n\nconst _colliding = (start1: number, end1: number, start2: number, end2: number) => {\n    return start1 < end2 && start2 < end1;\n}\n\nconst areColliding = (rect1: Rectangle, rect2: Rectangle) => {\n    return _colliding(rect1.left, rect1.left + rect1.width, rect2.left, rect2.left + rect2.width)\n        && _colliding(rect1.top, rect1.top + rect1.height, rect2.top, rect2.top + rect2.height);\n}\n\nconst hasCollisions = (rect: Rectangle, rects: Rectangle[]) => {\n    return rects.reduce((res, r) => res || areColliding(r, rect), false);\n}\n\nconst getPossibleFreePositions = (\n    width: number, height: number, clusterWidth: number, clusterHeight: number, rects: Rectangle[]\n): { possibleRectanglePositions: Rectangle[], freeRectMatrix: number[][] } => {\n    const freeRectMatrix: number[][] = []\n    let numberToWidth = Math.floor(width / clusterWidth)\n    let numberToheight = Math.floor(height / clusterHeight)\n\n    numberToWidth = numberToWidth === 0 ? 1 : numberToWidth\n    numberToheight = numberToheight === 0 ? 1 : numberToheight\n\n    const possibleRectanglePositions = []\n    let noRectangles = 0\n    for (let i = 0; i < numberToheight; i++) {\n        freeRectMatrix[i] = []\n        for (let j = 0; j < numberToWidth; j++) {\n            const rect: Rectangle = { top: i * clusterHeight, left: j * clusterWidth, width: clusterWidth, height: clusterHeight }\n            if (hasCollisions(rect, rects)) {\n                freeRectMatrix[i][j] = 0\n            }\n            else {\n                noRectangles += 1\n                freeRectMatrix[i][j] = noRectangles\n                possibleRectanglePositions.push(rect)\n            }\n        }\n    }\n\n    return { possibleRectanglePositions: possibleRectanglePositions, freeRectMatrix: freeRectMatrix }\n}\n","\n/**\n * Receives positions of nodes. Recomputes the coordinates to be working well with \n * svg element in cluster and artist edges.\n * \n * @param x1 X coordinate of first node\n * @param y1 Y coordinate of first node\n * @param x2 X coordinate of second node\n * @param y2 Y coordinate of second node\n * @param thickness thickness of the edge\n */\nexport const computeEdgeCoordinates = (x1: number, y1: number, x2: number, y2: number, thickness: number): \n{ x1fin: number, y1fin: number, x2fin: number, y2fin: number, top: number, left: number, hei: number, wid: number } => {\n\n    let top: number, left: number, wid: number, hei: number\n\n    if (x1 > x2) {\n        left = x2\n        wid = x1 - x2\n    }\n    else {\n        left = x1\n        wid = x2 - x1\n    }\n\n    if (y1 > y2) {\n        top = y2\n        hei = y1 - y2\n    }\n    else {\n        top = y1\n        hei = y2 - y1\n    }\n\n    let x1fin = 0 + thickness\n    let y1fin = hei\n    let x2fin = wid\n    let y2fin = 0 + thickness\n    if ((y1 > y2 && x1 > x2) ||\n        (y1 < y2 && x1 < x2)) {\n        y1fin = 0 + thickness\n        y2fin = hei\n    }\n\n    return { x1fin, y1fin, x2fin, y2fin, top, left, hei, wid }\n}\n","import React from 'react'\nimport { computeEdgeCoordinates } from '../methods/edge-calculation'\n\ninterface ArtistEdgeProps {\n    /** X coordinate of the first artist */\n    x1: number\n    /** Y coordinate of the first artist */\n    y1: number\n    /** X coordinate of the second artist */\n    x2: number\n    /** Y coordinate of the second artist*/\n    y2: number\n    /** Weight of the edge */\n    weigth: number\n    /** Artist element width */\n    artistWidth: number\n    /** Weight of the strongest edge in the Inside cluster graph */\n    maximumEdgeWeigth: number\n}\n\n/** ArtistEdge - edge between artists in the Inside cluster graph */\nexport default class ArtistEdge extends React.Component<ArtistEdgeProps, {}> {\n    render() {\n        const thickness = this.props.weigth * 2\n        const { x1fin, y1fin, x2fin, y2fin, top, left, hei, wid } = computeEdgeCoordinates(\n            this.props.x1, this.props.y1, this.props.x2, this.props.y2, thickness)\n\n        const st: React.CSSProperties = {\n            top: top + 30,\n            left: left + this.props.artistWidth / 2\n        }\n\n        const curvature = 20\n        const edgeColor = `rgb(${2}, ${250}, ${240}, ${this.props.weigth / this.props.maximumEdgeWeigth})`\n\n        return (\n            <svg style={st} className=\"position-absolute\" width={wid + thickness + curvature} height={hei + thickness + curvature}>\n                <path\n                    d={`M ${x1fin},${y1fin} \n                        C ${x1fin + curvature},${y1fin + curvature} ${x2fin + curvature},${y2fin + curvature} ${x2fin},${y2fin}`}\n                    strokeWidth={thickness}\n                    fill=\"none\"\n                    stroke={edgeColor}\n                />\n            </svg>\n        )\n    }\n}\n","\n/** The most commonly used colors in SpotifyGraph */\nconst COLORS = {\n    lightAzureBlue: `rgb(132, 237, 243)`,\n    darkAzureBlue: `rgb(2, 109, 104)`,\n    pink: `rgb(255, 51, 153)`,\n    green: `rgb(0, 204, 0)`,\n    grey: `rgb(191, 191, 191)`\n}\n\nexport default COLORS;\n","import React from 'react'\nimport Draggable, { DraggableEvent } from 'react-draggable'\nimport CSS from 'csstype'\nimport { connect } from 'react-redux'\n\nimport { State } from '../store/types'\nimport { setChosenArtistDataAll } from '../store/actions'\nimport { ArtistFull } from '../store/types'\nimport COLORS from '../methods/colors'\n\nimport './cluster-node.css'\nimport './artist-node.css'\n\ninterface ArtistNodeProps {\n    /** Artist to be displayed in the node */\n    artist: ArtistFull\n    /** Initial X coordinate */\n    positionX: number\n    /** Initial Y coordinate */\n    positionY: number\n    /** Minimal score for the artist to be shown */\n    minimumScore: number\n    /** ArtistFull object of the chosen artist */\n    chosenArtist?: ArtistFull\n    /** Spotify API access token */\n    accessToken?: string\n    /** Callback for position change - needed to inform edges about node position change */\n    positionChangedCallback: Function\n    /** Function to set chosen artist in the State */\n    setChosenArtistDataAllFunc: typeof setChosenArtistDataAll\n}\n\ninterface ArtistNodeState {\n    currentPositionX: number\n    currentPositionY: number\n    dragging: boolean\n}\n\n/**\n * Artist node in the Inside cluster graph \n */\nclass ArtistNode extends React.Component<ArtistNodeProps, ArtistNodeState> {\n    constructor(props: ArtistNodeProps) {\n        super(props);\n        this.state = {\n            currentPositionX: props.positionX,\n            currentPositionY: props.positionY,\n            dragging: false,\n        }\n        this.onDrag = this.onDrag.bind(this)\n        this.onStop = this.onStop.bind(this)\n    }\n\n    onDrag(e: DraggableEvent, ui: any) {\n        e.stopPropagation(); e.preventDefault();\n        this.setState({ dragging: true })\n        const newCurrX = this.state.currentPositionX + ui.deltaX\n        const newCurrY = this.state.currentPositionY + ui.deltaY\n        this.setState({ currentPositionX: newCurrX, currentPositionY: newCurrY })\n        this.props.positionChangedCallback(newCurrX, newCurrY, this.props.artist.id)\n    }\n\n    onStop(e: DraggableEvent) {\n        e.stopPropagation(); e.preventDefault();\n        const dragging = this.state.dragging;\n        this.setState({ dragging: false })\n        if (!dragging) {\n            this.handleClick();\n        }\n    }\n\n    handleClick() {\n        if (this.props.accessToken) {\n            if (this.props.chosenArtist && this.props.chosenArtist.id === this.props.artist.id) {\n                return\n            }\n            else {\n                this.props.setChosenArtistDataAllFunc(this.props.artist, this.props.accessToken);\n            }\n        }\n    }\n\n    render() {\n        let color = COLORS.lightAzureBlue\n        if (this.props.chosenArtist && this.props.chosenArtist.id === this.props.artist.id) {\n            color = COLORS.pink\n        }\n        const nodeWidth = 60\n        const nodeHeight = 60\n\n        const artistImageDivStyle: CSS.Properties = {\n            backgroundImage: `url(${this.props.artist.image})`,\n            backgroundSize: `${nodeHeight}px ${nodeWidth}px`,\n            width: `${nodeWidth}px`,\n            height: `${nodeHeight}px`,\n            borderRadius: \"10px\",\n            alignSelf: \"center\"\n        }\n\n        if (this.props.artist.score < this.props.minimumScore) {\n            return <div></div>\n        }\n\n        return (\n            <Draggable\n                key={this.props.artist.id}\n                bounds=\"parent\"\n                defaultPosition={{ x: this.props.positionX, y: this.props.positionY }}\n                onDrag={this.onDrag}\n                onStop={this.onStop}\n            >\n                <div className=\"artist-node-outer-wrapper\">\n                    <div style={{ ...artistImageDivStyle, backgroundColor: COLORS.lightAzureBlue }}>\n                        <div style={artistImageDivStyle} />\n                    </div>\n                    <div className=\"artist-node-artist-name-div\" style={{ backgroundColor: color }}>\n                        {this.props.artist.name}\n                    </div>\n                </div>\n            </Draggable>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        accessToken: state.accessToken,\n        chosenArtist: state.chosenArtist\n    }),\n    (dispatch: any) => ({\n        setChosenArtistDataAllFunc: (chosenArtist: ArtistFull, accessToken: string) => dispatch(setChosenArtistDataAll(chosenArtist, accessToken))\n    })\n)(ArtistNode)\n","import React, { ChangeEvent } from 'react'\nimport { connect } from 'react-redux'\nimport Draggable from 'react-draggable'\nimport { TiArrowMove } from 'react-icons/ti'\nimport { BsQuestion } from 'react-icons/bs'\n\nimport { State, ArtistFull, StringDict } from '../store/types'\nimport { InsideClusterGraph } from './chosen-cluster'\nimport ArtistEdge from './artist-edge'\nimport ArtistNode from './artist-node'\n\nimport './chosen-cluster-graph.css'\n\ninterface ChosenClusterGraphProps {\n    /** Inside cluster graph object containing nodes and edges */\n    graphElements: InsideClusterGraph\n\n    /** Dictionary: [artistId]: artistFullObject */\n    idArtistDict: StringDict<ArtistFull>\n}\n\ninterface SliderLimits {\n    minimum: number\n    maximum: number\n}\n\ninterface ChosenClusterGraphState {\n    /** Width of the div with inside cluster graph */\n    width: number\n    /** Height of the div with inside cluster graph */\n    height: number\n    /** JSX node elements */\n    nodes: JSX.Element[]\n    /** Position of artists in the graph */\n    artistsPositions: { [id: string]: { x: number, y: number } }\n\n    /** current limits of the artist slider */\n    artistsSliderLimits: SliderLimits\n    /** current limits of the edges slider */\n    edgesSliderLimits: SliderLimits\n    /** current value of the artist slider */\n    artistSliderValue: number\n    /** current value of the edges slider */\n    edgesSliderValue: number\n\n    /** is the description shown right now? */\n    descriptionHover: boolean\n\n    /** minimal edge weight for the edge to be shown */\n    minimumEdgeWeight: number\n    /** maximal number of edges to be visualized by default */\n    maximumEdges: number\n}\n\nclass ChosenClusterGraph extends React.Component<ChosenClusterGraphProps, ChosenClusterGraphState> {\n    boxRef: any\n    wrapperRef: any\n\n    constructor(props: ChosenClusterGraphProps) {\n        super(props);\n        const maximumEdges = 400\n        const { artistsSliderLimits, edgesSliderLimits, currSliderValue } = this.getSliderLimits(maximumEdges)\n        this.state = {\n            width: 0, height: 0,\n            nodes: [], artistsPositions: {},\n            artistSliderValue: artistsSliderLimits.minimum,\n            edgesSliderValue: currSliderValue,\n            artistsSliderLimits: artistsSliderLimits,\n            edgesSliderLimits: edgesSliderLimits,\n            descriptionHover: false,\n            minimumEdgeWeight: 0.4,\n            maximumEdges: maximumEdges\n        }\n        this.wrapperRef = React.createRef();\n        this.boxRef = React.createRef();\n\n        this.positionChangedHandler = this.positionChangedHandler.bind(this)\n        this.changeArtistSliderValue = this.changeArtistSliderValue.bind(this)\n        this.changeEdgeSliderValue = this.changeEdgeSliderValue.bind(this)\n    }    \n\n    /**\n     * If a new Inside cluster graph must appear -> create a new graph\n     * \n     * If a slider value is changed -> nodes are created again with new threshold\n     */\n    componentDidUpdate(prevprops: ChosenClusterGraphProps, prevstate: ChosenClusterGraphState) {\n        if (prevprops.graphElements !== this.props.graphElements) {\n            this.prepareAfterGraphDataUpdate()\n        }\n        else if (prevstate.artistSliderValue !== this.state.artistSliderValue) {\n            this.prepareAfterSliderUpdate()\n        }\n    }\n\n    /**\n     * After a component did mount -> create a new graph\n     */\n    componentDidMount() {\n        this.prepareAfterGraphDataUpdate()\n    }\n\n    /**\n     * Create a new graph.\n     */\n    prepareAfterGraphDataUpdate() {\n        const { artistsSliderLimits, edgesSliderLimits, currSliderValue } = this.getSliderLimits(this.state.maximumEdges)\n        this.setState({\n            artistsSliderLimits: artistsSliderLimits,\n            edgesSliderLimits: edgesSliderLimits,\n            artistSliderValue: artistsSliderLimits.minimum,\n            edgesSliderValue: currSliderValue\n        })\n        let width = this.boxRef.current.clientWidth;\n        let height = this.boxRef.current.clientHeight;\n        this.setState({ width: width, height: height })\n        const createdNodes: { nodes: JSX.Element[], positions: {} } = this.createNodes(width, height);\n        this.setState({ nodes: createdNodes.nodes, artistsPositions: createdNodes.positions })\n    }\n\n    /**\n     * Prepare nodes with current positions and new slider value. Sets state - new nodes\n     */\n    prepareAfterSliderUpdate() {\n        const nodes = []\n        for (let i = 0; i < this.props.graphElements.nodes.length; i++) {\n            const elem = this.props.graphElements.nodes[i]\n            nodes.push(\n                <ArtistNode\n                    key={elem.artist.id}\n                    positionChangedCallback={this.positionChangedHandler}\n                    positionX={this.state.artistsPositions[elem.artist.id].x}\n                    positionY={this.state.artistsPositions[elem.artist.id].y}\n                    artist={elem.artist}\n                    minimumScore={this.state.artistSliderValue}\n                />\n            )\n        }\n        this.setState({ nodes: nodes })\n    }\n\n    /**\n     * Newly created Inside cluster graph -> new nodes.\n     * \n     * Creates nodes from the initial positions in props.graphElements\n     * \n     * @param wid Inside cluster graph width\n     * @param hei Inside cluster graph height\n     */\n    createNodes(wid: number, hei: number): { nodes: JSX.Element[], positions: {} } {\n        const nodeWidth = 100\n        const nodeHeight = 100\n        const canvasPadding = 15\n\n        const nodes: JSX.Element[] = []\n        let newArtistsPositions: { [id: string]: { x: number, y: number } } = {}\n        for (let i = 0; i < this.props.graphElements.nodes.length; i++) {\n            const elem = this.props.graphElements.nodes[i]\n            const compX = elem.position.x * (wid - nodeWidth - 2 * canvasPadding) + canvasPadding\n            const compY = elem.position.y * (hei - nodeHeight - 2 * canvasPadding) + canvasPadding\n            newArtistsPositions[elem.artist.id] = { x: compX, y: compY }\n\n            nodes.push(\n                <ArtistNode\n                    key={elem.artist.id}\n                    positionChangedCallback={this.positionChangedHandler}\n                    positionX={compX}\n                    positionY={compY}\n                    artist={elem.artist}\n                    minimumScore={this.state.artistSliderValue}\n                />\n            )\n        }\n        return { nodes, positions: newArtistsPositions }\n    }\n\n    /**\n     * Calculates artist and edge slider extrema\n     * \n     * @param maximumEdges maximal number of defaultly visible edges\n     */\n    getSliderLimits(maximumEdges: number): {\n        artistsSliderLimits: SliderLimits,\n        edgesSliderLimits: SliderLimits,\n        currSliderValue: number\n    } {\n        let artistsSliderLimits: SliderLimits = { minimum: 1000, maximum: -1000 }\n        let edgesSliderLimits: SliderLimits = { minimum: 1000, maximum: -1000 }\n\n        // get slider values\n        for (let i = 0; i < this.props.graphElements.nodes.length; i++) {\n            const node = this.props.graphElements.nodes[i]\n            const artistScore = node.artist.score\n            artistsSliderLimits.maximum = artistScore > artistsSliderLimits.maximum ? artistScore : artistsSliderLimits.maximum\n            artistsSliderLimits.minimum = artistScore < artistsSliderLimits.minimum ? artistScore : artistsSliderLimits.minimum\n        }\n\n        const edgesValues: number[] = this.props.graphElements.edges.map(el => el.weigth).sort((a, b) => a - b)\n        edgesSliderLimits.minimum = edgesValues[0]\n        edgesSliderLimits.maximum = edgesValues[edgesValues.length - 1]\n\n        artistsSliderLimits.maximum = Math.ceil(artistsSliderLimits.maximum)\n        artistsSliderLimits.minimum = Math.ceil(artistsSliderLimits.minimum) - 1\n        edgesSliderLimits.maximum = Math.ceil(edgesSliderLimits.maximum)\n        edgesSliderLimits.minimum = Math.ceil(edgesSliderLimits.minimum) - 1\n\n        const l = edgesValues.length\n        const currSliderValue = l > maximumEdges ? edgesValues[l - maximumEdges] + 0.1 : edgesSliderLimits.minimum\n\n        return {\n            artistsSliderLimits: artistsSliderLimits,\n            edgesSliderLimits: edgesSliderLimits,\n            currSliderValue: currSliderValue\n        }\n    }\n\n    /**\n     * Changes state with the new position value of node.\n     * @param x new X coordinate\n     * @param y new Y coordinate\n     * @param artist_id ID of the node that will be changed\n     */\n    positionChangedHandler(x: number, y: number, artist_id: string) {\n        if (this.state.artistsPositions == null) {\n            return []\n        }\n        const pos = this.state.artistsPositions\n        pos[artist_id] = { x: x, y: y }\n        this.setState({ artistsPositions: pos });\n    }\n\n    /**\n     * Returns edges created from node positions.\n     */\n    createEdges(): JSX.Element[] {\n        const edges = []\n        if (this.state.artistsPositions == null) {\n            return []\n        }\n\n        try {\n            for (let i = 0; i < this.props.graphElements.edges.length; i++) {\n                const edge = this.props.graphElements.edges[i]\n                const node1id = edge.id1\n                const node2id = edge.id2\n                const edgeWeigth = edge.weigth\n                const clusterEdgeKey = node1id + node2id\n\n                const node1 = this.props.idArtistDict[node1id]\n                const node2 = this.props.idArtistDict[node2id]\n\n                if (node1 !== node2 && edgeWeigth > this.state.edgesSliderValue &&\n                    edgeWeigth > this.state.minimumEdgeWeight &&\n                    node1.score >= this.state.artistSliderValue &&\n                    node2.score >= this.state.artistSliderValue\n                ) {\n                    edges.push(\n                        <ArtistEdge\n                            key={clusterEdgeKey}\n                            x1={this.state.artistsPositions[node1id].x}\n                            y1={this.state.artistsPositions[node1id].y}\n                            x2={this.state.artistsPositions[node2id].x}\n                            y2={this.state.artistsPositions[node2id].y}\n                            weigth={edge.weigth}\n                            artistWidth={70}\n                            maximumEdgeWeigth={this.state.edgesSliderLimits.maximum}\n                        />\n                    )\n                }\n            }\n        }\n        catch (err) {\n            edges.push(<div></div>)\n        }\n\n        return edges\n    }\n\n    changeArtistSliderValue(e: ChangeEvent<HTMLInputElement>) {\n        this.setState({ artistSliderValue: e.currentTarget.valueAsNumber })\n    }\n\n    createArtistSlider(): JSX.Element {\n        const minimum = this.state.artistsSliderLimits.minimum\n        const maximum = this.state.artistsSliderLimits.maximum\n        return <div className=\"inner-slider-wrapper\">\n            <input\n                type=\"range\"\n                min={minimum}\n                max={maximum}\n                step={(maximum - minimum) / 10}\n                value={this.state.artistSliderValue}\n                onChange={this.changeArtistSliderValue}\n                className=\"slider-input\"\n            />\n        </div>\n    }\n\n    changeEdgeSliderValue(e: ChangeEvent<HTMLInputElement>) {\n        this.setState({ edgesSliderValue: e.currentTarget.valueAsNumber })\n    }\n\n    createEdgeSlider(): JSX.Element {\n        const minimum = Math.max(this.state.edgesSliderLimits.minimum, this.state.minimumEdgeWeight)\n        const maximum = this.state.edgesSliderLimits.maximum\n        return <div className=\"inner-slider-wrapper\">\n            <input\n                type=\"range\"\n                min={minimum}\n                max={maximum}\n                step={(maximum - minimum) / 10}\n                value={this.state.edgesSliderValue}\n                onChange={this.changeEdgeSliderValue}\n                className=\"slider-input\"\n            />\n        </div>\n    }\n\n    changeHover() {\n        this.setState({ descriptionHover: !this.state.descriptionHover })\n    }\n\n    getDraggableSlider() {\n        const showDescriptionStyle = this.state.descriptionHover ? {} : { display: 'none' }\n        return (\n            <Draggable handle=\"strong\" bounds=\"parent\">\n                <div className=\"draggable-slider-div\">\n                    <div>\n                        <div className=\"outer-slider-wrapper\">\n                            {this.createEdgeSlider()}\n                            edges\n                        </div>\n                        <div className=\"outer-slider-wrapper\">\n                            {this.createArtistSlider()}\n                            artists\n                        </div>\n                    </div>\n                    <BsQuestion onMouseEnter={() => this.changeHover()} onMouseLeave={() => this.changeHover()} size={30} />\n                    <strong><TiArrowMove size={30} /></strong>\n                    <div className=\"slider-description\" style={showDescriptionStyle}>\n                        <p>Drag the sliders to control how many edges and artists will be shown.</p>\n                        <p>The artists will be hidden in the order based on their importance to you - less important first, more important remainig.</p>\n                        <p>The importance takes into account these factors: how many their songs you like, if you follow them and popularity on Spotify.</p>\n                        <p>The score of an edge between two artists is calculated from the number of common genres and Spotify \"related artists\" information.</p>\n                    </div>\n                </div>\n            </Draggable>\n        )\n    }\n\n    render() {\n        return (\n            <div className=\"noselect chosen-cluster-wrapper\" ref={this.wrapperRef}>\n                <div className=\"insideClusterBox\" ref={this.boxRef} style={{ width: this.state.width }}>\n                    {this.getDraggableSlider()}\n                    {this.state.width !== 0 && this.state.nodes.length !== 0 && this.createEdges()}\n                    {this.state.width !== 0 && this.state.nodes}\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        idArtistDict: state.graph.artistDict\n    }),\n    {}\n)(ChosenClusterGraph)\n","\nimport React from 'react'\nimport { connect } from 'react-redux'\nimport { isUndefined } from 'util'\nimport { MdPlayCircleOutline, MdPauseCircleOutline } from 'react-icons/md'\nimport { IoMdMusicalNotes, IoMdHeart } from 'react-icons/io'\nimport { RiQuestionLine} from 'react-icons/ri'\nimport SpotifyWebApi from 'spotify-web-api-js'\n\nimport { ArtistFull, State, ChosenArtistData, SongFull } from '../store/types'\nimport { setSongToPlay, setPaused } from '../store/actions'\nimport COLORS from '../methods/colors'\n\nimport './chosen-artist-bar.css'\nimport './styles.css'\n\ninterface ChosenArtistBarProps {\n    /** Chosen artist - full object */\n    chosenArtist?: ArtistFull,\n    /** Chosen artist loading - true if loading */\n    chosenArtistLoading: boolean,\n    /** Chosen artist error - if some error occurs, contains error message */\n    chosenArtistError?: string,\n    /** Chosen artist data object */\n    chosenArtistData?: ChosenArtistData,\n    /** Function to play a song */\n    setSongToPlay: (song: SongFull) => void,    \n    /** Spotify Web API object */\n    spotifyApiObject: SpotifyWebApi.SpotifyWebApiJs,\n    /** Song that is currently in the player */\n    songToPlay: SongFull\n    /** Is song paused? */\n    paused: boolean\n    /** Change the state of player*/\n    setPause: (paused: boolean) => void\n}\n\ninterface ChosenArtistBarState {\n    chosenSongId: string\n    likedSongs:SongFull[]\n    notLikedSongs:SongFull[]\n}\n\n/**\n * Right bar with Chosen artist information (songs, image)\n */\nclass ChosenArtistBar extends React.Component<ChosenArtistBarProps, ChosenArtistBarState> {\n\n    constructor(props: any) {\n        super(props)\n        const {liked, notLiked} = this.prepareSongs()\n        this.state = {chosenSongId: '', likedSongs:liked, notLikedSongs: notLiked}\n    }\n\n    setChosenSong(songId: string) {\n        if (songId === this.state.chosenSongId) {\n            this.setState({chosenSongId: \"\"})\n        }\n        else {\n            this.setState({chosenSongId: songId})\n        }\n    }\n\n    componentDidUpdate(prevProps: ChosenArtistBarProps, prevState: ChosenArtistBarState) {\n        if(prevProps.chosenArtistData !== this.props.chosenArtistData && this.props.chosenArtistData) {\n            this.setState({\n                chosenSongId: '',\n                likedSongs:this.props.chosenArtistData.likedSongs,\n                notLikedSongs: this.props.chosenArtistData.notLikedSongs\n            })\n        }\n    }\n\n    prepareSongs(): {liked: SongFull[], notLiked: SongFull[]} {\n        if(!!!this.props.chosenArtistData || isUndefined(this.props.chosenArtist)) {\n            return {liked:[],notLiked:[]}\n        }\n\n        const likedSongs:SongFull[] = []\n        const notLikedSongs:SongFull[] = []\n\n        for (let i = 0; i < this.props.chosenArtistData.likedSongs.length; i++) {\n            const element = this.props.chosenArtistData.likedSongs[i];\n            if (this.props.chosenArtist.likedSongs && !!!likedSongs.includes(element)) {\n                likedSongs.push(element);\n            }\n            else if (!notLikedSongs.includes(element)){\n                notLikedSongs.push(element);\n            }\n        }\n        console.debug('liked:', likedSongs)\n        console.debug('liked by artist', this.props.chosenArtist.likedSongs)\n        console.debug('not liked:', notLikedSongs)\n        return {liked: likedSongs, notLiked: notLikedSongs}\n    }\n\n    getSongDiv(song: SongFull, liked: boolean): JSX.Element {\n        const style = this.state.chosenSongId === song.id ? {maxHeight: 80} : {maxHeight: 0}\n\n        let playerIcon = <MdPlayCircleOutline size={40} onClick={(e) => {\n            e.stopPropagation(); \n            this.props.setSongToPlay(song);\n        }} />\n\n        let chosenSongColorIndicator = COLORS.lightAzureBlue;\n        if (this.props.songToPlay && this.props.songToPlay.id === song.id) {\n            chosenSongColorIndicator = COLORS.pink;\n            if (this.props.paused) {\n                playerIcon = <MdPlayCircleOutline size={40} onClick={(e) => {e.stopPropagation(); this.props.setPause(false)}} />\n            }\n            else {\n                playerIcon = <MdPauseCircleOutline size={40} onClick={(e) => {e.stopPropagation(); this.props.setPause(true)}} />\n            }\n        }\n\n        let likedSongColorIndicator = COLORS.lightAzureBlue\n        if (liked) {\n            likedSongColorIndicator = COLORS.green\n        }\n\n        if (song.previewLink === '' || song.previewLink === null || isUndefined(song.previewLink)) {\n            playerIcon = <RiQuestionLine size={40} onClick={(e) => {e.stopPropagation(); alert('No preview found on Spotify')}} />\n            chosenSongColorIndicator = COLORS.grey\n        }\n\n        return (\n            <div key={song.id} className=\"flex-column song-div\" style={{backgroundColor: chosenSongColorIndicator}}>\n                <div className=\"song-preview\" style={{backgroundColor: likedSongColorIndicator}} onClick={() => this.setChosenSong(song.id)}>\n                    <div className=\"pointer\"\n                        style={{marginRight:\"5px\", display:\"inline-flex\", flexDirection:\"column\", justifyContent:\"center\", alignContent:\"center\"}}\n                    >\n                        {playerIcon}\n                    </div>\n                    <div className=\"song-wrapper\">\n                        {song.name}\n                    </div>\n                </div>\n                <div className=\"song-description\" style={style}>\n                    <div className=\"full-song-link-div\" onClick={() => {window.open(song.externalUrl)}}>\n                        <IoMdMusicalNotes/>\n                        Full song\n                    </div>\n                    { !!!liked && <div className=\"full-song-link-div\" onClick={() => {\n                        this.props.spotifyApiObject.addToMySavedTracks([song.id])\n                        .then(() => {\n                            console.debug('TRACK SAVED')\n                            let likedSongsOld = this.state.likedSongs\n                            likedSongsOld = likedSongsOld.concat(song)\n                            let notLikedSongsOld = this.state.notLikedSongs.filter(s => s.id !== song.id)\n\n                            this.setState({likedSongs: likedSongsOld, notLikedSongs: notLikedSongsOld})\n                        })\n                        .catch((error: any) => {\n                            console.debug('THIS ERROR DURING TRACK SAVING OCCURED:', error)\n                        })\n                    }}>\n                        <IoMdHeart/>\n                        Save to liked songs\n                    </div>\n                    }\n                </div>\n            </div>\n        )\n    }\n\n    getSongsDivs(songs: SongFull[], liked: boolean): JSX.Element[] {\n        if (!!!songs) return []\n\n        const toReturn: JSX.Element[] = []\n        for (let i = 0; i < songs.length; i++) {\n            toReturn.push(\n                this.getSongDiv(songs[i], liked)\n            )\n        }\n        return toReturn\n\n    }\n\n    render() {\n        if (this.props.chosenArtistError) {\n            return (\n                <div className=\"chosen-artist-bar\">\n                    <h2><i>{this.props.chosenArtistError}</i></h2>\n                </div>\n            )\n        }\n        else if (isUndefined(this.props.chosenArtist) || isUndefined(this.props.chosenArtistData)) {\n            return (\n                <div className=\"chosen-artist-bar\">\n                    <h2>CLICK SOME ARTIST</h2>\n                </div>\n            )\n        }\n        else if (this.props.chosenArtistLoading) {\n            return (\n                <div className=\"chosen-artist-bar\">\n                    <h2>LOADING...</h2>\n                </div>\n            )\n        }\n        else {\n            return (\n                <div className=\"chosen-artist-bar\">\n                    <div className=\"chosen-artist-bar-top\">\n                        <h1 style={{margin:0}}>\n                            {this.props.chosenArtist.name}\n                        </h1>\n                        <div style={{\n                            backgroundImage:`url(${this.props.chosenArtist.image})`,\n                            width: 70, height: 70, borderRadius: `${20}%`,\n                            backgroundSize: `70px 70px`,\n                            display: \"inline-grid\"\n                        }}></div>\n                        {\n                            this.props.chosenArtist.isFollowed &&\n                            <h2 style={{ margin:`5px 0px 0px 0px` }}>You are following this artist.</h2>\n                        }\n                    </div>\n                    <div className=\"chosen-artist-bar-scroll\">\n                        {this.getSongsDivs(this.state.likedSongs, true)}\n                        {this.getSongsDivs(this.state.notLikedSongs, false)}\n                    </div>\n                </div>\n            )\n        }\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        songToPlay: state.songToPlay,\n        chosenArtist: state.chosenArtist,\n        chosenArtistLoading: state.chosenArtistLoading,\n        chosenArtistError: state.chosenArtistError,\n        chosenArtistData: state.chosenArtistData,\n        spotifyApiObject: state.spotifyWebApiObject,\n        paused: state.paused\n    }),\n    (dispatch: Function) => ({\n        setPause: (paused:boolean) => dispatch(setPaused(paused)),\n        setSongToPlay: (song: SongFull) => dispatch(setSongToPlay(song))\n    })\n)(ChosenArtistBar)\n","import * as React from 'react'\nimport CSS from 'csstype'\nimport './styles.css'\nimport { connect } from 'react-redux'\nimport { State, Cluster, ClusterEdge, ArtistEdge,ArtistFull, StringDict } from '../store/types'\nimport { closeChosenClusterGraph, setChosenCluster, closeChosenArtist } from '../store/actions'\nimport ChosenClusterGraph from './chosen-cluster-graph'\nimport {TiArrowBack} from 'react-icons/ti'\nimport ChosenArtistBar from './chosen-artist-bar'\n\ninterface ChosenClusterProps {\n    closeChosenClusterGraph: Function,\n    closeChosenArtist: Function,\n    setChosenCluster: Function,\n    chosenCluster: Cluster,\n    clusters: Cluster[],\n    clusterEdges: ClusterEdge[],\n    artistEdges: ArtistEdge[],\n    artistDict: StringDict<ArtistFull>\n}\n\ninterface ChosenClusterState {\n    elements: InsideClusterGraph\n}\n\nexport interface InsideClusterArtistNode {\n    artist: ArtistFull\n    position: {x:number, y:number}\n}\n\nexport interface InsideClusterArtistEdge {\n    id: string\n    id1: string\n    id2: string\n    weigth: number\n}\n\nexport interface InsideClusterGraph {\n    nodes: InsideClusterArtistNode[]\n    edges: InsideClusterArtistEdge[]\n}\n\nclass ChosenCluster extends React.Component<ChosenClusterProps, ChosenClusterState> {\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            elements:this.getChosenClusterGraphElements(this.props.chosenCluster)\n        }\n    }\n\n    getChosenClusterGraphElements(chosenCluster: Cluster): InsideClusterGraph {\n        const nodes: InsideClusterArtistNode[] = [];\n        const edges: InsideClusterArtistEdge[] = [];\n\n        for (let i = 0; i < chosenCluster.artistsIds.length; i++) {\n            const currArtistId = chosenCluster.artistsIds[i];\n            const pos = chosenCluster.artistsPositions[currArtistId]\n            nodes.push({artist:this.props.artistDict[currArtistId], position: {x:pos.x, y:pos.y}})\n        }\n\n        for (let i = 0; i < this.props.artistEdges.length; i++) {\n            const id1 = this.props.artistEdges[i].id1;\n            const id2 = this.props.artistEdges[i].id2;\n            if (chosenCluster.artistsIds.includes(id1) && chosenCluster.artistsIds.includes(id2)) {\n                edges.push({id: id1+id2, id1: id1, id2: id2, weigth: this.props.artistEdges[i].weight})\n            }\n        }\n\n        return {nodes, edges}\n    }\n\n    getSimilarClusters(): JSX.Element[] {\n        const id = this.props.chosenCluster.id\n        const clusterEdgesWithChosenCluster: ClusterEdge[] = []\n\n        for (let i = 0; i < this.props.clusterEdges.length; i++) {\n            const clusterEdge = this.props.clusterEdges[i]\n            if (clusterEdge.id2 !== clusterEdge.id1 &&\n                (clusterEdge.id1 === id || clusterEdge.id2 === id)) {\n                clusterEdgesWithChosenCluster.push(clusterEdge)\n            }\n        }\n        clusterEdgesWithChosenCluster.sort((a, b) => a.weight > b.weight ? -1 : 1)\n\n        const similarClusters: JSX.Element[] = []\n        const minimalClusterSimilarity = 2\n\n        const imgWid = 60\n        const imgHei = 60\n        let artistDivStyle: CSS.Properties = {\n            width: `${imgWid}px`,\n            height: `${imgHei}px`,\n            backgroundSize: `${imgHei}px ${imgWid}px`,\n        }\n\n        for (let i = 0; i < clusterEdgesWithChosenCluster.length; i++) {\n            const edge = clusterEdgesWithChosenCluster[i];\n            if (edge.weight > minimalClusterSimilarity) {\n                const secondId = id === edge.id1 ? edge.id2 : edge.id1\n                const similarCluster = this.props.clusters[this.props.clusters.map(e => e.id).indexOf(secondId)]\n                const similarClusterArtistsElements: JSX.Element[] = []\n\n                for (let j = 0; j < Math.min(similarCluster.artistsIds.length, 3); j++) {\n                    const artistId = similarCluster.artistsIds[j];\n                    const currArtist = this.props.artistDict[artistId]\n                    const artistDivStyleNew = {\n                        ...artistDivStyle,\n                        backgroundImage:`url(${currArtist.image})`\n                    }\n                    similarClusterArtistsElements.push(\n                        <div className=\"artistWrapper\">\n                            <div title={currArtist.name} style={artistDivStyleNew} className=\"artistDiv\"></div>\n                        </div>\n                    )\n                }\n\n                similarClusters.push(\n                    <div className=\"similar-cluster-div padding-margin pointer\" onClick={\n                            () => {\n                                this.props.closeChosenArtist()\n                                this.props.setChosenCluster(similarCluster)\n                                this.setState({\n                                    elements:this.getChosenClusterGraphElements(similarCluster)\n                                })\n                            }\n                        }>\n                        <p>Similar to: {similarCluster.genres[0]}</p>\n                        <div className=\"artistsRow\">\n                            {similarClusterArtistsElements}\n                        </div>\n                    </div>\n                )\n            }\n        }\n        return similarClusters\n    }\n\n    onClick = () => {\n        this.props.closeChosenClusterGraph()\n        this.props.closeChosenArtist()\n    }\n\n    render() {\n        const similarClusters = this.getSimilarClusters()\n\n        return (\n            <div className=\"chosen-cluster-div\">\n                <div className=\"chosen-cluster-column\">\n                    <div className=\"similar-cluster-row\">\n                        <div className=\"go-back-div padding-margin pointer\" onClick={this.onClick}>\n                            <TiArrowBack size={50}/>\n                            <h3 className=\"h3-no-padding\">Go back to the graph</h3>\n                        </div>\n                        {similarClusters}\n                    </div>\n                    <div className=\"chosen-cluster-graph-div\">\n                        <ChosenClusterGraph graphElements={this.state.elements}/>\n                    </div>\n                </div>\n\n                <ChosenArtistBar/>\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = (state: State) => {\n    return {\n        artistEdges: state.graph.artistEdges,\n        clusters: state.graph.clusters,\n        clusterEdges: state.graph.clusterEdges,\n        artistDict: state.graph.artistDict\n    }\n}\n\nexport default connect(\n    mapStateToProps,\n    {\n        closeChosenClusterGraph,\n        closeChosenArtist,\n        setChosenCluster\n    }\n  )(ChosenCluster)\n","import React from 'react'\nimport { connect } from 'react-redux'\nimport Draggable, { DraggableEvent } from 'react-draggable'\nimport ReactCountryFlag from 'react-country-flag'\nimport CSS from 'csstype';\n\nimport { State } from '../store/types'\nimport { setChosenCluster, } from '../store/actions'\nimport { Cluster, StringDict, ArtistFull } from '../store/types'\nimport './cluster-node.css'\n\nvar countries = require(\"i18n-iso-countries\");\ncountries.registerLocale(require(\"i18n-iso-countries/langs/en.json\"));\n\ninterface ClusterNodeProps {\n    /** Cluster to be shown as node */\n    cluster: Cluster\n    /** Initial X coordinate */\n    positionX: number\n    /** Initial Y coordinate */\n    positionY: number\n    /** Callback - let Main graph know that position of the node with artist_id was changed */\n    positionChanged: (x: number, y: number, artist_id: string) => void\n    /** Set chosen cluster in the State */\n    setChosenCluster: typeof setChosenCluster\n    \n    /** Constant to adapt description font size on zoom */\n    fontSizeConst: number\n    /** Width of the cluster in the default zoom. */\n    clusterWidth: number\n    /** Artist dictionarty - [artistId]:artistFullObject */\n    artistDict: StringDict<ArtistFull>\n}\n\ninterface ClusterNodeState {\n    /** Current X coordinate */\n    positionX: number\n    /** Current Y coordinate */\n    positionY: number\n    /** Is the node being dragged */\n    dragging: boolean\n    /** The default font size of the description */\n    fontSizeDefault: number\n}\n\nclass ClusterNode extends React.Component<ClusterNodeProps, ClusterNodeState> {\n    constructor(props: ClusterNodeProps) {\n        super(props);\n        this.state = {\n            positionX: props.positionX,\n            positionY: props.positionY,\n            dragging: false,\n            fontSizeDefault: 12\n        }\n        this.onDrag = this.onDrag.bind(this)\n        this.onStop = this.onStop.bind(this)\n    }\n\n    componentDidUpdate(prevProps: ClusterNodeProps, prevState: ClusterNodeState) {\n        if (prevProps.positionX !== this.props.positionX) {\n            this.setState({ positionX: this.props.positionX })\n        }\n    }\n\n    /** On node drag -> change position and call callback to let Main graph edges know */\n    onDrag(e: DraggableEvent, ui: any) {\n        e.stopPropagation(); e.preventDefault();\n\n        const oldX = this.state.positionX\n        const oldY = this.state.positionY\n\n        const newX = oldX + ui.deltaX\n        const newY = oldY + ui.deltaY\n\n        this.setState({ dragging: true, positionX: newX, positionY: newY })\n        this.props.positionChanged(newX, newY, this.props.cluster.id)\n    }\n\n    onStop(e: DraggableEvent) {\n        e.stopPropagation(); e.preventDefault();\n        const dragging = this.state.dragging;\n        this.setState({ dragging: false })\n        if (!dragging) {\n            this.handleClick(e);\n        }\n    }\n\n    handleClick(e: any) {\n        this.props.setChosenCluster(this.props.cluster)\n    }\n\n    createArtistWrapper(title: string, style: {}, key: number): JSX.Element {\n        return (\n            <div key={key} className=\"artistWrapper\">\n                <div className=\"colourWrapper\">\n                    <div title={title} style={style} className=\"artistDiv\"></div>\n                </div>\n            </div>\n        )\n    }\n\n    createEmptyWrapper(key: number): JSX.Element {\n        return <div key={key} className=\"artistWrapper\"><div></div></div>\n    }\n    \n    /** Prepares the node div.\n     * Makes rows of artists\n     */\n    clusterDiv(): JSX.Element {\n        const imgSize = this.props.clusterWidth / 4.6\n        let artistDivStyle: CSS.Properties = {\n            width: `${imgSize}px`,\n            height: `${imgSize}px`,\n            backgroundSize: `${imgSize}px ${imgSize}px`,\n        }\n\n        const rows: JSX.Element[] = [];\n        const numberOfArtists = this.props.cluster.artistsIds.length\n\n        let currKey = 0\n        let l: JSX.Element[] = []\n        for (let i = 0; i < Math.min(numberOfArtists, 4); i++) {\n            const currArtist = this.props.artistDict[this.props.cluster.artistsIds[i]]\n            const artistDivStyleNew = {\n                ...artistDivStyle,\n                backgroundImage: `url(${currArtist.image})`\n            }\n            l.push(this.createArtistWrapper(currArtist.name, artistDivStyleNew, currKey++))\n        }\n        rows.push(<div key={1} className=\"artistsRow\">{l}</div>)\n\n        l = []\n        if (numberOfArtists > 4) {\n            l.push(this.createEmptyWrapper(currKey++))\n            l.push(this.createEmptyWrapper(currKey++))\n\n            for (let i = 4; i < Math.min(6, numberOfArtists); i++) {\n                const currArtist = this.props.artistDict[this.props.cluster.artistsIds[i]]\n                const artistDivStyleNew = {\n                    ...artistDivStyle,\n                    backgroundImage: `url(${currArtist.image})`\n                }\n                l.push(this.createArtistWrapper(currArtist.name, artistDivStyleNew, currKey++))\n            }\n\n            if (numberOfArtists > 6) {\n                const artistDivStyleNew = {\n                    ...artistDivStyle,\n                    backgroundImage: `url(${process.env.PUBLIC_URL + '/three-dots.png'})`\n                }\n                l.push(this.createArtistWrapper(\"AND OTHERS\", artistDivStyleNew, currKey++))\n            }\n            l.push(this.createEmptyWrapper(currKey++))\n            l.push(this.createEmptyWrapper(currKey++))\n            rows.push(<div key={2} className=\"artistsRow\">{l}</div>)\n        }\n\n        let headerString = \"\"\n        const numberOfGenres = this.props.cluster.genres.length\n        if (numberOfGenres === 0) {\n            headerString = \"...unknown genre...\"\n        }\n        else {\n            for (let i = 0; i < Math.min(numberOfGenres, this.props.fontSizeConst + 1); i++) {\n                if (i === 0) {\n                    headerString += this.props.cluster.genres[i]\n                }\n                else {\n                    headerString += ', ' + this.props.cluster.genres[i]\n                }\n            }\n        }\n\n        let wrapperStyle: CSS.Properties = {\n            width: `${this.props.clusterWidth}px`,\n        }\n        return (<div className=\"nodeWrapper\" style={wrapperStyle}>\n            {\n                this.props.cluster.country &&\n                <div style={{\n                    position: \"absolute\",\n                    margin: 0,\n                    left: 0,\n                    opacity: 0.4,\n                    zIndex: -1,\n                    alignItems: 'center',\n                }}>\n                    <ReactCountryFlag\n                        countryCode={countries.alpha3ToAlpha2(this.props.cluster.country)}\n                        svg\n                        style={{\n                            width: this.props.clusterWidth + 30,\n                            height: '260px'\n                        }}\n                    />\n                </div>\n            }\n\n            <div className=\"nodeHeader\">\n                <div className=\"header noselect\" style={{ fontSize: this.state.fontSizeDefault / this.props.fontSizeConst + this.props.fontSizeConst }}>\n                    {headerString}\n                </div>\n            </div>\n            {rows}\n\n        </div>)\n    }\n\n    render() {\n        const clusterDiv = this.clusterDiv()\n        return (\n            <Draggable\n                onDrag={this.onDrag}\n                onStop={this.onStop}\n                onStart={(e: DraggableEvent) => { e.stopPropagation(); e.preventDefault(); }}\n                bounds=\"parent\"\n                defaultPosition={{ x: this.props.positionX, y: this.props.positionY }}\n                position={{ x: this.state.positionX, y: this.state.positionY }}\n            >\n                {clusterDiv}\n            </Draggable>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        artistDict: state.graph.artistDict\n    }),\n    {\n        setChosenCluster,\n    }\n)(ClusterNode)\n","import React from 'react'\nimport {computeEdgeCoordinates} from '../methods/edge-calculation'\n\ninterface ClusterEdgeProps {\n    /** X coordinate of the first cluster */\n    x1: number\n    /** Y coordinate of the first cluster */\n    y1: number\n    /** X coordinate of the second cluster */\n    x2: number\n    /** Y coordinate of the second cluster */\n    y2: number\n    /** Weight of the edge */\n    weigth: number\n    /** Size of the cluster to calculate the starting coordinates of edge */\n    clusterWidth: number\n}\n\n/** ClusterEdge - edge between clusters in the Main graph */\nexport default class ClusterEdge extends React.Component<ClusterEdgeProps, {}> {\n\n    render() {\n        const thickness = this.props.weigth\n        const {x1fin, y1fin, x2fin, y2fin, top, left, hei, wid} = computeEdgeCoordinates(\n            this.props.x1, this.props.y1, this.props.x2, this.props.y2, thickness)\n\n        const st: React.CSSProperties ={\n            top: top + 30,\n            left: left + this.props.clusterWidth / 2\n        }\n\n        const curvature = 20\n\n        return(\n            <svg style={st} className=\"position-absolute\" width={wid+thickness+curvature} height={hei+thickness+curvature}>\n                <path\n                    d={`M ${x1fin},${y1fin}\n                        C ${x1fin+curvature},${y1fin+curvature} ${x2fin+curvature},${y2fin+curvature} ${x2fin},${y2fin}`}\n                    strokeWidth={thickness}\n                    fill=\"none\"\n                    stroke=\"black\"\n                />\n            </svg>\n        )\n    }\n}\n","/* eslint-disable @typescript-eslint/no-useless-constructor */\n\nimport React from 'react'\n\ninterface ProgressBarProps {\n    progress: number\n}\n\nexport default class ProgressBar extends React.Component<ProgressBarProps, {}> {\n    constructor(props: ProgressBarProps) {\n        super(props);\n    }\n\n    render() {\n        return (\n            <div className=\"progressbar\">\n                <div className=\"progress\" style={{ width: `${this.props.progress * 100}%` }} />\n            </div>\n        )\n    }\n}\n","/* eslint-disable @typescript-eslint/no-useless-constructor */\n\nimport React from 'react'\nimport SpotifyWebApi from 'spotify-web-api-js'\nimport { connect } from 'react-redux'\nimport { TransformWrapper, TransformComponent } from \"react-zoom-pan-pinch\";\nimport { isUndefined } from 'util';\n\nimport { Graph, Cluster, State, StringDict, Position } from '../store/types'\nimport { setGraph, loadGraph, graphFromFileIsLoaded } from '../store/actions'\nimport { computeHeigthFromPositions, computeClusterPositions } from '../methods/graph-layout'\nimport ChosenCluster from './chosen-cluster'\nimport ClusterNode from './cluster-node'\nimport ClusterEdge from './cluster-edge'\nimport ProgressBar from './progress-bar'\n\nimport './draggable-canvas.css'\n\ninterface DraggableCanvasProps {\n    /** Thunk action for loading graph from the backend */\n    loadGraph: typeof loadGraph\n    /** The graph object */\n    graph: Graph\n    /** Was the graph loaded */\n    graphLoaded: boolean\n    /** Is the graph loading */\n    graphLoading: boolean\n    /** Message during the loading */\n    graphLoadingMessage: string,\n    /** Progress of related artists */\n    graphLoadingRelatedArtistsProgress: number,\n    /** Did error occur */\n    isGraphLoadingError: boolean\n    /** Message if error occured */\n    graphLoadingErrorMessage: string,\n    /** The chosen cluster */\n    chosenCluster: Cluster\n    /** Spotify API access token */\n    accessToken: string\n    /** SpotifyWebApiJs object */\n    sp: SpotifyWebApi.SpotifyWebApiJs\n    /** Set if a graph from file is loaded */\n    graphFromFileIsLoaded: Function\n    /** Is graph loaded from file */\n    isGraphFromFileLoaded: boolean\n}\n\ninterface DraggableCanvasState {\n    /** Dimensions of draggable canvas */\n    dimensions?: { w: number, h: number }\n    /** Current positions of clusters */\n    clusterPositions?: StringDict<Position>\n    /** Width of one cluster */\n    clusterWidth: number\n    /** Approximate height of one cluster (it can differ if cluster contains less artists) */\n    clusterHeight: number\n    /** Current zoom scale */\n    currentScale: number\n\n    /** Draggable canvas width when did mount */\n    originalRefWidth: number\n    /** Draggable canvas height when did mount */\n    originalRefHeight: number\n}\n\n/**\n * Contains all the work with the Main graph.\n */\nclass DraggableCanvas extends React.Component<DraggableCanvasProps, DraggableCanvasState> {\n    boxRef: any\n    wrapperRef: any\n\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            clusterWidth: 150,\n            clusterHeight: 150,\n            currentScale: 1,\n            originalRefHeight: 0,\n            originalRefWidth: 0\n        }\n\n        this.wrapperRef = React.createRef();\n        this.boxRef = React.createRef();\n\n        this.positionChangedHandler = this.positionChangedHandler.bind(this)\n    }\n\n    positionChangedHandler(x: number, y: number, artist_id: string) {\n        if (this.state.clusterPositions == null) {\n            return []\n        }\n        const pos = this.state.clusterPositions\n        pos[artist_id] = { x: x, y: y }\n        this.setState({ clusterPositions: pos });\n    }\n\n    graphLoadedCallback(width: number, height: number) {\n        const clusterWidth = this.state.clusterWidth\n        const clusterHeigth = this.state.clusterHeight\n\n        let newHeight = height\n        if (this.props.graph.clusters.length < 15) { newHeight -= (clusterHeigth + 20) }\n        else if (this.props.graph.clusters.length > 30) { newHeight += clusterHeigth }\n        const positions = computeClusterPositions(width, newHeight, clusterWidth, clusterHeigth, this.props.graph.clusterSquares)\n        const newHeigth = computeHeigthFromPositions(positions, clusterHeigth);\n\n        const currDimensions = this.state.dimensions ? this.state.dimensions : { w: 500, h: 1000 }\n        currDimensions.h = newHeigth\n        this.setState({ clusterPositions: positions })\n    }\n\n    /** On width change -> recompute nodes positions */\n    onResizeRecomputePositions() {\n        if (isUndefined(this.state.dimensions)) return\n        if (isUndefined(this.state.clusterPositions)) return\n\n        const origWidth = this.state.dimensions.w\n        const origHei = this.state.dimensions.h\n        const newWidth = this.wrapperRef.current.clientWidth\n\n        if (origWidth === newWidth) return\n\n        const currentPositions = this.state.clusterPositions\n        const ratio = Math.floor((newWidth / origWidth) * 1024) / 1024\n        for (let key in currentPositions) {\n            currentPositions[key].x = ratio * currentPositions[key].x\n        }\n\n        this.setState({\n            dimensions: { w: newWidth, h: origHei },\n            clusterPositions: currentPositions\n        })\n    }\n\n    componentDidMount() {\n        window.addEventListener('resize', () => { this.onResizeRecomputePositions() });\n        let width = this.wrapperRef.current.clientWidth;\n        let height = this.wrapperRef.current.clientHeight;\n        this.setState(\n            {\n                dimensions: { w: width, h: height },\n                originalRefWidth: width,\n                originalRefHeight: height\n            },\n            () => this.props.loadGraph(this.props.accessToken, this.props.sp, () => this.graphLoadedCallback(width, height))\n        )\n    }\n\n    componentDidUpdate(prevProps: DraggableCanvasProps, prevState: DraggableCanvasState) {\n        if (this.props.isGraphFromFileLoaded) {\n            let w = 500\n            let h = 500\n            if (!isUndefined(this.state.dimensions)) {\n                w = this.state.dimensions.w\n                h = this.state.dimensions.h\n            }\n            // w = this.state.originalRefWidth \n            h = this.state.originalRefHeight\n            this.graphLoadedCallback(w, h)\n            this.props.graphFromFileIsLoaded(false)\n        }\n    }\n\n    /** Creates node elements */\n    createNodes(): JSX.Element[] {\n        if (this.state.clusterPositions === null || isUndefined(this.state.clusterPositions)) {\n            return []\n        }\n\n        const nodes = []\n        for (let i = 0; i < this.props.graph.clusters.length; i++) {\n            const element = this.props.graph.clusters[i];\n            nodes.push(\n                <ClusterNode\n                    key={element.id}\n                    fontSizeConst={this.state.currentScale}\n                    cluster={element}\n                    positionX={this.state.clusterPositions[element.id].x}\n                    positionY={this.state.clusterPositions[element.id].y}\n                    positionChanged={this.positionChangedHandler}\n                    clusterWidth={this.state.clusterWidth}\n                />\n            )\n        }\n        return nodes\n    }\n\n    /** Creates edge elements */\n    createEdges(): JSX.Element[] {\n        const edges = []\n        if (this.state.clusterPositions == null) {\n            return []\n        }\n\n        for (let i = 0; i < this.props.graph.clusterEdges.length; i++) {\n            const source = this.props.graph.clusterEdges[i].id1\n            const target = this.props.graph.clusterEdges[i].id2\n            const clusterEdgeKey = source + target\n            if (source !== target) {\n                const edgeWeigth = Math.log2(this.props.graph.clusterEdges[i].weight) * 3\n                edges.push(\n                    <ClusterEdge\n                        key={clusterEdgeKey}\n                        x1={this.state.clusterPositions[source].x}\n                        y1={this.state.clusterPositions[source].y}\n                        x2={this.state.clusterPositions[target].x}\n                        y2={this.state.clusterPositions[target].y}\n                        weigth={edgeWeigth}\n                        clusterWidth={this.state.clusterWidth}\n                    />\n                )\n            }\n        }\n\n        return edges\n    }\n\n    createGraphLoadingDiv() {\n        return (\n            <div className=\"page-wrapper\">\n                <div className=\"generic-description\">{this.props.graphLoadingMessage}</div>\n                <ProgressBar progress={this.props.graphLoadingRelatedArtistsProgress} />\n            </div>\n        )\n    }\n\n    createSpotifyErrorDiv() {\n        let message = 'Error while loading!\\n\\n'\n        if (this.props.graphLoadingErrorMessage) {\n            message += this.props.graphLoadingErrorMessage\n        }\n\n        return (\n            <div className=\"page-wrapper\">\n                <div className=\"generic-description\">{message}</div>\n            </div>\n        )\n    }\n\n    render() {\n        if (this.props.graphLoading) {\n            return this.createGraphLoadingDiv()\n        }\n\n        if (this.props.isGraphLoadingError) {\n            return this.createSpotifyErrorDiv()\n        }\n\n        const clusterIsChosen = this.props.chosenCluster !== undefined\n        const display = clusterIsChosen ? \"none\" : \"\"\n        const w = this.state.dimensions ? this.state.dimensions.w : 500\n        const h = this.state.dimensions ? this.state.dimensions.h : 500\n\n        return (\n            <div className=\"wrapper\" ref={this.wrapperRef}>\n                <TransformWrapper\n                    defaultScale={1}\n                    defaultPositionX={1}\n                    defaultPositionY={1}\n                    options={{\n                        maxScale: 4,\n                        limitToWrapper: true,\n                    }}\n                    onWheelStop={(e: any) => { this.setState({ currentScale: e.scale }) }}\n                >\n                    {({\n                        zoomIn,\n                        zoomOut,\n                        setTransform,\n                        ...rest\n                    }: any) => (\n                            <React.Fragment>\n                                {\n                                    clusterIsChosen &&\n                                    <ChosenCluster key={this.props.chosenCluster.id} chosenCluster={this.props.chosenCluster} />\n                                }\n                                <TransformComponent>\n                                    <div className=\"box\" ref={this.boxRef}\n                                        style={{ width: w, height: h, display: display }}\n                                    >\n                                        {\n                                            this.state.dimensions &&\n                                            this.createEdges()\n                                        }\n                                        {\n                                            this.state.dimensions &&\n                                            this.createNodes()\n                                        }\n                                    </div>\n                                </TransformComponent>\n                            </React.Fragment>\n                        )}\n                </TransformWrapper>\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = (state: State) => {\n    return {\n        graphLoaded: state.graphLoaded,\n        graphLoading: state.graphLoading,\n        isGraphLoadingError: state.isGraphLoadingError,\n        graphLoadingMessage: state.graphLoadingMessage,\n        graphLoadingErrorMessage: state.graphLoadingErrorMessage,\n        graphLoadingRelatedArtistsProgress: state.graphLoadingRelatedArtistsProgress,\n        graph: state.graph,\n        chosenCluster: state.chosenCluster,\n\n        accessToken: state.accessToken,\n        sp: state.spotifyWebApiObject,\n\n        isGraphFromFileLoaded: state.isGraphFromFileLoaded\n    }\n}\n\nconst mapDispatchToProps = (dispatch: any) => {\n    return {\n        setGraph: setGraph,\n        graphFromFileIsLoaded: (isLoaded: boolean) => dispatch(graphFromFileIsLoaded(isLoaded)),\n        loadGraph: (accessToken: string, sp: SpotifyWebApi.SpotifyWebApiJs, callback: Function) => dispatch(loadGraph(accessToken, sp, callback))\n    }\n}\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(DraggableCanvas)\n","import React from 'react'\nimport { connect } from 'react-redux'\nimport { isUndefined } from 'util'\n\nimport { State, SongFull, StringDict, ArtistSimplified, ArtistFull } from '../store/types'\nimport { setPaused } from '../store/actions'\n\nimport './draggable-canvas.css'\nimport './styles.css'\n\ninterface PlayerProps {\n    /** Access token to check */\n    accessToken?: string\n    /** Song that will be played */\n    songToPlay?: SongFull\n    /** Is paused? */\n    paused: boolean\n    /** Function to pause the player */\n    setPaused: Function\n    /** Dict of artists that can appear in the not-liked songs. Necessary to show artists' names. */\n    nonFavouriteArtistDict: StringDict<ArtistSimplified>\n    /** Dict of artists in the user's graph */\n    favouriteArtistDict: StringDict<ArtistFull>\n}\n\n/** Audio player that plays the song given in the state.songToPlay */\nclass Player extends React.Component<PlayerProps, {}> {\n    playerRef: any\n    constructor(props: any) {\n        super(props);\n        this.playerRef = React.createRef();\n    }\n\n    componentDidUpdate() {\n        if (this.playerRef.current !== null) {\n            if (this.props.paused) {\n                this.playerRef.current.pause()\n            }\n            else {\n                this.playerRef.current.play()\n            }\n        }\n    }\n        \n    render() {\n        if (isUndefined(this.props.accessToken)) {\n            return (\n                <div></div>\n            )\n        }\n        else if (isUndefined(this.props.songToPlay)) {\n            return (\n                <div className=\"empty-player\">\n                    <div className=\"generic-description-small-margin\">Choose some artist and some song and listen to a preview</div>\n                </div>\n            )\n        }\n        else {\n            let mp3Link = ''\n            let artistsDescriptionNames = []\n            for (let i = 0; i < this.props.songToPlay.artistsIds.length; i++) {\n                const aID = this.props.songToPlay.artistsIds[i];\n                if (aID in this.props.favouriteArtistDict) {\n                    artistsDescriptionNames.push(this.props.favouriteArtistDict[aID].name)\n                }\n                else if (aID in this.props.nonFavouriteArtistDict) {\n                    artistsDescriptionNames.push(this.props.nonFavouriteArtistDict[aID].name)\n                }\n                else {\n                    artistsDescriptionNames.push(aID)\n                }\n            }\n            const artistsDescription = artistsDescriptionNames.join(', ')\n            mp3Link = this.props.songToPlay.previewLink == null ? '' : this.props.songToPlay.previewLink\n\n            return (\n                <div className=\"player\">\n                    <div className=\"flex1\">\n                        <p className=\"playingSongName\"><b>{this.props.songToPlay.name}</b></p>\n                        <p className=\"playingSongArtists\">{artistsDescription}</p>\n                    </div>\n                    <audio onPlay={() => this.props.setPaused(false)}\n                        onPause={() => this.props.setPaused(true)}\n                        ref={this.playerRef}\n                        autoPlay controls src={mp3Link} className=\"playerControls\"\n                    >\n                        Your browser does not support the\n                        <code>audio</code> element.\n                    </audio>\n                </div>\n            )\n        }\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        paused: state.paused,\n        accessToken: state.accessToken,\n        songToPlay: state.songToPlay,\n        favouriteArtistDict: state.graph.artistDict,\n        nonFavouriteArtistDict: state.nonFavouriteArtistDict\n    }),\n    {\n        setPaused\n    }\n)(Player)\n","import * as React from 'react'\n\nimport DraggableCanvas from './draggable-canvas'\nimport Player from './player'\n\nimport './page-content.css'\n\n/** Wrapper to DraggableCanvas and Player */\nclass PageContent extends React.Component<{}, {}> {\n    render() {\n        return (\n            <div className=\"mainDiv\">\n                <div className=\"mainDivContent\">\n                    <DraggableCanvas/>\n                </div>\n                <Player/>\n            </div>\n        )\n    }\n}\n\nexport default PageContent\n","import * as React from 'react'\nimport { connect } from 'react-redux'\nimport { isUndefined } from 'util'\n\nimport { State, StringDict, ArtistFull, Cluster, Graph } from '../store/types'\nimport { loadGraphFromFile } from '../store/actions'\n\nimport './side-bar.css'\nimport './styles.css'\n\ninterface SideBarProps {\n    /** Chosen cluster if any, otherwise undefined */\n    chosenCluster?: Cluster\n    /** Graph object */\n    graph: Graph\n    /** ArtistDict: [artistId]: ArtistFull */\n    artistDict: StringDict<ArtistFull>\n    /** Function to load parse the graph from the file */\n    loadGraphFromFile: Function\n    /** Was graph loaded */\n    graphLoaded: boolean\n\n    graphLoadingError: boolean\n}\n\ninterface SideBarState { }\n\nclass SideBar extends React.Component<SideBarProps, SideBarState> {\n    constructor(props: SideBarProps) {\n        super(props);\n        this.dowloadGraph = this.dowloadGraph.bind(this)\n        this.uploadGraph = this.uploadGraph.bind(this)\n    }\n\n    /** Downloads graph to json file */\n    dowloadGraph() {\n        if (!this.props.graph) return\n\n        const element = document.createElement('a');\n        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(JSON.stringify(this.props.graph, null, 4)));\n        element.setAttribute('download', 'mySpotifyGraph.json');\n        element.style.display = 'none';\n        document.body.appendChild(element);\n        element.click();\n        document.body.removeChild(element);\n    }\n\n    /** Loads a graph from a given file */\n    uploadGraph(selectorFiles: FileList) {\n        const corruptedFileAlert = 'Sorry, this file seems to be not in the correct format.\\n Error:'\n        console.log(selectorFiles)\n        const file = selectorFiles[0]\n        const reader = new FileReader()\n        const loadGraphFromFileFunc = (g: Graph) => (this.props.loadGraphFromFile(g))\n\n        reader.onload = function (event) {\n            if (event.target !== null && event.target.result !== null) {\n                try {\n                    const resultString = event.target.result.toString()\n                    const resultJSON = isUndefined(resultString) ? {} : JSON.parse(resultString)\n                    const g: Graph = resultJSON\n                    loadGraphFromFileFunc(g)\n                } catch (error) {\n                    alert(corruptedFileAlert + error)\n                    console.debug('error while graph loading from file:', error)\n                }\n            }\n            else {\n                alert(corruptedFileAlert)\n            }\n        };\n\n        reader.readAsText(file);\n    }\n\n    /** Enlists names of artists of the chosen cluster */\n    createChosenClusterArtists(): JSX.Element {\n        if (isUndefined(this.props.chosenCluster)) return <div></div>\n\n        return (\n            <ul>{this.props.chosenCluster.artistsIds.map(id =>\n                <li className=\"shift-left\">\n                    {this.props.artistDict[id].name}\n                </li>)}\n            </ul>\n        )\n    }\n\n    /** Enlists genres of artists of the chosen cluster */\n    createChosenClusterGenres(): JSX.Element {\n        let properties: JSX.Element[] = []\n        if (this.props.chosenCluster !== undefined) {\n            properties = this.props.chosenCluster.genres.map(a => <li className=\"shift-left\">{a}</li>)\n        }\n        return <ul>{properties}</ul>\n    }\n\n    render() {\n        return (\n            <div className=\"sideBar\">\n                <div className=\"sideBarHeader\">\n                    <img width={40} height={40} className=\"spotify-image\" alt=\"\" src=\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Ik0xOS4wOTggMTAuNjM4Yy0zLjg2OC0yLjI5Ny0xMC4yNDgtMi41MDgtMTMuOTQxLTEuMzg3LS41OTMuMTgtMS4yMi0uMTU1LTEuMzk5LS43NDgtLjE4LS41OTMuMTU0LTEuMjIuNzQ4LTEuNCA0LjIzOS0xLjI4NyAxMS4yODUtMS4wMzggMTUuNzM4IDEuNjA1LjUzMy4zMTcuNzA4IDEuMDA1LjM5MiAxLjUzOC0uMzE2LjUzMy0xLjAwNS43MDktMS41MzguMzkyem0tLjEyNiAzLjQwM2MtLjI3Mi40NC0uODQ3LjU3OC0xLjI4Ny4zMDgtMy4yMjUtMS45ODItOC4xNDItMi41NTctMTEuOTU4LTEuMzk5LS40OTQuMTUtMS4wMTctLjEyOS0xLjE2Ny0uNjIzLS4xNDktLjQ5NS4xMy0xLjAxNi42MjQtMS4xNjcgNC4zNTgtMS4zMjIgOS43NzYtLjY4MiAxMy40OCAxLjU5NS40NC4yNy41NzguODQ3LjMwOCAxLjI4NnptLTEuNDY5IDMuMjY3Yy0uMjE1LjM1NC0uNjc2LjQ2NS0xLjAyOC4yNDktMi44MTgtMS43MjItNi4zNjUtMi4xMTEtMTAuNTQyLTEuMTU3LS40MDIuMDkyLS44MDMtLjE2LS44OTUtLjU2Mi0uMDkyLS40MDMuMTU5LS44MDQuNTYyLS44OTYgNC41NzEtMS4wNDUgOC40OTItLjU5NSAxMS42NTUgMS4zMzguMzUzLjIxNS40NjQuNjc2LjI0OCAxLjAyOHptLTUuNTAzLTE3LjMwOGMtNi42MjcgMC0xMiA1LjM3My0xMiAxMiAwIDYuNjI4IDUuMzczIDEyIDEyIDEyIDYuNjI4IDAgMTItNS4zNzIgMTItMTIgMC02LjYyNy01LjM3Mi0xMi0xMi0xMnoiLz48L3N2Zz4=\"></img>\n                    <h1>Spotify graph</h1>\n                </div>\n                <div>Graph of your musical taste ♬♫</div>\n\n                {\n                    this.props.graphLoaded &&\n                    <div className=\"download-button pointer\" onClick={this.dowloadGraph}>\n                        Download graph to JSON\n                    </div>\n                }\n                {\n                    (this.props.graphLoaded || this.props.graphLoadingError )&&\n                    <input className=\"download-button\" type=\"file\" accept=\".json\" onChange={(e) => {\n                        if (e.target.files !== null) this.uploadGraph(e.target.files)\n                    }} />\n                }\n\n                <div className=\"sideBarContent\">\n                    {\n                        this.props.chosenCluster &&\n                        <div className=\"box-with-margin\">\n                            <h2>mostly these genres</h2>\n                            {this.createChosenClusterGenres()}\n                        </div>\n                    }\n                    {\n                        this.props.chosenCluster &&\n                        <div className=\"box-with-margin\">\n                            <h2 className=\"text-align-center\">group of artists</h2>\n                            {this.createChosenClusterArtists()}\n                        </div>\n                    }\n\n                    {!!!this.props.chosenCluster && this.props.graph &&\n                        <div className=\"box-with-margin\">\n                            <p>We took the artists from your <b>liked</b> songs and the artists that <b>you follow</b>.</p>\n                            <p>We found <b>{Object.values(this.props.graph.artistDict).length} artist</b> that you like.</p>\n                            <p>We divided them into clusters you're seing right now. The clusters are based on <b>genres</b> and <b>preferences</b> of other users of Spotify</p>\n                            <p>Click the cluster and explore how the artists are connected.</p>\n                        </div>\n                    }\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default connect(\n    (state: State) => ({\n        chosenCluster: state.chosenCluster,\n        graph: state.graph,\n        sp: state.spotifyWebApiObject,\n        artistDict: state.graph.artistDict,\n        graphLoaded: state.graphLoaded,\n        graphLoadingError: state.isGraphLoadingError\n    }),\n    {\n        loadGraphFromFile\n    }\n)(SideBar)\n","import React from 'react'\nimport { Redirect } from \"react-router-dom\";\nimport { connect } from 'react-redux'\nimport { withRouter } from \"react-router-dom\";\nimport { RouteComponentProps } from \"react-router\";\n\nimport PageContent from './page-content'\nimport SideBar from './side-bar'\nimport { State } from '../store/types'\nimport { setAccessToken } from '../store/actions'\n\nimport '../App.css'\n\ninterface MyGraphPageProps extends RouteComponentProps<any> {\n    setAccessToken: typeof setAccessToken\n}\n\ninterface MyGraphPageState {\n    loggingLoading: boolean\n    loggingFailed: boolean\n}\n\n/** The base page. Wrapper to SideBar and PageContent */\nclass MyGraphPage extends React.Component<MyGraphPageProps, MyGraphPageState> {\n    constructor(props: MyGraphPageProps) {\n        super(props);\n        this.state = {\n            loggingLoading: true,\n            loggingFailed: false\n        }\n        /* eslint-disable react/no-direct-mutation-state */\n        this.afterSpotifyLogin()\n    }\n\n    afterSpotifyLogin() {\n        const urlParams = window.location.search\n        var query = urlParams.substr(1);\n        var result: any = {};\n        query.split(\"&\").forEach(function (part: string) {\n            var item = part.split(\"=\");\n            result[item[0]] = decodeURIComponent(item[1]);\n        })\n        if (!('code' in result) || result['code'] === '' || result['code'] === null) {\n            this.state = { loggingFailed: true, loggingLoading: false }\n            return\n        }\n\n        const currentPathName = this.props.history.location.pathname\n        this.props.history.push({\n            pathname: currentPathName,\n            search: ''\n        })\n\n        const linkToBackendWithoutCode = process.env.NODE_ENV === \"production\" ? process.env.REACT_APP_PROD_BACKEND_URL_LOGGED_IN : process.env.REACT_APP_DEV_BACKEND_URL_LOGGED_IN\n        const linkToBackend = linkToBackendWithoutCode + result['code']\n        let accessToken: string = ''\n        fetch(linkToBackend)\n            .then((response) => {\n                if (response.status !== 200) {\n                    throw response.status\n                }\n                const tryAccessToken = response.headers.get('access-token')\n                if (tryAccessToken !== null) {\n                    accessToken = tryAccessToken\n                    this.props.setAccessToken(accessToken)\n                }\n\n                this.setState({ loggingLoading: false })\n            })\n            .catch((error) => {\n                console.debug(error)\n                this.setState({ loggingFailed: true, loggingLoading: false })\n                alert('Sorry, we did not manage to log you in Spotify.')\n            })\n    }\n\n    render() {\n        if (this.state.loggingLoading) {\n            return (\n                <div className=\"App\">\n                    <div className=\"page-wrapper\">\n                        <div className=\"loader\" />\n                        <div className=\"generic-description\">Logging into Spotify</div>\n                    </div>\n                </div>\n            )\n        }\n\n        if (this.state.loggingFailed) {\n            return <Redirect to=\"/login\" />\n        }\n\n        return (\n            <div className=\"App\">\n                <SideBar />\n                <PageContent />\n            </div>\n        )\n    }\n}\n\nexport default withRouter<MyGraphPageProps, any>(\n    connect(\n        (state: State) => ({}),\n        (dispatch: any) => ({\n            setAccessToken: (accessToken: string) => dispatch(setAccessToken(accessToken)),\n        })\n    )(MyGraphPage)\n)\n","import React from 'react'\nimport { Provider } from 'react-redux'\nimport { createStoreInstance } from './store/reducers'\nimport { BrowserRouter, Switch, Route } from \"react-router-dom\";\nimport WelcomePage from './components/welcome-page'\nimport './App.css'\nimport LoginPage from './components/login-page'\nimport MyGraphPage from './components/my-graph-page';\n\nexport const storeInstance = createStoreInstance()\n\nconst App: React.FC = () => {\n    return (\n        <Provider store={storeInstance}>\n            <BrowserRouter basename={process.env.PUBLIC_URL}>\n                <Switch>\n                    <Route path=\"/login\" component={LoginPage} />\n                    <Route path=\"/mygraph\" component={MyGraphPage} />\n                    <Route path=\"/\" component={WelcomePage} />\n                </Switch>\n            </BrowserRouter>\n        </Provider>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n// import * as serviceWorker from './serviceWorker';\n\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}